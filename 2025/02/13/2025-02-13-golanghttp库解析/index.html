<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Golanghttp库解析 | xhang's blog</title><meta name="author" content="xhang"><meta name="copyright" content="xhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 整体框架1.1 C-S架构http 协议下，交互框架是由客户端（Client）和服务端（Server）两个模块组成的 C-S 架构，两个部分正好对应为本文研究的两条主线. 1234567891011121314151617181920212223graph TD    A[Client] --&gt;|HTTP Request| B[http.Client]    B --&gt;|Send">
<meta property="og:type" content="article">
<meta property="og:title" content="Golanghttp库解析">
<meta property="og:url" content="https://blog.740777352.xyz/2025/02/13/2025-02-13-golanghttp%E5%BA%93%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="xhang&#39;s blog">
<meta property="og:description" content="1 整体框架1.1 C-S架构http 协议下，交互框架是由客户端（Client）和服务端（Server）两个模块组成的 C-S 架构，两个部分正好对应为本文研究的两条主线. 1234567891011121314151617181920212223graph TD    A[Client] --&gt;|HTTP Request| B[http.Client]    B --&gt;|Send">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.740777352.xyz/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-02-13T02:09:00.000Z">
<meta property="article:modified_time" content="2025-02-14T02:46:44.897Z">
<meta property="article:author" content="xhang">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.740777352.xyz/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Golanghttp库解析",
  "url": "https://blog.740777352.xyz/2025/02/13/2025-02-13-golanghttp%E5%BA%93%E8%A7%A3%E6%9E%90/",
  "image": "https://blog.740777352.xyz/img/butterfly-icon.png",
  "datePublished": "2025-02-13T02:09:00.000Z",
  "dateModified": "2025-02-14T02:46:44.897Z",
  "author": [
    {
      "@type": "Person",
      "name": "xhang",
      "url": "https://blog.740777352.xyz/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.740777352.xyz/2025/02/13/2025-02-13-golanghttp%E5%BA%93%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Golanghttp库解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">xhang's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Golanghttp库解析</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Golanghttp库解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-13T02:09:00.000Z" title="发表于 2025-02-13 10:09:00">2025-02-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-14T02:46:44.897Z" title="更新于 2025-02-14 10:46:44">2025-02-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="1-整体框架"><a href="#1-整体框架" class="headerlink" title="1 整体框架"></a>1 整体框架</h1><h2 id="1-1-C-S架构"><a href="#1-1-C-S架构" class="headerlink" title="1.1 C-S架构"></a>1.1 C-S架构</h2><p>http 协议下，交互框架是由客户端（Client）和服务端（Server）两个模块组成的 C-S 架构，两个部分正好对应为本文研究的两条主线.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Client] --&gt;|HTTP Request| B[http.Client]</span><br><span class="line">    B --&gt;|Send Request| C[Transport]</span><br><span class="line">    C --&gt;|Dial| D[Network]</span><br><span class="line">    D --&gt;|Send to Server| E[Server]</span><br><span class="line">    E --&gt;|Handle Request| F[http.ServeMux]</span><br><span class="line">    F --&gt;|Call Handler| G[Handler Function]</span><br><span class="line">    G --&gt;|Generate Response| H[Response]</span><br><span class="line">    H --&gt;|Send Response| E</span><br><span class="line">    E --&gt;|Return Response| D</span><br><span class="line">    D --&gt;|Return to Client| C</span><br><span class="line">    C --&gt;|Return Response| B</span><br><span class="line">    B --&gt;|Receive Response| A</span><br><span class="line"></span><br><span class="line">    subgraph Server Flow</span><br><span class="line">        E --&gt;|Listen for Request| D</span><br><span class="line">        D --&gt;|Handle Incoming Connections| E</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph Client Flow</span><br><span class="line">        A --&gt;|Create Request| B</span><br><span class="line">        B --&gt;|Set Headers/Params| B</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<h2 id="1-2-启动-http-服务"><a href="#1-2-启动-http-服务" class="headerlink" title="1.2 启动 http 服务"></a>1.2 启动 http 服务</h2><p>在 Golang 启动一个 http 服务只需寥寥数笔，非常方便，代码示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;pong&quot;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8091&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，完成了两件事：</p>
<ul>
<li> 调用 http.HandleFunc 方法，注册了对应于请求路径 &#x2F;ping 的 handler 函数</li>
<li> 调用 http.ListenAndServe，启动了一个端口为 8091 的 http 服务</li>
</ul>
<p>如此简洁轻便即实现了一个 http server 的启动，其背后究竟隐藏了哪些实施细节呢. 这个问题，就让我们在第 2 章的内容中，和大家一同展开探讨.</p>
<h2 id="1-3-发送-http-请求"><a href="#1-3-发送-http-请求" class="headerlink" title="1.3 发送 http 请求"></a>1.3 发送 http 请求</h2><p>在 Golang 中发送 http 请求的实现同样非常简单. 下面给出一例发送 JSON POST 请求的代码示例.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    reqBody, _ := json.Marshal(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;key1&quot;</span>: <span class="string">&quot;val1&quot;</span>, <span class="string">&quot;key2&quot;</span>: <span class="string">&quot;val2&quot;</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    resp, _ := http.Post(<span class="string">&quot;:8091&quot;</span>, <span class="string">&quot;application/json&quot;</span>, bytes.NewReader(reqBody))</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    </span><br><span class="line">    respBody, _ := io.ReadAll(resp.Body)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;resp: %s&quot;</span>, respBody)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分将作为本文的第二条线索，放在第 3 章中展开讨论.</p>
<h2 id="1-4-源码位置一览"><a href="#1-4-源码位置一览" class="headerlink" title="1.4 源码位置一览"></a>1.4 源码位置一览</h2><p>本文涉及内容的源码均位于 net&#x2F;http 库下，各模块的文件位置如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>模块</strong></th>
<th><strong>文件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>服务端</td>
<td>net&#x2F;http&#x2F;server.go</td>
</tr>
<tr>
<td>客户端——主流程</td>
<td>net&#x2F;http&#x2F;client.go</td>
</tr>
<tr>
<td>客户端——构造请求</td>
<td>net&#x2F;http&#x2F;request.go</td>
</tr>
<tr>
<td>客户端——网络交互</td>
<td>net&#x2F;http&#x2F;transport.go</td>
</tr>
</tbody></table>
<h1 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2 服务端"></a>2 服务端</h1><h2 id="2-1-核心数据结构"><a href="#2-1-核心数据结构" class="headerlink" title="2.1 核心数据结构"></a>2.1 核心数据结构</h2><p>首先对 http 服务端模块涉及的核心数据结构作简要介绍.</p>
<p>（1）Server</p>
<p>基于面向对象的思想，整个 http 服务端模块被封装在 Server 类当中.</p>
<p>Handler 是 Server 中最核心的成员字段，实现了从请求路径 path 到具体处理函数 handler 的注册和映射能力.</p>
<p>在用户构造 Server 对象时，倘若其中的 Handler 字段未显式声明，则会取 net&#x2F;http 包下的单例对象 DefaultServeMux（ServerMux 类型） 进行兜底.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// server 的地址</span></span><br><span class="line">    Addr <span class="type">string</span></span><br><span class="line">    <span class="comment">// 路由处理器.</span></span><br><span class="line">    Handler Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）Handler</p>
<p>Handler 是一个 interface，定义了方法： ServeHTTP.</p>
<p>该方法的作用是，根据 http 请求 Request 中的请求路径 path 映射到对应的 handler 处理函数，对请求进行处理和响应.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;    </span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）ServeMux</p>
<p>ServeMux 是对 Handler 的具体实现，内部通过一个 map 维护了从 path 到 handler 的映射关系.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]muxEntry</span><br><span class="line">    es []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">    hosts <span class="type">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）muxEntry</p>
<p>muxEntry 为一个 handler 单元，内部包含了请求路径 path + 处理函数 handler 两部分.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    h Handler</span><br><span class="line">    pattern <span class="type">string</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-注册-handler"><a href="#2-2-注册-handler" class="headerlink" title="2.2 注册 handler"></a>2.2 注册 handler</h2><p>首先给出服务端注册 handler 的主干链路，避免晕车.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Server] --&gt;|Create Mux| B[http.ServeMux]</span><br><span class="line">    B --&gt;|Register Route| C[HandleFunc]</span><br><span class="line">    C --&gt;|Set Handler| D[http.Handler]</span><br><span class="line">    D --&gt;|Invoke| E[Handler Function]</span><br><span class="line">    E --&gt;|Generate Response| F[Response]</span><br><span class="line">    F --&gt;|Return to Mux| B</span><br><span class="line">    B --&gt;|Send Response| G[Client]</span><br><span class="line">    </span><br><span class="line">    subgraph Handler Registration</span><br><span class="line">        A --&gt;|Listen on Port| H[http.ListenAndServe]</span><br><span class="line">        H --&gt;|Attach Mux| B</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p>在 net&#x2F;http 包下声明了一个单例 ServeMux，当用户直接通过公开方法 http.HandleFunc 注册 handler 时，则会将其注册到 DefaultServeMux 当中.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123; </span><br><span class="line"></span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ServeMux.HandleFunc 内部会将处理函数 handler 转为实现了 ServeHTTP 方法的 HandlerFunc 类型，将其作为 Handler interface 的实现类注册到 ServeMux 的路由 map 当中.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).  实现Handler的interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> HandleFunc(pattern <span class="type">string</span>, handler <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现路由注册的核心逻辑位于 ServeMux.Handle 方法中，两个核心逻辑值得一提：</p>
<ul>
<li><p>将 path 和 handler 包装成一个 muxEntry，以 path 为 key 注册到路由 map ServeMux.m 中</p>
</li>
<li><p>响应模糊匹配机制. 对于以 ‘&#x2F;‘ 结尾的 path，根据 path 长度将 muxEntry 有序插入到数组 ServeMux.es 中.（模糊匹配机制的伏笔在 2.3 小节回收）</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> Handle(pattern <span class="type">string</span>, handler Handler) &#123;</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">    mux.m[pattern] = e</span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">        mux.es = appendSorted(mux.es, e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSorted</span><span class="params">(es []muxEntry, e muxEntry)</span></span> []muxEntry &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(es)</span><br><span class="line">    i := sort.Search(n, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(es[i].pattern) &lt; <span class="built_in">len</span>(e.pattern)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> i == n &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">append</span>(es, e)</span><br><span class="line">    &#125;</span><br><span class="line">    es = <span class="built_in">append</span>(es, muxEntry&#123;&#125;) <span class="comment">// try to grow the slice in place, any entry works.</span></span><br><span class="line">    <span class="built_in">copy</span>(es[i+<span class="number">1</span>:], es[i:])      <span class="comment">// Move shorter entries down</span></span><br><span class="line">    es[i] = e</span><br><span class="line">    <span class="keyword">return</span> es</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-启动-server"><a href="#2-3-启动-server" class="headerlink" title="2.3 启动 server"></a>2.3 启动 server</h2><p>调用 net&#x2F;http 包下的公开方法 ListenAndServe，可以实现对服务端的一键启动. 内部会声明一个新的 Server 对象，嵌套执行 Server.ListenAndServe 方法.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server.ListenAndServe 方法中，根据用户传入的端口，申请到一个监听器 listener，继而调用 Server.Serve 方法.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> ListenAndServe() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    addr := srv.Addr</span><br><span class="line">    <span class="keyword">if</span> addr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        addr = <span class="string">&quot;:http&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ln, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="keyword">return</span> srv.Serve(ln)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Server.Serve开始] --&gt;|创建Context| B[添加Server到Context]</span><br><span class="line">    B --&gt; C[进入For循环]</span><br><span class="line">    C --&gt;|阻塞等待| D[Listener.Accept]</span><br><span class="line">    D --&gt;|新连接到达| E[创建新的conn]</span><br><span class="line">    E --&gt;|异步处理| F[启动goroutine]</span><br><span class="line">    F --&gt; G[执行conn.serve]</span><br><span class="line">    G --&gt; H[处理请求]</span><br><span class="line">    H --&gt; I[返回响应]</span><br><span class="line">    I --&gt; J[关闭连接]</span><br><span class="line">    </span><br><span class="line">    C --&gt;|继续循环| D</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;每个连接的处理流程&quot;</span><br><span class="line">        F</span><br><span class="line">        G</span><br><span class="line">        H </span><br><span class="line">        I</span><br><span class="line">        J</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;主循环&quot;</span><br><span class="line">        C</span><br><span class="line">        D</span><br><span class="line">        E</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p>Server.Serve 方法很核心，体现了 http 服务端的运行架构：for + listener.accept 模式.</p>
<ul>
<li>将 server 封装成一组 kv 对，添加到 context 当中</li>
<li>开启 for 循环，每轮循环调用 Listener.Accept 方法阻塞等待新连接到达</li>
<li>每有一个连接到达，创建一个 goroutine 异步执行 conn.serve 方法负责处理</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ServerContextKey = &amp;contextKey&#123;<span class="string">&quot;http-server&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> contextKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, err := l.Accept()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        connCtx := ctx</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(connCtx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>conn.serve 是响应客户端连接的核心方法：</p>
<ul>
<li>从 conn 中读取到封装到 response 结构体，以及请求参数 http.Request</li>
<li>调用 serveHandler.ServeHTTP 方法，根据请求的 path 为其分配 handler</li>
<li>通过特定 handler 处理并响应请求</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> serve(ctx context.Context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    c.r = &amp;connReader&#123;conn: c&#125;</span><br><span class="line">    c.bufr = newBufioReader(c.r)</span><br><span class="line">    c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        w, err := c.readRequest(ctx)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">        w.cancelCtx()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 serveHandler.ServeHTTP 方法中，会对 Handler 作判断，倘若其未声明，则取全局单例 DefaultServeMux 进行路由匹配，呼应了 http.HandleFunc 中的处理细节.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span></span> ServeHTTP(rw ResponseWriter, req *Request) &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![[..&#x2F;pictures&#x2F;servehttp.png]]</p>
<p>接下来，兜兜转转依次调用 ServeMux.ServeHTTP、ServeMux.Handler、ServeMux.handler 等方法，最终在 ServeMux.match 方法中，以 Request 中的 path 为 pattern，在路由字典 Server.m 中匹配 handler，最后调用 handler.ServeHTTP 方法进行请求的处理和响应.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> Handler(r *Request) (h Handler, pattern <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> handler(host, path <span class="type">string</span>) (h Handler, pattern <span class="type">string</span>) &#123;</span><br><span class="line">    mux.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    h, pattern = mux.match(path)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，当通过路由字典 Server.m 未命中 handler 时，此时会启动模糊匹配模式，两个核心规则如下：</p>
<ul>
<li>以 ‘&#x2F;‘ 结尾的 pattern 才能被添加到 Server.es 数组中，才有资格参与模糊匹配</li>
<li>模糊匹配时，会找到一个与请求路径 path 前缀完全匹配且长度最长的 pattern，其对应的handler 会作为本次请求的处理函数.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> match(path <span class="type">string</span>) (h Handler, pattern <span class="type">string</span>) &#123;</span><br><span class="line">    v, ok := mux.m[path]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServeMux.es 本身是按照 pattern 的长度由大到小排列的</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> mux.es &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.HasPrefix(path, e.pattern) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.h, e.pattern</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，2.2 小节中模糊匹配问题的伏笔回收.</p>
<h1 id="3-客户端"><a href="#3-客户端" class="headerlink" title="3 客户端"></a>3 客户端</h1><h2 id="3-1-核心数据结构"><a href="#3-1-核心数据结构" class="headerlink" title="3.1 核心数据结构"></a>3.1 核心数据结构</h2><p>（1）Client</p>
<p>与 Server 对仗，客户端模块也有一个 Client 类，实现对整个模块的封装：</p>
<ul>
<li>Transport：负责 http 通信的核心部分，也是接下来的讨论重点</li>
<li>Jar：cookie 管理</li>
<li>Timeout：超时设置</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Transport RoundTripper</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Jar CookieJar</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）RoundTripper</p>
<p>RoundTripper 是通信模块的 interface，需要实现方法 Roundtrip，即通过传入请求 Request，与服务端交互后获得响应 Response.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> &#123;    </span><br><span class="line">	RoundTrip(*Request) (*Response, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）Transport</p>
<p>Tranport 是 RoundTripper 的实现类，核心字段包括：</p>
<ul>
<li>idleConn：空闲连接 map，实现复用</li>
<li>DialContext：新连接生成器</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> &#123;</span><br><span class="line">    idleConn     <span class="keyword">map</span>[connectMethodKey][]*persistConn <span class="comment">// most recently used at end</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    DialContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）Request</p>
<p>http 请求参数结构体.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    Method <span class="type">string</span></span><br><span class="line">    <span class="comment">// 请求路径</span></span><br><span class="line">    URL *url.URL</span><br><span class="line">    <span class="comment">// 请求头</span></span><br><span class="line">    Header Header</span><br><span class="line">    <span class="comment">// 请求参数内容</span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line">    <span class="comment">// 服务器主机</span></span><br><span class="line">    Host <span class="type">string</span></span><br><span class="line">    <span class="comment">// query 请求参数</span></span><br><span class="line">    Form url.Values</span><br><span class="line">    <span class="comment">// 响应参数 struct</span></span><br><span class="line">    Response *Response</span><br><span class="line">    <span class="comment">// 请求链路的上下文</span></span><br><span class="line">    ctx context.Context</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）Response</p>
<p>http 响应参数结构体.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 请求状态，200 为 请求成功</span></span><br><span class="line">    StatusCode <span class="type">int</span>    <span class="comment">// e.g. 200</span></span><br><span class="line">    <span class="comment">// http 协议，如：HTTP/1.0</span></span><br><span class="line">    Proto      <span class="type">string</span> <span class="comment">// e.g. &quot;HTTP/1.0&quot;</span></span><br><span class="line">    <span class="comment">// 请求头</span></span><br><span class="line">    Header Header</span><br><span class="line">    <span class="comment">// 响应参数内容  </span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line">    <span class="comment">// 指向请求参数</span></span><br><span class="line">    Request *Request</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-方法链路总览"><a href="#3-2-方法链路总览" class="headerlink" title="3.2 方法链路总览"></a>3.2 方法链路总览</h2><p>客户端发起一次 http 请求大致分为几个步骤：</p>
<ul>
<li>• 构造 http 请求参数</li>
<li>• 获取用于与服务端交互的 tcp 连接</li>
<li>• 通过 tcp 连接发送请求参数</li>
<li>• 通过 tcp 连接接收响应结果</li>
</ul>
<p>整体方法链路如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[客户端代码] --&gt;|NewRequest| B[http.NewRequest]</span><br><span class="line">    B --&gt;|Do| C[http.Client]</span><br><span class="line">    C --&gt;|Transport.RoundTrip| D[http.Transport]</span><br><span class="line">    D --&gt;|Dial| E[net.Dial]</span><br><span class="line">    E --&gt;|Establish TCP Connection| F[TCP 连接]</span><br><span class="line">    F --&gt;|Write| G[TCP Conn.Write]</span><br><span class="line">    G --&gt;|Send HTTP Request| H[HTTP 服务器]</span><br><span class="line">    H --&gt;|Process Request| I[HTTP 响应]</span><br><span class="line">    I --&gt;|Read| J[TCP Conn.Read]</span><br><span class="line">    J --&gt;|Return Response| D</span><br><span class="line">    D --&gt;|Return Response| C</span><br><span class="line">    C --&gt;|Handle Response| A</span><br><span class="line"></span><br><span class="line">    subgraph 客户端</span><br><span class="line">        A --&gt; B</span><br><span class="line">        B --&gt; C</span><br><span class="line">        C --&gt; D</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 网络层</span><br><span class="line">        D --&gt; E</span><br><span class="line">        E --&gt; F</span><br><span class="line">        F --&gt; G</span><br><span class="line">        G --&gt; J</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 服务器</span><br><span class="line">        H --&gt; I</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 客户端</span><br><span class="line">        D --&gt; C</span><br><span class="line">        C --&gt; A</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<h2 id="3-3-Client-Post"><a href="#3-3-Client-Post" class="headerlink" title="3.3 Client.Post"></a>3.3 Client.Post</h2><p>调用 net&#x2F;http 包下的公开方法 Post 时，需要传入服务端地址 url，请求参数格式 contentType 以及请求参数的 io reader.</p>
<p>方法中会使用包下的单例客户端 DefaultClient 处理这次请求.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultClient = &amp;Client&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Post</span><span class="params">(url, contentType <span class="type">string</span>, body io.Reader)</span></span> (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultClient.Post(url, contentType, body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Client.Post 方法中，首先会结合用户的入参，构造出完整的请求参数 Request；继而通过 Client.Do 方法，处理这笔请求.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Post(url, contentType <span class="type">string</span>, body io.Reader) (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">    req, err := NewRequest(<span class="string">&quot;POST&quot;</span>, url, body)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, contentType)</span><br><span class="line">    <span class="keyword">return</span> c.Do(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-NewRequest"><a href="#3-4-NewRequest" class="headerlink" title="3.4 NewRequest"></a>3.4 NewRequest</h2><p>NewRequestWithContext 方法中，根据用户传入的 url、method等信息，构造了 Request 实例.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequestWithContext</span><span class="params">(ctx context.Context, method, url <span class="type">string</span>, body io.Reader)</span></span> (*Request, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    u, err := urlpkg.Parse(url)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    rc, ok := body.(io.ReadCloser)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    req := &amp;Request&#123;</span><br><span class="line">        ctx:        ctx,</span><br><span class="line">        Method:     method,</span><br><span class="line">        URL:        u,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Header:     <span class="built_in">make</span>(Header),</span><br><span class="line">        Body:       rc,</span><br><span class="line">        Host:       u.Host,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-Client-Do"><a href="#3-5-Client-Do" class="headerlink" title="3.5 Client.Do"></a>3.5 Client.Do</h2><p>发送请求方法时，经由 Client.Do、Client.do 辗转，继而步入到 Client.send 方法中.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Do(req *Request) (*Response, <span class="type">error</span>) &#123;     </span><br><span class="line">	<span class="keyword">return</span> c.do(req) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> do(req *Request) (retres *Response, reterr <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        deadline      = c.deadline()</span><br><span class="line">        resp          *Response</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    )    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">var</span> err <span class="type">error</span>       </span><br><span class="line">        <span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Client.send 方法中，会在通过 send 方法发送请求之前和之后，分别对 cookie 进行更新.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> send(req *Request, deadline time.Time) (resp *Response, didTimeout <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置 cookie 到请求头中</span></span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">            req.AddCookie(cookie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 resp 的 cookie 到请求头中</span></span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用 send 方法时，需要注入 RoundTripper 模块，默认会使用全局单例 DefaultTransport 进行注入，核心逻辑位于 Transport.RoundTrip 方法中，其中分为两个步骤：</p>
<ul>
<li>• 获取&#x2F;构造 tcp 连接</li>
<li>• 通过 tcp 连接完成与服务端的交互</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    DialContext: defaultTransportDialContext(&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">        KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> transport() RoundTripper &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Transport</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span> (resp *Response, didTimeout <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    resp, err = rt.RoundTrip(req)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> RoundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;    </span><br><span class="line">	<span class="keyword">return</span> t.roundTrip(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> roundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> &#123;          </span><br><span class="line">        <span class="comment">// ...    </span></span><br><span class="line">        treq := &amp;transportRequest&#123;Request: req, trace: trace, cancelKey: cancelKey&#125;      </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pconn, err := t.getConn(treq, cm)        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        resp, err = pconn.roundTrip(treq)          </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-Transport-getConn"><a href="#3-6-Transport-getConn" class="headerlink" title="3.6 Transport.getConn"></a>3.6 Transport.getConn</h2><p>获取 tcp 连接的策略分为两步：</p>
<ul>
<li>• 通过 queueForIdleConn 方法，尝试复用采用相同协议、访问相同服务端的空闲连接</li>
<li>• 倘若无可用连接，则通过 queueForDial 方法，异步创建一个新的连接，并通过接收 ready channel 信号的方式，确认构造连接的工作已经完成.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取连接的请求参数体</span></span><br><span class="line">    w := &amp;wantConn&#123;</span><br><span class="line">        cm:         cm,</span><br><span class="line">        <span class="comment">// key 由 http 协议、服务端地址等信息组成</span></span><br><span class="line">        key:        cm.key(),</span><br><span class="line">        ctx:        ctx,</span><br><span class="line">        <span class="comment">// 标识连接构造成功的信号发射器</span></span><br><span class="line">        ready:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倘若连接获取失败，在 wantConn.cancel 方法中，会尝试将 tcp 连接放回队列中以供后续复用</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            w.cancel(t, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 尝试复用指向相同服务端地址的空闲连接</span></span><br><span class="line">    <span class="keyword">if</span> delivered := t.queueForIdleConn(w); delivered &#123;</span><br><span class="line">        pc := w.pc</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步构造新的连接</span></span><br><span class="line">    t.queueForDial(w)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 通过阻塞等待信号的方式，等待连接获取完成</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-w.ready:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> w.pc, w.err</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）复用连接</p>
<ul>
<li>• 尝试从 Transport.idleConn 中获取指向同一服务端的空闲连接 persisConn</li>
<li>• 获取到连接后会调用 wantConn.tryDeliver 方法将连接绑定到 wantConn 请求参数上</li>
<li>• 绑定成功后，会关闭 wantConn.ready channel，以唤醒阻塞读取该 channel 的 goroutine</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> queueForIdleConn(w *wantConn) (delivered <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> list, ok := t.idleConn[w.key]; ok &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(list) &gt; <span class="number">0</span> &amp;&amp; !stop &#123;</span><br><span class="line">            pconn := list[<span class="built_in">len</span>(list)<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            delivered = w.tryDeliver(pconn, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> delivered &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                list = list[:<span class="built_in">len</span>(list)<span class="number">-1</span>]               </span><br><span class="line">            &#125;</span><br><span class="line">            stop = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> stop &#123;</span><br><span class="line">            <span class="keyword">return</span> delivered</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wantConn)</span></span> tryDeliver(pc *persistConn, err <span class="type">error</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    w.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> w.mu.Unlock()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    w.pc = pc</span><br><span class="line">    w.err = err</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">close</span>(w.ready)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）创建连接</p>
<p>在 queueForDial 方法会异步调用 Transport.dialConnFor 方法，创建新的 tcp 连接. 由于是异步操作，所以在上游会通过读 channel 的方式，等待创建操作完成.</p>
<p>这里之所以采用异步操作进行连接创建，有两部分原因：</p>
<ul>
<li>• 一个 tcp 连接并不是一个静态的数据结构，它是有生命周期的，创建过程中会为其创建负责读写的两个守护协程，伴随而生</li>
<li>• 在上游 Transport.queueForIdleConn 方法中，当通过 select 多路复用的方式，接收到其他终止信号时，可以提前调用 wantConn.cancel 方法打断创建连接的 goroutine. 相比于串行化执行而言，这种异步交互的模式，具有更高的灵活度</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> queueForDial(w *wantConn) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">go</span> t.dialConnFor(w) </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transport.dialConnFor 方法中，首先调用 Transport.dialConn 创建 tcp 连接 persisConn，接着执行 wantConn.tryDeliver 方法，将连接绑定到 wantConn 上，然后通过关闭 ready channel 操作唤醒上游读 ready channel 的 goroutine.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dialConnFor(w *wantConn) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pc, err := t.dialConn(w.ctx, w.cm)</span><br><span class="line">    delivered := w.tryDeliver(pc, err)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Transport.dialConn 方法包含了创建连接的核心逻辑：</p>
<ul>
<li>• 调用 Transport.dial 方法，最终通过 Tranport.DialContext 成员函数，创建好 tcp 连接，封装到 persistConn 当中</li>
<li>• 异步启动连接的伴生读写协程 readLoop 和 writeLoop 方法，组成提交请求、接收响应的循环</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">    pconn = &amp;persistConn&#123;</span><br><span class="line">        t:             t,</span><br><span class="line">        reqch:         <span class="built_in">make</span>(<span class="keyword">chan</span> requestAndChan, <span class="number">1</span>),</span><br><span class="line">        writech:       <span class="built_in">make</span>(<span class="keyword">chan</span> writeRequest, <span class="number">1</span>),</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conn, err := t.dial(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pconn.conn = conn      </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">    <span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">    <span class="keyword">return</span> pconn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dial(ctx context.Context, network, addr <span class="type">string</span>) (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> t.DialContext(ctx, network, addr)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在伴生读协程 persisConn.readLoop 方法中，会读取来自服务端的响应，并添加到 persistConn.reqCh 中，供上游 persistConn.roundTrip 方法接收.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> readLoop() &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    alive := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> alive &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        rc := &lt;-pc.reqch</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">var</span> resp *Response</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        resp, err = pc.readResponse(rc, trace)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">select</span>&#123;</span><br><span class="line">            rc.ch &lt;- responseAndError&#123;res: resp&#125;:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...        </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>    </p>
<p>（3）归还连接</p>
<p>有复用连接的能力，就必然存在归还连接的机制.</p>
<p>首先，在构造新连接中途，倘若被打断，则可能会将连接放回队列以供复用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 倘若连接获取失败，在 wantConn.cancel 方法中，会尝试将 tcp 连接放回队列中以供后续复用</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            w.cancel(t, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wantConn)</span></span> cancel(t *Transport, err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> pc != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.putOrCloseIdleConn(pc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> tryPutIdleConn(pconn *persistConn) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    key := pconn.cacheKey</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    t.idleConn[key] = <span class="built_in">append</span>(idles, pconn)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，倘若与服务端的一轮交互流程结束，也会将连接放回队列以供复用.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> readLoop() &#123;</span><br><span class="line">    tryPutIdleConn := <span class="function"><span class="keyword">func</span><span class="params">(trace *httptrace.ClientTrace)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := pc.t.tryPutIdleConn(pc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    alive := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> alive &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> bodyEOF := &lt;-waitForBodyRead:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            tryPutIdleConn(trace)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> putOrCloseIdleConn(pconn *persistConn) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := t.tryPutIdleConn(pconn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        pconn.<span class="built_in">close</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-persistConn-roundTrip"><a href="#3-7-persistConn-roundTrip" class="headerlink" title="3.7 persistConn.roundTrip"></a>3.7 persistConn.roundTrip</h2><p>3.6 小节中谈到，一个连接 persistConn 是一个具有生命特征的角色. 它本身伴有 readLoop 和 writeLoop 两个守护协程，与上游应用者之间通过 channel 进行读写交互.</p>
<p>而其中扮演应用者这一角色的，正式本小节谈到的主流程中的方法：persistConn.roundTrip：</p>
<ul>
<li>• 首先将 http 请求通过 persistConn.writech 发送给连接的守护协程 writeLoop，并进一步传送到服务端</li>
<li>• 其次通过读取 resc channel，接收由守护协程 readLoop 代理转发的客户端响应数据.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> roundTrip(req *transportRequest) (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pc.writech &lt;- writeRequest&#123;req, writeErrCh, continueCh&#125;</span><br><span class="line">    resc := <span class="built_in">make</span>(<span class="keyword">chan</span> responseAndError)</span><br><span class="line">    pc.reqch &lt;- requestAndChan&#123;</span><br><span class="line">        req:        req.Request,</span><br><span class="line">        cancelKey:  req.cancelKey,</span><br><span class="line">        ch:         resc,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> &#123;    </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> re := &lt;-resc:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> re.res, <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>graph TD<br>    A[Server.Serve开始] –&gt;|创建Context| B[添加Server到Context]<br>    B –&gt; C[进入For循环]<br>    C –&gt;|阻塞等待| D[Listener.Accept]<br>    D –&gt;|新连接到达| E[创建新的conn]<br>    E –&gt;|异步处理| F[启动goroutine]<br>    F –&gt; G[执行conn.serve]<br>    G –&gt; H[处理请求]<br>    H –&gt; I[返回响应]<br>    I –&gt; J[关闭连接]</p>
<pre><code>C --&gt;|继续循环| D

subgraph &quot;每个连接的处理流程&quot;
    F
    G
    H 
    I
    J
end

subgraph &quot;主循环&quot;
    C
    D
    E
end
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.740777352.xyz">xhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.740777352.xyz/2025/02/13/2025-02-13-golanghttp%E5%BA%93%E8%A7%A3%E6%9E%90/">https://blog.740777352.xyz/2025/02/13/2025-02-13-golanghttp%E5%BA%93%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.740777352.xyz" target="_blank">xhang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/13/2025-02-13-etcdctl%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/" title="etcdctl命令整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">etcdctl命令整理</div></div><div class="info-2"><div class="info-item-1">etcdctl 是 etcd 的命令行客户端工具，用于与 etcd 集群进行交互。下面是 etcdctl 的一些常用选项和命令，帮助你进行数据存取和集群管理等操作。 常用选项在执行任何 etcdctl 命令时，你通常需要指定以下选项来配置连接参数：  --endpoints=[]：指定 etcd 集群的一个或多个端点地址，通常是 http://ip:port 格式。 --cacert=&quot;&quot;：指定根证书文件路径，用于 TLS 连接。 --cert=&quot;&quot;：指定客户端证书文件路径，用于 TLS 连接。 --key=&quot;&quot;：指定客户端私钥文件路径，用于 TLS 连接。 --user=&quot;&quot;：指定用户名和密码，格式为 username:password，用于身份验证。 --dial-timeout=&quot;&quot;：指定建立连接的超时时长。 --command-timeout=&quot;&quot;：指定命令执行的超时时长。  常用命令数据操作命令 put &lt;key&gt;...</div></div></div></a><a class="pagination-related" href="/2025/02/13/etcd-tools/" title="etcd 工具和客户端库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">etcd 工具和客户端库</div></div><div class="info-2"><div class="info-item-1">以下是关于 etcd 工具和客户端库的汇总翻译自：https://etcd.io/docs/v3.5/integrations/ 库和工具etcd 工具和客户端库列表。请注意，以下提到的第三方库和工具（不托管在 https://github.com/etcd-io 上）没有经过 etcd 团队的测试和维护。在使用它们之前，建议用户先阅读和调查这些库和工具。 工具 etcdctl - etcd 的命令行客户端。 etcd-dump - 用于转储&#x2F;恢复 etcd 的命令行工具。 etcd-fs - 基于 FUSE 的 etcd 文件系统。 etcddir - 实时同步 etcd 和本地目录，适用于 Windows 和 Linux。 etcd-browser - 一个基于 AngularJS 的 etcd 网页键值编辑器。 etcd-lock - 使用 etcd 实现的主节点选举和分布式读&#x2F;写锁，支持 v2。 etcd-console - 一个基于 PHP 的 etcd 网页键值编辑器。 etcd-viewer - 用 Java 编写的 etcd...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/11/2025-02-11-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day01/" title="Golang整体复习Day01"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-11</div><div class="info-item-2">Golang整体复习Day01</div></div><div class="info-2"><div class="info-item-1">abstract由于笔者工作与开发关系不大，因此已有许久没有复习过golang的语法和用例，最近在对运维平台的梳理过程中，想要用golang来做一下后端的实现，奈何基础知识基本上忘光了，连ai写都写不下去，故此开始复习一下相关内容，顺便整理一下之前杂乱的笔记。   0.从零开始搭建Go环境0.1 安装Go下载下载地址Go官网下载地址：https://golang.org/dl/ Go官方镜像站（推荐）：https://golang.google.cn/dl/ 版本的选择Windows平台和Mac平台推荐下载可执行文件版，Linux平台下载压缩文件版。 笔者使用的是macos平台，因此下载的是go1.23.6.darwin-amd64.pkg这个版本。  安装双击下载的pkg文件，按照提示安装即可。 配置环境变量笔者使用的是macos平台，因此需要配置环境变量。 在终端输入以下命令： 12echo &#x27;export PATH=&quot;$PATH:/usr/local/go/bin&quot;&#x27; &gt;&gt; ~/.zshrcsource...</div></div></div></a><a class="pagination-related" href="/2025/02/12/2025-02-12-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day03/" title="Golang整体复习Day03"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-12</div><div class="info-item-2">Golang整体复习Day03</div></div><div class="info-2"><div class="info-item-1">流程控制if else(分支结构)if条件判断基本写法Go语言中if条件判断的格式如下： 1234567if 表达式1 &#123;    分支1&#125; else if 表达式2 &#123;    分支2&#125; else&#123;    分支3&#125;  当表达式1的结果为true时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的else if和else都是可选的，可以根据实际需要进行选择。 Go语言规定与if匹配的左括号&#123;必须与if和表达式放在同一行，&#123;放在其他位置会触发编译错误。 同理，与else匹配的&#123;也必须与else写在同一行，else也必须与上一个if或else if右边的大括号在同一行。 举个例子： 12345678910func ifDemo1() &#123;	score := 65	if score &gt;= 90 &#123;		fmt.Println(&quot;A&quot;)	&#125; else if score &gt; 75...</div></div></div></a><a class="pagination-related" href="/2025/02/12/2025-02-12-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day02/" title="Golang整体复习Day02"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-12</div><div class="info-item-2">Golang整体复习Day02</div></div><div class="info-2"><div class="info-item-1">标识符与关键字标识符在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和_(下划线）组成，并且只能以字母和_开头。 举几个例子：abc, _, _123, a123。 关键字关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。 Go语言中有25个关键字： 12345break        default      func         interface    selectcase         defer        go           map          structchan         else         goto         package      switchconst        fallthrough  if           range        typecontinue     for          import       return      ...</div></div></div></a><a class="pagination-related" href="/2025/02/13/2025-02-13-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day04/" title="Golang整体复习Day04"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-13</div><div class="info-item-2">Golang整体复习Day04</div></div><div class="info-2"><div class="info-item-1">Array(数组)数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法： 12// 定义一个长度为3元素类型为int的数组avar a [3]int  数组定义：1var 数组变量名 [元素数量]T  比如：var a [5]int， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 [5]int和[10]int是不同的类型。 123var a [3]intvar b [4]inta = b //不可以这样做，因为此时a和b是不同的类型  数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会panic。 数组的初始化数组的初始化也有很多方式。 方法一初始化数组时可以使用初始化列表来设置数组元素的值。 12345678func main() &#123;	var testArray [3]int                        //数组会初始化为int类型的零值	var numArray =...</div></div></div></a><a class="pagination-related" href="/2025/02/13/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day05/" title="Golang整体复习Day05"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-13</div><div class="info-item-2">Golang整体复习Day05</div></div><div class="info-2"><div class="info-item-1">Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。 mapmap是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。 map定义Go语言中 map的定义语法如下： 1map[KeyType]ValueType  其中，  KeyType:表示键的类型。 ValueType:表示键对应的值的类型。  map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为： 1make(map[KeyType]ValueType, [cap])  其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。 map基本使用map中的数据都是成对出现的，map的基本使用示例代码如下： 12345678func main() &#123;	scoreMap := make(map[string]int, 8)	scoreMap[&quot;张三&quot;] = 90	scoreMap[&quot;小明&quot;] =...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xhang</div><div class="author-info-description">徐航的个人博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">1 整体框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-C-S%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 C-S架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%90%AF%E5%8A%A8-http-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 启动 http 服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%8F%91%E9%80%81-http-%E8%AF%B7%E6%B1%82"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 发送 http 请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%BA%90%E7%A0%81%E4%BD%8D%E7%BD%AE%E4%B8%80%E8%A7%88"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 源码位置一览</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">2.</span> <span class="toc-text">2 服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 核心数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%B3%A8%E5%86%8C-handler"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 注册 handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%90%AF%E5%8A%A8-server"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 启动 server</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">3.</span> <span class="toc-text">3 客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 核心数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%96%B9%E6%B3%95%E9%93%BE%E8%B7%AF%E6%80%BB%E8%A7%88"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 方法链路总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Client-Post"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Client.Post</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-NewRequest"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 NewRequest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Client-Do"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 Client.Do</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Transport-getConn"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 Transport.getConn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-persistConn-roundTrip"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 persistConn.roundTrip</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/13/nginx%E8%B7%A8%E5%9F%9F/" title="Nginx 跨域配置">Nginx 跨域配置</a><time datetime="2025-02-13T08:24:00.000Z" title="发表于 2025-02-13 16:24:00">2025-02-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/13/nginx%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/" title="Nginx 超时问题">Nginx 超时问题</a><time datetime="2025-02-13T08:14:00.000Z" title="发表于 2025-02-13 16:14:00">2025-02-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/13/etcd-tools/" title="etcd 工具和客户端库">etcd 工具和客户端库</a><time datetime="2025-02-13T07:14:00.000Z" title="发表于 2025-02-13 15:14:00">2025-02-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/13/2025-02-13-etcdctl%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/" title="etcdctl命令整理">etcdctl命令整理</a><time datetime="2025-02-13T02:09:00.000Z" title="发表于 2025-02-13 10:09:00">2025-02-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/13/2025-02-13-golanghttp%E5%BA%93%E8%A7%A3%E6%9E%90/" title="Golanghttp库解析">Golanghttp库解析</a><time datetime="2025-02-13T02:09:00.000Z" title="发表于 2025-02-13 10:09:00">2025-02-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By xhang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>