<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Golang整体复习Day11</title>
    <link href="/2025/02/20/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day11/"/>
    <url>/2025/02/20/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day11/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了Go语言反射的意义和基本使用。</p><h1 id="变量的内在机制"><a href="#变量的内在机制" class="headerlink" title="变量的内在机制"></a>变量的内在机制</h1><p>Go语言中的变量是分为两部分的:</p><ul><li>类型信息：预先定义好的元信息。</li><li>值信息：程序运行过程中可动态变化的。</li></ul><h1 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h1><p>反射是指在程序运行期间对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p><p>支持反射的语言可以在程序编译期间将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期间获取类型的反射信息，并且有能力修改它们。</p><p>Go程序在运行期间使用reflect包访问程序的反射信息。</p><p>在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。</p><h1 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h1><p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p><h2 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h2><p>在Go语言中，使用<code>reflect.TypeOf()</code>函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectType</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>v := reflect.TypeOf(x)<br>fmt.Printf(<span class="hljs-string">&quot;type:%v\n&quot;</span>, v)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">float32</span> = <span class="hljs-number">3.14</span><br>reflectType(a) <span class="hljs-comment">// type:float32</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int64</span> = <span class="hljs-number">100</span><br>reflectType(b) <span class="hljs-comment">// type:int64</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="type-name和type-kind"><a href="#type-name和type-kind" class="headerlink" title="type name和type kind"></a>type name和type kind</h3><p>在反射中关于类型还划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<code>种类（Kind）</code>就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到<code>种类（Kind）</code>。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectType</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>t := reflect.TypeOf(x)<br>fmt.Printf(<span class="hljs-string">&quot;type:%v kind:%v\n&quot;</span>, t.Name(), t.Kind())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a *<span class="hljs-type">float32</span> <span class="hljs-comment">// 指针</span><br><span class="hljs-keyword">var</span> b myInt    <span class="hljs-comment">// 自定义类型</span><br><span class="hljs-keyword">var</span> c <span class="hljs-type">rune</span>     <span class="hljs-comment">// 类型别名</span><br>reflectType(a) <span class="hljs-comment">// type: kind:ptr</span><br>reflectType(b) <span class="hljs-comment">// type:myInt kind:int64</span><br>reflectType(c) <span class="hljs-comment">// type:int32 kind:int32</span><br><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>age  <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">type</span> book <span class="hljs-keyword">struct</span>&#123; title <span class="hljs-type">string</span> &#125;<br><span class="hljs-keyword">var</span> d = person&#123;<br>name: <span class="hljs-string">&quot;沙河小王子&quot;</span>,<br>age:  <span class="hljs-number">18</span>,<br>&#125;<br><span class="hljs-keyword">var</span> e = book&#123;title: <span class="hljs-string">&quot;《跟小王子学Go语言》&quot;</span>&#125;<br>reflectType(d) <span class="hljs-comment">// type:person kind:struct</span><br>reflectType(e) <span class="hljs-comment">// type:book kind:struct</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的<code>.Name()</code>都是返回<code>空</code>。</p><p>在<code>reflect</code>包中定义的Kind类型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Kind <span class="hljs-type">uint</span><br><span class="hljs-keyword">const</span> (<br>    Invalid Kind = <span class="hljs-literal">iota</span>  <span class="hljs-comment">// 非法类型</span><br>    Bool                 <span class="hljs-comment">// 布尔型</span><br>    Int                  <span class="hljs-comment">// 有符号整型</span><br>    Int8                 <span class="hljs-comment">// 有符号8位整型</span><br>    Int16                <span class="hljs-comment">// 有符号16位整型</span><br>    Int32                <span class="hljs-comment">// 有符号32位整型</span><br>    Int64                <span class="hljs-comment">// 有符号64位整型</span><br>    Uint                 <span class="hljs-comment">// 无符号整型</span><br>    Uint8                <span class="hljs-comment">// 无符号8位整型</span><br>    Uint16               <span class="hljs-comment">// 无符号16位整型</span><br>    Uint32               <span class="hljs-comment">// 无符号32位整型</span><br>    Uint64               <span class="hljs-comment">// 无符号64位整型</span><br>    Uintptr              <span class="hljs-comment">// 指针</span><br>    Float32              <span class="hljs-comment">// 单精度浮点数</span><br>    Float64              <span class="hljs-comment">// 双精度浮点数</span><br>    Complex64            <span class="hljs-comment">// 64位复数类型</span><br>    Complex128           <span class="hljs-comment">// 128位复数类型</span><br>    Array                <span class="hljs-comment">// 数组</span><br>    Chan                 <span class="hljs-comment">// 通道</span><br>    Func                 <span class="hljs-comment">// 函数</span><br>    Interface            <span class="hljs-comment">// 接口</span><br>    Map                  <span class="hljs-comment">// 映射</span><br>    Ptr                  <span class="hljs-comment">// 指针</span><br>    Slice                <span class="hljs-comment">// 切片</span><br>    String               <span class="hljs-comment">// 字符串</span><br>    Struct               <span class="hljs-comment">// 结构体</span><br>    UnsafePointer        <span class="hljs-comment">// 底层指针</span><br>)<br></code></pre></td></tr></table></figure><h2 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h2><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p><p><code>reflect.Value</code>类型提供的获取原始值的方法如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Interface() interface {}</td><td>将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td>Int() int64</td><td>将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td>Uint() uint64</td><td>将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td>Float() float64</td><td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td>Bool() bool</td><td>将值以 bool 类型返回</td></tr><tr><td>Bytes() []bytes</td><td>将值以字节数组 []bytes 类型返回</td></tr><tr><td>String() string</td><td>将值以字符串类型返回</td></tr></tbody></table><h3 id="通过反射获取值"><a href="#通过反射获取值" class="headerlink" title="通过反射获取值"></a>通过反射获取值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectValue</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>v := reflect.ValueOf(x)<br>k := v.Kind()<br><span class="hljs-keyword">switch</span> k &#123;<br><span class="hljs-keyword">case</span> reflect.Int64:<br><span class="hljs-comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span><br>fmt.Printf(<span class="hljs-string">&quot;type is int64, value is %d\n&quot;</span>, <span class="hljs-type">int64</span>(v.Int()))<br><span class="hljs-keyword">case</span> reflect.Float32:<br><span class="hljs-comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span><br>fmt.Printf(<span class="hljs-string">&quot;type is float32, value is %f\n&quot;</span>, <span class="hljs-type">float32</span>(v.Float()))<br><span class="hljs-keyword">case</span> reflect.Float64:<br><span class="hljs-comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span><br>fmt.Printf(<span class="hljs-string">&quot;type is float64, value is %f\n&quot;</span>, <span class="hljs-type">float64</span>(v.Float()))<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">float32</span> = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int64</span> = <span class="hljs-number">100</span><br>reflectValue(a) <span class="hljs-comment">// type is float32, value is 3.140000</span><br>reflectValue(b) <span class="hljs-comment">// type is int64, value is 100</span><br><span class="hljs-comment">// 将int类型的原始值转换为reflect.Value类型</span><br>c := reflect.ValueOf(<span class="hljs-number">10</span>)<br>fmt.Printf(<span class="hljs-string">&quot;type c :%T\n&quot;</span>, c) <span class="hljs-comment">// type c :reflect.Value</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h3><p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectSetValue1</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>v := reflect.ValueOf(x)<br><span class="hljs-keyword">if</span> v.Kind() == reflect.Int64 &#123;<br>v.SetInt(<span class="hljs-number">200</span>) <span class="hljs-comment">//修改的是副本，reflect包会引发panic</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectSetValue2</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>v := reflect.ValueOf(x)<br><span class="hljs-comment">// 反射中使用 Elem()方法获取指针对应的值</span><br><span class="hljs-keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;<br>v.Elem().SetInt(<span class="hljs-number">200</span>)<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">int64</span> = <span class="hljs-number">100</span><br><span class="hljs-comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span><br>reflectSetValue2(&amp;a)<br>fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="isNil-和isValid"><a href="#isNil-和isValid" class="headerlink" title="isNil()和isValid()"></a>isNil()和isValid()</h3><h4 id="isNil"><a href="#isNil" class="headerlink" title="isNil()"></a>isNil()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span></span> IsNil() <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p><h4 id="isValid"><a href="#isValid" class="headerlink" title="isValid()"></a>isValid()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span></span> IsValid() <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// *int类型空指针</span><br><span class="hljs-keyword">var</span> a *<span class="hljs-type">int</span><br>fmt.Println(<span class="hljs-string">&quot;var a *int IsNil:&quot;</span>, reflect.ValueOf(a).IsNil())<br><span class="hljs-comment">// nil值</span><br>fmt.Println(<span class="hljs-string">&quot;nil IsValid:&quot;</span>, reflect.ValueOf(<span class="hljs-literal">nil</span>).IsValid())<br><span class="hljs-comment">// 实例化一个匿名结构体</span><br>b := <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-comment">// 尝试从结构体中查找&quot;abc&quot;字段</span><br>fmt.Println(<span class="hljs-string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="hljs-string">&quot;abc&quot;</span>).IsValid())<br><span class="hljs-comment">// 尝试从结构体中查找&quot;abc&quot;方法</span><br>fmt.Println(<span class="hljs-string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="hljs-string">&quot;abc&quot;</span>).IsValid())<br><span class="hljs-comment">// map</span><br>c := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-comment">// 尝试从map中查找一个不存在的键</span><br>fmt.Println(<span class="hljs-string">&quot;map中不存在的键：&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="hljs-string">&quot;娜扎&quot;</span>)).IsValid())<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h1><h2 id="与结构体相关的方法"><a href="#与结构体相关的方法" class="headerlink" title="与结构体相关的方法"></a>与结构体相关的方法</h2><p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（<code>reflect.Type</code>）的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p><p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Field(i int) StructField</td><td>根据索引，返回索引对应的结构体字段的信息。</td></tr><tr><td>NumField() int</td><td>返回结构体成员字段数量。</td></tr><tr><td>FieldByName(name string) (StructField, bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息。</td></tr><tr><td>FieldByIndex(index []int) StructField</td><td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td></tr><tr><td>FieldByNameFunc(match func(string) bool) (StructField,bool)</td><td>根据传入的匹配函数匹配需要的字段。</td></tr><tr><td>NumMethod() int</td><td>返回该类型的方法集中方法的数目</td></tr><tr><td>Method(int) Method</td><td>返回该类型方法集中的第i个方法</td></tr><tr><td>MethodByName(string)(Method, bool)</td><td>根据方法名返回该类型方法集中的方法</td></tr></tbody></table><h2 id="StructField类型"><a href="#StructField类型" class="headerlink" title="StructField类型"></a>StructField类型</h2><p><code>StructField</code>类型用来描述结构体中的一个字段的信息。</p><p><code>StructField</code>的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StructField <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span><br>    <span class="hljs-comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span><br>    Name    <span class="hljs-type">string</span><br>    PkgPath <span class="hljs-type">string</span><br>    Type      Type      <span class="hljs-comment">// 字段的类型</span><br>    Tag       StructTag <span class="hljs-comment">// 字段的标签</span><br>    Offset    <span class="hljs-type">uintptr</span>   <span class="hljs-comment">// 字段在结构体中的字节偏移量</span><br>    Index     []<span class="hljs-type">int</span>     <span class="hljs-comment">// 用于Type.FieldByIndex时的索引切片</span><br>    Anonymous <span class="hljs-type">bool</span>      <span class="hljs-comment">// 是否匿名字段</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体反射示例"><a href="#结构体反射示例" class="headerlink" title="结构体反射示例"></a>结构体反射示例</h2><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Score <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;score&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stu1 := student&#123;<br>Name:  <span class="hljs-string">&quot;小王子&quot;</span>,<br>Score: <span class="hljs-number">90</span>,<br>&#125;<br><br>t := reflect.TypeOf(stu1)<br>fmt.Println(t.Name(), t.Kind()) <span class="hljs-comment">// student struct</span><br><span class="hljs-comment">// 通过for循环遍历结构体的所有字段信息</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>fmt.Printf(<span class="hljs-string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// 通过字段名获取指定结构体字段信息</span><br><span class="hljs-keyword">if</span> scoreField, ok := t.FieldByName(<span class="hljs-string">&quot;Score&quot;</span>); ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来编写一个函数<code>printMethod(s interface&#123;&#125;)</code>来遍历打印s包含的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s student)</span></span> Study() <span class="hljs-type">string</span> &#123;<br>msg := <span class="hljs-string">&quot;好好学习，天天向上。&quot;</span><br>fmt.Println(msg)<br><span class="hljs-keyword">return</span> msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s student)</span></span> Sleep() <span class="hljs-type">string</span> &#123;<br>msg := <span class="hljs-string">&quot;好好睡觉，快快长大。&quot;</span><br>fmt.Println(msg)<br><span class="hljs-keyword">return</span> msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMethod</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>t := reflect.TypeOf(x)<br>v := reflect.ValueOf(x)<br><br>fmt.Println(t.NumMethod())<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumMethod(); i++ &#123;<br>methodType := v.Method(i).Type()<br>fmt.Printf(<span class="hljs-string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)<br>fmt.Printf(<span class="hljs-string">&quot;method:%s\n&quot;</span>, methodType)<br><span class="hljs-comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span><br><span class="hljs-keyword">var</span> args = []reflect.Value&#123;&#125;<br>v.Method(i).Call(args)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="反射是把双刃剑"><a href="#反射是把双刃剑" class="headerlink" title="反射是把双刃剑"></a>反射是把双刃剑</h1><p>反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。</p><ol><li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li><li>大量使用反射的代码通常难以理解。</li><li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写代码利用反射实现一个ini文件的解析器程序。</li></ol>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day12</title>
    <link href="/2025/02/20/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day12/"/>
    <url>/2025/02/20/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day12/</url>
    
    <content type="html"><![CDATA[<p>并发编程在当前软件领域是一个非常重要的概念，随着CPU等硬件的发展，我们无一例外的想让我们的程序运行的快一点、再快一点。Go语言在语言层面天生支持并发，充分利用现代CPU的多核优势，这也是Go语言能够大范围流行的一个很重要的原因。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先我们先来了解几个与并发编程相关的基本概念。</p><h3 id="串行、并发与并行"><a href="#串行、并发与并行" class="headerlink" title="串行、并发与并行"></a>串行、并发与并行</h3><p>串行：我们都是先读小学，小学毕业后再读初中，读完初中再读高中。</p><p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p><p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p><h3 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h3><p>进程（process）：程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。</p><p>线程（thread）：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位。</p><p>协程（coroutine）：非操作系统提供而是由用户自行创建和控制的用户态‘线程’，比线程更轻量级。</p><h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><p>业界将如何实现并发编程总结归纳为各式各样的并发模型，常见的并发模型有以下几种：</p><ul><li>线程&amp;锁模型</li><li>Actor模型</li><li>CSP模型</li><li>Fork&amp;Join模型</li></ul><p>Go语言中的并发程序主要是通过基于CSP（communicating sequential processes）的goroutine和channel来实现，当然也支持使用传统的多线程共享内存的并发方式。</p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Goroutine 是 Go 语言支持并发的核心，在一个Go程序中同时创建成百上千个goroutine是非常普遍的，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。区别于操作系统线程由系统内核进行调度， goroutine 是由Go运行时（runtime）负责调度。例如Go运行时会智能地将 m个goroutine 合理地分配给n个操作系统线程，实现类似m:n的调度机制，不再需要Go开发者自行在代码层面维护一个线程池。</p><p>Goroutine 是 Go 程序中最基本的并发执行单元。每一个 Go 程序都至少包含一个 goroutine——main goroutine，当 Go 程序启动时它会自动创建。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能——goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个 goroutine 去执行这个函数就可以了，就是这么简单粗暴。</p><h3 id="go关键字"><a href="#go关键字" class="headerlink" title="go关键字"></a>go关键字</h3><p>Go语言中使用 goroutine 非常简单，只需要在函数或方法调用前加上<code>go</code>关键字就可以创建一个 goroutine ，从而让该函数或方法在新创建的 goroutine 中执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> f()  <span class="hljs-comment">// 创建一个新的 goroutine 运行函数f</span><br></code></pre></td></tr></table></figure><p>匿名函数也支持使用<code>go</code>关键字创建 goroutine 去执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;()<br></code></pre></td></tr></table></figure><p>一个 goroutine 必定对应一个函数&#x2F;方法，可以创建多个 goroutine 去执行相同的函数&#x2F;方法。</p><h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><p>启动 goroutine 的方式非常简单，只需要在调用函数（普通函数和匿名函数）前加上一个<code>go</code>关键字。</p><p>我们先来看一个在 main 函数中执行普通函数调用的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>hello()<br>fmt.Println(<span class="hljs-string">&quot;你好&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>将上面的代码编译后执行，得到的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hello<br>你好<br></code></pre></td></tr></table></figure><p>代码中 hello 函数和其后面的打印语句是串行的。</p><p><img src="https://www.liwenzhou.com/images/Go/concurrence/goroutine01.png" alt="main goroutine"></p><p>接下来我们在调用 hello 函数前面加上关键字<code>go</code>，也就是启动一个 goroutine 去执行 hello 这个函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> hello() <span class="hljs-comment">// 启动另外一个goroutine去执行hello函数</span><br>fmt.Println(<span class="hljs-string">&quot;你好&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>将上述代码重新编译后执行，得到输出结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">你好<br></code></pre></td></tr></table></figure><p>这一次的执行结果只在终端打印了”你好”，并没有打印 <code>hello</code>。这是为什么呢？</p><p>其实在 Go 程序启动时，Go 程序就会为 main 函数创建一个默认的 goroutine 。在上面的代码中我们在 main 函数中使用 go 关键字创建了另外一个 goroutine 去执行 hello 函数，而此时 main goroutine 还在继续往下执行，我们的程序中此时存在两个并发执行的 goroutine。当 main 函数结束时整个程序也就结束了，同时 main goroutine 也结束了，所有由 main goroutine 创建的 goroutine 也会一同退出。也就是说我们的 main 函数退出太快，另外一个 goroutine 中的函数还未执行完程序就退出了，导致未打印出“hello”。</p><p><em>main goroutine 就像是《权利的游戏》中的夜王，其他的 goroutine 都是夜王转化出的异鬼，夜王一死它转化的那些异鬼也就全部GG了。</em></p><p>所以我们要想办法让 main 函数“等一等”将在另一个 <code>goroutine</code> 中运行的 <code>hello</code> 函数。其中最简单粗暴的方式就是在 main 函数中“time.Sleep”1秒钟了（这里的1秒钟是我们根据经验而设置的一个值，在这个示例中1秒钟足够创建新的<code>goroutine</code>执行完<code>hello</code>函数了）。</p><p>按如下方式修改我们的示例代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> hello()<br>fmt.Println(<span class="hljs-string">&quot;你好&quot;</span>)<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>将我们的程序重新编译后再次执行，程序会在终端输出如下结果，并且会短暂停顿一会儿。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">你好<br>hello<br></code></pre></td></tr></table></figure><p>为什么会先打印<code>你好</code>呢？</p><p>这是因为在程序中创建 goroutine 执行函数需要一定的开销，而与此同时 main 函数所在的 goroutine 是继续执行的。</p><p><img src="https://www.liwenzhou.com/images/Go/concurrence/goroutine02.png" alt="main goroutine和hello goorutine"></p><p>在上面的程序中使用<code>time.Sleep</code>让 main goroutine 等待 hello goroutine执行结束是不优雅的，当然也是不准确的。</p><p>Go 语言中通过<code>sync</code>包为我们提供了一些常用的并发原语，我们会在后面的小节单独介绍<code>sync</code>包中的内容。在这一小节，我们会先介绍一下 sync 包中的<code>WaitGroup</code>。当你并不关心并发操作的结果或者有其它方式收集并发操作的结果时，<code>WaitGroup</code>是实现等待一组并发操作完成的好方法。</p><p>下面的示例代码中我们在 main goroutine 中使用<code>sync.WaitGroup</code>来等待 hello goroutine 完成后再退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// 声明全局等待组变量</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>wg.Done() <span class="hljs-comment">// 告知当前goroutine完成</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 登记1个goroutine</span><br><span class="hljs-keyword">go</span> hello()<br>fmt.Println(<span class="hljs-string">&quot;你好&quot;</span>)<br>wg.Wait() <span class="hljs-comment">// 阻塞等待登记的goroutine完成</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将代码编译后再执行，得到的输出结果和之前一致，但是这一次程序不再会有多余的停顿，hello goroutine 执行完毕后程序直接退出。</p><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><p>在 Go 语言中实现并发就是这样简单，我们还可以启动多个 goroutine 。让我们再来看一个新的代码示例。这里同样使用了<code>sync.WaitGroup</code>来实现 goroutine 的同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// goroutine结束就登记-1</span><br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>, i)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 启动一个goroutine就登记+1</span><br><span class="hljs-keyword">go</span> hello(i)<br>&#125;<br>wg.Wait() <span class="hljs-comment">// 等待所有登记的goroutine都结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>多次执行上面的代码会发现每次终端上打印数字的顺序都不一致。这是因为10个 goroutine 是并发执行的，而 goroutine 的调度是随机的。</p><h3 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h3><p>操作系统的线程一般都有固定的栈内存（通常为2MB）,而 Go 语言中的 goroutine 非常轻量级，一个 goroutine 的初始栈空间很小（一般为2KB），所以在 Go 语言中一次创建数万个 goroutine 也是可能的。并且 goroutine 的栈不是固定的，可以根据需要动态地增大或缩小， Go 的 runtime 会自动为 goroutine 分配合适的栈空间。</p><h3 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h3><p>操作系统内核在调度时会挂起当前正在执行的线程并将寄存器中的内容保存到内存中，然后选出接下来要执行的线程并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。从一个线程切换到另一个线程需要完整的上下文切换。因为可能需要多次内存访问，索引这个切换上下文的操作开销较大，会增加运行的cpu周期。</p><p>区别于操作系统内核调度操作系统线程，goroutine 的调度是Go语言运行时（runtime）层面的实现，是完全由 Go 语言本身实现的一套调度系统——go scheduler。它的作用是按照一定的规则将所有的 goroutine 调度到操作系统线程上执行。</p><p>在经历数个版本的迭代之后，目前 Go 语言的调度器采用的是 <code>GPM</code> 调度模型。</p><p><img src="https://www.liwenzhou.com/images/Go/concurrence/gpm.png" alt="gpm"></p><p>其中：</p><ul><li><p>G：表示 goroutine，每执行一次<code>go f()</code>就创建一个 G，包含要执行的函数和上下文信息。</p></li><li><p>全局队列（Global Queue）：存放等待运行的 G。</p></li><li><p>P：表示 goroutine 执行所需的资源，最多有 GOMAXPROCS 个。</p></li><li><p>P 的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果本地队列满了会批量移动部分 G 到全局队列。</p></li><li><p>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</p></li><li><p>Goroutine 调度器和操作系统调度器是通过 M 结合起来的，每个 M 都代表了1个内核线程，操作系统调度器负责把内核线程分配到 CPU 的核上执行。</p></li></ul><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。</p><h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过<code>runtime.GOMAXPROCS</code>函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的CPU 逻辑核心数。）</p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>请写出下面程序的执行结果。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(i)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的 goroutine 中容易发生竞态问题。为了保证数据交换的正确性，很多并发模型中必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言采用的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p><p>如果说 goroutine 是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h3 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h3><p><code>channel</code>是 Go 语言中一种特有的类型。声明通道类型变量的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 变量名称 <span class="hljs-keyword">chan</span> 元素类型<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>chan：是关键字</li><li>元素类型：是指通道中传递元素的类型</li></ul><p>举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>   <span class="hljs-comment">// 声明一个传递整型的通道</span><br><span class="hljs-keyword">var</span> ch2 <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>  <span class="hljs-comment">// 声明一个传递布尔型的通道</span><br><span class="hljs-keyword">var</span> ch3 <span class="hljs-keyword">chan</span> []<span class="hljs-type">int</span> <span class="hljs-comment">// 声明一个传递int切片的通道</span><br></code></pre></td></tr></table></figure><h3 id="channel零值"><a href="#channel零值" class="headerlink" title="channel零值"></a>channel零值</h3><p>未初始化的通道类型变量其默认零值是<code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br>fmt.Println(ch) <span class="hljs-comment">// &lt;nil&gt;</span><br></code></pre></td></tr></table></figure><h3 id="初始化channel"><a href="#初始化channel" class="headerlink" title="初始化channel"></a>初始化channel</h3><p>声明的通道类型变量需要使用内置的<code>make</code>函数初始化之后才能使用。具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> 元素类型, [缓冲大小])<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>channel的缓冲大小是可选的。</li></ul><p>举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ch4 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>ch5 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">// 声明一个缓冲区大小为1的通道</span><br></code></pre></td></tr></table></figure><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道共有发送（send）、接收(receive）和关闭（close）三种操作。而发送和接收操作都使用<code>&lt;-</code>符号。</p><p>现在我们先使用以下语句定义一个通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>将一个值发送到通道中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch &lt;- <span class="hljs-number">10</span> <span class="hljs-comment">// 把10发送到ch中</span><br></code></pre></td></tr></table></figure><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>从一个通道中接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">x := &lt;- ch <span class="hljs-comment">// 从ch中接收值并赋值给变量x</span><br>&lt;-ch       <span class="hljs-comment">// 从ch中接收值，忽略结果</span><br></code></pre></td></tr></table></figure><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">close</span>(ch)<br></code></pre></td></tr></table></figure><p><strong>注意</strong>:一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致 panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致 panic。</li></ol><h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p>无缓冲的通道又称为阻塞的通道。我们来看一下如下代码片段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">fatal error: all goroutines are asleep - deadlock!<br><br>goroutine 1 [chan send]:<br>main.main()<br>        .../main.go:8 +0x54<br></code></pre></td></tr></table></figure><p><code>deadlock</code>表示我们程序中的 goroutine 都被挂起导致程序死锁了。为什么会出现<code>deadlock</code>错误呢？</p><p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有接收方能够接收值的时候才能发送成功，否则会一直处于等待发送的阶段。同理，如果对一个无缓冲通道执行接收操作时，没有任何向通道中发送值的操作那么也会导致接收操作阻塞。就像田径比赛中的4x100接力赛，想要完成交棒必须有一个能够接棒的运动员，否则只能等待。简单来说就是无缓冲的通道必须有至少一个接收方才能发送成功。</p><p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p><p>其中一种可行的方法是创建一个 goroutine 去接收值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recv</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>ret := &lt;-c<br>fmt.Println(<span class="hljs-string">&quot;接收成功&quot;</span>, ret)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> recv(ch) <span class="hljs-comment">// 创建一个 goroutine 从通道接收值</span><br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先无缓冲通道<code>ch</code>上的发送操作会阻塞，直到另一个 goroutine 在该通道上执行接收操作，这时数字10才能发送成功，两个 goroutine 将继续执行。相反，如果接收操作先执行，接收方所在的 goroutine 将阻塞，直到 main goroutine 中向该通道发送数字10。</p><p>使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>还有另外一种解决上面死锁问题的方法，那就是使用有缓冲区的通道。我们可以在使用 make 函数初始化通道时，可以为其指定通道的容量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 创建一个容量为1的有缓冲区通道</span><br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>只要通道的容量大于零，那么该通道就属于有缓冲的通道，通道的容量表示通道中最大能存放的元素数量。当通道内已有元素数达到最大容量后，再向通道执行发送操作就会阻塞，除非有从通道执行接收操作。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h3 id="多返回值模式"><a href="#多返回值模式" class="headerlink" title="多返回值模式"></a>多返回值模式</h3><p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。当一个通道被关闭后，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值。通道内的值被接收完后再对通道执行接收操作得到的值会一直都是对应元素类型的零值。那我们如何判断一个通道是否被关闭了呢？</p><p>对一个通道执行接收操作时支持使用如下多返回值模式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">value, ok := &lt;- ch<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>value：从通道中取出的值，如果通道被关闭则返回对应类型的零值。</li><li>ok：通道ch关闭时返回 false，否则返回 true。</li></ul><p>下面代码片段中的<code>f2</code>函数会循环从通道<code>ch</code>中接收所有值，直到通道被关闭后退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>v, ok := &lt;-ch<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;通道已关闭&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;v:%#v ok:%#v\n&quot;</span>, v, ok)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>ch &lt;- <span class="hljs-number">1</span><br>ch &lt;- <span class="hljs-number">2</span><br><span class="hljs-built_in">close</span>(ch)<br>f2(ch)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for-range接收值"><a href="#for-range接收值" class="headerlink" title="for range接收值"></a>for range接收值</h3><p>通常我们会选择使用<code>for range</code>循环从通道中接收值，当通道被关闭后，会在通道内的所有值被接收完毕后会自动退出循环。上面那个示例我们使用<code>for range</code>改写后会很简洁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Println(v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>:目前Go语言中并没有提供一个不对通道进行读取操作就能判断通道是否被关闭的方法。不能简单的通过<code>len(ch)</code>操作来判断通道是否被关闭。</p><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>在某些场景下我们可能会将通道作为参数在多个任务函数间进行传递，通常我们会选择在不同的任务函数中对通道的使用进行限制，比如限制通道在某个函数中只能执行发送或只能执行接收操作。想象一下，我们现在有<code>Producer</code>和<code>Consumer</code>两个函数，其中<code>Producer</code>函数会返回一个通道，并且会持续将符合条件的数据发送至该通道，并在发送完成后将该通道关闭。而<code>Consumer</code>函数的任务是从通道中接收值进行计算，这两个函数之间通过<code>Processer</code>函数返回的通道进行通信。完整的示例代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// Producer 返回一个通道</span><br><span class="hljs-comment">// 并持续将符合条件的数据发送至返回的通道中</span><br><span class="hljs-comment">// 数据发送完成后会将返回的通道关闭</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// 创建一个新的goroutine执行发送数据的任务</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>ch &lt;- i<br>&#125;<br>&#125;<br><span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// 任务完成后关闭通道</span><br>&#125;()<br><br><span class="hljs-keyword">return</span> ch<br>&#125;<br><br><span class="hljs-comment">// Consumer 从通道中接收数据进行计算</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>sum += v<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := Producer()<br><br>res := Consumer(ch)<br>fmt.Println(res) <span class="hljs-comment">// 25</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的示例代码中可以看出正常情况下<code>Consumer</code>函数中只会对通道进行接收操作，但是这不代表不可以在<code>Consumer</code>函数中对通道进行发送操作。作为<code>Producer</code>函数的提供者，我们在返回通道的时候可能只希望调用方拿到返回的通道后只能对其进行接收操作。但是我们没有办法阻止在<code>Consumer</code>函数中对通道进行发送操作。</p><p>Go语言中提供了<strong>单向通道</strong>来处理这种需要限制通道只能进行某种操作的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;- <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 只接收通道，只能接收不能发送</span><br><span class="hljs-keyword">chan</span> &lt;- <span class="hljs-type">int</span> <span class="hljs-comment">// 只发送通道，只能发送不能接收</span><br></code></pre></td></tr></table></figure><p>其中，箭头<code>&lt;-</code>和关键字<code>chan</code>的相对位置表明了当前通道允许的操作，这种限制将在编译阶段进行检测。另外对一个只接收通道执行close也是不允许的，因为默认通道的关闭操作应该由发送方来完成。</p><p>我们使用单向通道将上面的示例代码进行如下改造。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Producer2 返回一个接收通道</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Producer2</span><span class="hljs-params">()</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// 创建一个新的goroutine执行发送数据的任务</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>ch &lt;- i<br>&#125;<br>&#125;<br><span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// 任务完成后关闭通道</span><br>&#125;()<br><br><span class="hljs-keyword">return</span> ch<br>&#125;<br><br><span class="hljs-comment">// Consumer2 参数为接收通道</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Consumer2</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>sum += v<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch2 := Producer2()<br>  <br>res2 := Consumer2(ch2)<br>fmt.Println(res2) <span class="hljs-comment">// 25</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这一次，<code>Producer</code>函数返回的是一个只接收通道，这就从代码层面限制了该函数返回的通道只能进行接收操作，保证了数据安全。很多读者看到这个示例可能会觉着这样的限制是多余的，但是试想一下如果<code>Producer</code>函数可以在其他地方被其他人调用，你该如何限制他人不对该通道执行发送操作呢？并且返回限制操作的单向通道也会让代码语义更清晰、更易读。</p><p>在函数传参及任何赋值操作中全向通道（正常通道）可以转换为单向通道，但是无法反向转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch3 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>ch3 &lt;- <span class="hljs-number">10</span><br><span class="hljs-built_in">close</span>(ch3)<br>Consumer2(ch3) <span class="hljs-comment">// 函数传参时将ch3转为单向通道</span><br><br><span class="hljs-keyword">var</span> ch4 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>ch4 &lt;- <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> ch5 &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 声明一个只接收通道ch5</span><br>ch5 = ch4          <span class="hljs-comment">// 变量赋值时将ch4转为单向通道</span><br>&lt;-ch5<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下面的表格中总结了对不同状态下的通道执行相应操作的结果。</p><p><img src="https://www.liwenzhou.com/images/Go/concurrence/channel.png"></p><p><strong>注意</strong>:对已经关闭的通道再执行 close 也会引发 panic。</p><h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p>在某些场景下我们可能需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以被接收那么当前 goroutine 将会发生阻塞。你也许会写出如下代码尝试使用遍历的方式来实现从多个通道中接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span>&#123;<br>    <span class="hljs-comment">// 尝试从ch1接收值</span><br>    data, ok := &lt;-ch1<br>    <span class="hljs-comment">// 尝试从ch2接收值</span><br>    data, ok := &lt;-ch2<br>    …<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式虽然可以实现从多个通道接收值的需求，但是程序的运行性能会差很多。Go 语言内置了<code>select</code>关键字，使用它可以同时响应多个通道的操作。</p><p>Select 的使用方式类似于之前学到的 switch 语句，它也有一系列 case 分支和一个默认的分支。每个 case 分支会对应一个通道的通信（接收或发送）过程。select 会一直等待，直到其中的某个 case 的通信操作完成时，就会执行该 case 分支对应的语句。具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch1:<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">case</span> data := &lt;-ch2:<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">case</span> ch3 &lt;- <span class="hljs-number">10</span>:<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">//默认操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Select 语句具有以下特点。</p><ul><li>可处理一个或多个 channel 的发送&#x2F;接收操作。</li><li>如果多个 case 同时满足，select 会<strong>随机</strong>选择一个执行。</li><li>对于没有 case 的 select 会一直阻塞，可用于阻塞 main 函数，防止退出。</li></ul><p>下面的示例代码能够在终端打印出10以内的奇数，我们借助这个代码片段来看一下 select 的具体使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> x := &lt;-ch:<br>fmt.Println(x)<br><span class="hljs-keyword">case</span> ch &lt;- i:<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码输出内容如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1<br>3<br>5<br>7<br>9<br></code></pre></td></tr></table></figure><p>示例中的代码首先是创建了一个缓冲区大小为1的通道 ch，进入 for 循环后：</p><ul><li>第一次循环时 i &#x3D; 1，select 语句中包含两个 case 分支，此时由于通道中没有值可以接收，所以<code>x := &lt;-ch</code> 这个 case 分支不满足，而<code>ch &lt;- i</code>这个分支可以执行，会把1发送到通道中，结束本次 for 循环；</li><li>第二次 for 循环时，i &#x3D; 2，由于通道缓冲区已满，所以<code>ch &lt;- i</code>这个分支不满足，而<code>x := &lt;-ch</code>这个分支可以执行，从通道接收值1并赋值给变量 x ，所以会在终端打印出 1；</li><li>后续的 for 循环以此类推会依次打印出3、5、7、9。</li></ul><h2 id="通道误用示例"><a href="#通道误用示例" class="headerlink" title="通道误用示例"></a>通道误用示例</h2><p>接下来，我们将展示两个因误用通道导致程序出现 bug 的代码片段，希望能够加深读者对通道操作的印象。</p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>各位读者可以查看以下示例代码，尝试找出其中存在的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// demo1 通道误用导致的bug</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">demo1</span><span class="hljs-params">()</span></span> &#123;<br>wg := sync.WaitGroup&#123;&#125;<br><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ch &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(ch)<br><br>wg.Add(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>task := &lt;-ch<br><span class="hljs-comment">// 这里假设对接收的数据执行某些操作</span><br>fmt.Println(task)<br>&#125;<br>wg.Done()<br>&#125;()<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>将上述代码编译执行后，匿名函数所在的 goroutine 并不会按照预期在通道被关闭后退出。因为<code>task := &lt;- ch</code>的接收操作在通道被关闭后会一直接收到零值，而不会退出。此处的接收操作应该使用<code>task, ok := &lt;- ch</code> ，通过判断布尔值<code>ok</code>为假时退出；或者使用select 来处理通道。</p><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>各位读者阅读下方代码片段，尝试找出其中存在的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// demo2 通道误用导致的bug</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">demo2</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 这里假设执行一些耗时的操作</span><br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>ch &lt;- <span class="hljs-string">&quot;job result&quot;</span><br>&#125;()<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> result := &lt;-ch:<br>fmt.Println(result)<br><span class="hljs-keyword">case</span> &lt;-time.After(time.Second): <span class="hljs-comment">// 较小的超时时间</span><br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码片段可能导致 goroutine 泄露（goroutine 并未按预期退出并销毁）。由于 select 命中了超时逻辑，导致通道没有消费者（无接收操作），而其定义的通道为无缓冲通道，因此 goroutine 中的<code>ch &lt;- &quot;job result&quot;</code>操作会一直阻塞，最终导致 goroutine 泄露。</p><h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><p>有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生<code>竞态问题</code>（数据竞态）。这就好比现实生活中十字路口被各个方向的汽车竞争，还有火车上的卫生间被车厢里的人竞争。</p><p>我们用下面的代码演示一个数据竞争的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>x <span class="hljs-type">int64</span><br><br>wg sync.WaitGroup <span class="hljs-comment">// 等待组</span><br>)<br><br><span class="hljs-comment">// add 对全局变量x执行5000次加1操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<br>x = x + <span class="hljs-number">1</span><br>&#125;<br>wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">go</span> add()<br><span class="hljs-keyword">go</span> add()<br><br>wg.Wait()<br>fmt.Println(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将上面的代码编译后执行，不出意外每次执行都会输出诸如9537、5865、6527等不同的结果。这是为什么呢？</p><p>在上面的示例代码片中，我们开启了两个 goroutine 分别执行 add 函数，这两个 goroutine 在访问和修改全局的<code>x</code>变量时就会存在数据竞争，某个 goroutine 中对全局变量<code>x</code>的修改可能会覆盖掉另一个 goroutine 中的操作，所以导致最后的结果与预期不符。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用<code>sync</code>包中提供的<code>Mutex</code>类型来实现互斥锁。</p><p><code>sync.Mutex</code>提供了两个方法供我们使用。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (m *Mutex) Lock()</td><td>获取互斥锁</td></tr><tr><td>func (m *Mutex) Unlock()</td><td>释放互斥锁</td></tr></tbody></table><p>我们在下面的示例代码中使用互斥锁限制每次只有一个 goroutine 才能修改全局变量<code>x</code>，从而修复上面代码中的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// sync.Mutex</span><br><br><span class="hljs-keyword">var</span> (<br>x <span class="hljs-type">int64</span><br><br>wg sync.WaitGroup <span class="hljs-comment">// 等待组</span><br><br>m sync.Mutex <span class="hljs-comment">// 互斥锁</span><br>)<br><br><span class="hljs-comment">// add 对全局变量x执行5000次加1操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<br>m.Lock() <span class="hljs-comment">// 修改x前加锁</span><br>x = x + <span class="hljs-number">1</span><br>m.Unlock() <span class="hljs-comment">// 改完解锁</span><br>&#125;<br>wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">go</span> add()<br><span class="hljs-keyword">go</span> add()<br><br>wg.Wait()<br>fmt.Println(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>将上面的代码编译后多次执行，每一次都会得到预期中的结果——10000。</p><p>使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。</p><h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是实际上有很多场景是读多写少的，当我们并发的去读取一个资源而不涉及资源修改的时候是没有必要加互斥锁的，这种场景下使用读写锁是更好的一种选择。读写锁在 Go 语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p><p><code>sync.RWMutex</code>提供了以下5个方法。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (rw *RWMutex) Lock()</td><td>获取写锁</td></tr><tr><td>func (rw *RWMutex) Unlock()</td><td>释放写锁</td></tr><tr><td>func (rw *RWMutex) RLock()</td><td>获取读锁</td></tr><tr><td>func (rw *RWMutex) RUnlock()</td><td>释放读锁</td></tr><tr><td>func (rw *RWMutex) RLocker() Locker</td><td>返回一个实现Locker接口的读写锁</td></tr></tbody></table><p>读写锁分为两种：读锁和写锁。当一个 goroutine 获取到读锁之后，其他的 goroutine 如果是获取读锁会继续获得锁，如果是获取写锁就会等待；而当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待。</p><p>下面我们使用代码构造一个读多写少的场景，然后分别使用互斥锁和读写锁查看它们的性能差异。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>x       <span class="hljs-type">int64</span><br>wg      sync.WaitGroup<br>mutex   sync.Mutex<br>rwMutex sync.RWMutex<br>)<br><br><span class="hljs-comment">// writeWithLock 使用互斥锁的写操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeWithLock</span><span class="hljs-params">()</span></span> &#123;<br>mutex.Lock() <span class="hljs-comment">// 加互斥锁</span><br>x = x + <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Millisecond) <span class="hljs-comment">// 假设读操作耗时10毫秒</span><br>mutex.Unlock()                    <span class="hljs-comment">// 解互斥锁</span><br>wg.Done()<br>&#125;<br><br><span class="hljs-comment">// readWithLock 使用互斥锁的读操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readWithLock</span><span class="hljs-params">()</span></span> &#123;<br>mutex.Lock()                 <span class="hljs-comment">// 加互斥锁</span><br>time.Sleep(time.Millisecond) <span class="hljs-comment">// 假设读操作耗时1毫秒</span><br>mutex.Unlock()               <span class="hljs-comment">// 释放互斥锁</span><br>wg.Done()<br>&#125;<br><br><span class="hljs-comment">// writeWithLock 使用读写互斥锁的写操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeWithRWLock</span><span class="hljs-params">()</span></span> &#123;<br>rwMutex.Lock() <span class="hljs-comment">// 加写锁</span><br>x = x + <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Millisecond) <span class="hljs-comment">// 假设读操作耗时10毫秒</span><br>rwMutex.Unlock()                  <span class="hljs-comment">// 释放写锁</span><br>wg.Done()<br>&#125;<br><br><span class="hljs-comment">// readWithRWLock 使用读写互斥锁的读操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readWithRWLock</span><span class="hljs-params">()</span></span> &#123;<br>rwMutex.RLock()              <span class="hljs-comment">// 加读锁</span><br>time.Sleep(time.Millisecond) <span class="hljs-comment">// 假设读操作耗时1毫秒</span><br>rwMutex.RUnlock()            <span class="hljs-comment">// 释放读锁</span><br>wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(wf, rf <span class="hljs-keyword">func</span>()</span></span>, wc, rc <span class="hljs-type">int</span>) &#123;<br>start := time.Now()<br><span class="hljs-comment">// wc个并发写操作</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; wc; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> wf()<br>&#125;<br><br><span class="hljs-comment">//  rc个并发读操作</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; rc; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> rf()<br>&#125;<br><br>wg.Wait()<br>cost := time.Since(start)<br>fmt.Printf(<span class="hljs-string">&quot;x:%v cost:%v\n&quot;</span>, x, cost)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们假设每一次读操作都会耗时1ms，而每一次写操作会耗时10ms，我们分别测试使用互斥锁和读写互斥锁执行10次并发写和1000次并发读的耗时数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用互斥锁，10并发写，1000并发读</span><br>do(writeWithLock, readWithLock, <span class="hljs-number">10</span>, <span class="hljs-number">1000</span>) <span class="hljs-comment">// x:10 cost:1.466500951s</span><br><br><span class="hljs-comment">// 使用读写互斥锁，10并发写，1000并发读</span><br>do(writeWithRWLock, readWithRWLock, <span class="hljs-number">10</span>, <span class="hljs-number">1000</span>) <span class="hljs-comment">// x:10 cost:117.207592ms</span><br></code></pre></td></tr></table></figure><p>从最终的执行结果可以看出，使用读写互斥锁在读多写少的场景下能够极大地提高程序的性能。不过需要注意的是如果一个程序中的读操作和写操作数量级差别不大，那么读写互斥锁的优势就发挥不出来。</p><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (wg * WaitGroup) Add(delta int)</td><td>计数器+delta</td></tr><tr><td>(wg *WaitGroup) Done()</td><td>计数器-1</td></tr><tr><td>(wg *WaitGroup) Wait()</td><td>阻塞直到计数器变为0</td></tr></tbody></table><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 Done 方法将计数器减1。通过调用 Wait 来等待并发任务执行完，当计数器值为 0 时，表示所有并发任务已经完成。</p><p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> hello() <span class="hljs-comment">// 启动另外一个goroutine去执行hello函数</span><br>fmt.Println(<span class="hljs-string">&quot;main goroutine done!&quot;</span>)<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意<code>sync.WaitGroup</code>是一个结构体，进行参数传递的时候要传递指针。</p><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案——<code>sync.Once</code>，<code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Do(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>)<br></code></pre></td></tr></table></figure><p><strong>注意</strong>:如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</p><h4 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a>加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> icons <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadIcons</span><span class="hljs-params">()</span></span> &#123;<br>icons = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image&#123;<br><span class="hljs-string">&quot;left&quot;</span>:  loadIcon(<span class="hljs-string">&quot;left.png&quot;</span>),<br><span class="hljs-string">&quot;up&quot;</span>:    loadIcon(<span class="hljs-string">&quot;up.png&quot;</span>),<br><span class="hljs-string">&quot;right&quot;</span>: loadIcon(<span class="hljs-string">&quot;right.png&quot;</span>),<br><span class="hljs-string">&quot;down&quot;</span>:  loadIcon(<span class="hljs-string">&quot;down.png&quot;</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Icon 被多个goroutine调用时不是并发安全的</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> image.Image &#123;<br><span class="hljs-keyword">if</span> icons == <span class="hljs-literal">nil</span> &#123;<br>loadIcons()<br>&#125;<br><span class="hljs-keyword">return</span> icons[name]<br>&#125;<br></code></pre></td></tr></table></figure><p>多个 goroutine 并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个 goroutine 都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadIcons</span><span class="hljs-params">()</span></span> &#123;<br>icons = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image)<br>icons[<span class="hljs-string">&quot;left&quot;</span>] = loadIcon(<span class="hljs-string">&quot;left.png&quot;</span>)<br>icons[<span class="hljs-string">&quot;up&quot;</span>] = loadIcon(<span class="hljs-string">&quot;up.png&quot;</span>)<br>icons[<span class="hljs-string">&quot;right&quot;</span>] = loadIcon(<span class="hljs-string">&quot;right.png&quot;</span>)<br>icons[<span class="hljs-string">&quot;down&quot;</span>] = loadIcon(<span class="hljs-string">&quot;down.png&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的 goroutine 操作，但是这样做又会引发性能问题。</p><p>使用<code>sync.Once</code>改造的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> icons <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image<br><br><span class="hljs-keyword">var</span> loadIconsOnce sync.Once<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadIcons</span><span class="hljs-params">()</span></span> &#123;<br>icons = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image&#123;<br><span class="hljs-string">&quot;left&quot;</span>:  loadIcon(<span class="hljs-string">&quot;left.png&quot;</span>),<br><span class="hljs-string">&quot;up&quot;</span>:    loadIcon(<span class="hljs-string">&quot;up.png&quot;</span>),<br><span class="hljs-string">&quot;right&quot;</span>: loadIcon(<span class="hljs-string">&quot;right.png&quot;</span>),<br><span class="hljs-string">&quot;down&quot;</span>:  loadIcon(<span class="hljs-string">&quot;down.png&quot;</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Icon 是并发安全的</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> image.Image &#123;<br>loadIconsOnce.Do(loadIcons)<br><span class="hljs-keyword">return</span> icons[name]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并发安全的单例模式"><a href="#并发安全的单例模式" class="headerlink" title="并发安全的单例模式"></a>并发安全的单例模式</h4><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> singleton <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-keyword">var</span> instance *singleton<br><span class="hljs-keyword">var</span> once sync.Once<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *singleton &#123;<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        instance = &amp;singleton&#123;&#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go 语言中内置的 map 不是并发安全的，请看下面这段示例代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> m[key]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">set</span><span class="hljs-params">(key <span class="hljs-type">string</span>, value <span class="hljs-type">int</span>)</span></span> &#123;<br>m[key] = value<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg := sync.WaitGroup&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>key := strconv.Itoa(n)<br>set(key, n)<br>fmt.Printf(<span class="hljs-string">&quot;k=:%v,v:=%v\n&quot;</span>, key, get(key))<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>将上面的代码编译后执行，会报出<code>fatal error: concurrent map writes</code>错误。我们不能在多个 goroutine 中并发对内置的 map 进行读写操作，否则会存在数据竞争问题。</p><p>像这种场景下就需要为 map 加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版 map——<code>sync.Map</code>。开箱即用表示其不用像内置的 map 一样使用 make 函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (m *Map) Store(key, value interface{})</td><td>存储key-value数据</td></tr><tr><td>func (m *Map) Load(key interface{}) (value interface{}, ok bool)</td><td>查询key对应的value</td></tr><tr><td>func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)</td><td>查询或存储key对应的value</td></tr><tr><td>func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool)</td><td>查询并删除key</td></tr><tr><td>func (m *Map) Delete(key interface{})</td><td>删除key</td></tr><tr><td>func (m *Map) Range(f func(key, value interface{}) bool)</td><td>对map中的每个key-value依次调用f</td></tr></tbody></table><p>下面的代码示例演示了并发读写<code>sync.Map</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// 并发安全的map</span><br><span class="hljs-keyword">var</span> m = sync.Map&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg := sync.WaitGroup&#123;&#125;<br><span class="hljs-comment">// 对m执行20个并发的读写操作</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>key := strconv.Itoa(n)<br>m.Store(key, n)         <span class="hljs-comment">// 存储key-value</span><br>value, _ := m.Load(key) <span class="hljs-comment">// 根据key取值</span><br>fmt.Printf(<span class="hljs-string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>针对整数数据类型（int32、uint32、int64、uint64）我们还可以使用原子操作来保证并发安全，通常直接使用原子操作比使用锁操作效率更高。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p><h3 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h3><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>func LoadInt32(addr *int32) (val int32)  <br>func LoadInt64(addr *int64) (val int64)  <br>func LoadUint32(addr *uint32) (val uint32)  <br>func LoadUint64(addr *uint64) (val uint64)  <br>func LoadUintptr(addr *uintptr) (val uintptr)  <br>func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td><td>读取操作</td></tr><tr><td>func StoreInt32(addr *int32, val int32)  <br>func StoreInt64(addr *int64, val int64)  <br>func StoreUint32(addr *uint32, val uint32)  <br>func StoreUint64(addr *uint64, val uint64)  <br>func StoreUintptr(addr *uintptr, val uintptr)  <br>func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td><td>写入操作</td></tr><tr><td>func AddInt32(addr *int32, delta int32) (new int32)  <br>func AddInt64(addr *int64, delta int64) (new int64)  <br>func AddUint32(addr *uint32, delta uint32) (new uint32)  <br>func AddUint64(addr *uint64, delta uint64) (new uint64)  <br>func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td>修改操作</td></tr><tr><td>func SwapInt32(addr *int32, new int32) (old int32)  <br>func SwapInt64(addr *int64, new int64) (old int64)  <br>func SwapUint32(addr *uint32, new uint32) (old uint32)  <br>func SwapUint64(addr *uint64, new uint64) (old uint64)  <br>func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)  <br>func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td><td>交换操作</td></tr><tr><td>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)  <br>func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)  <br>func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)  <br>func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)  <br>func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)  <br>func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td><td>比较并交换操作</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;sync/atomic&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">interface</span> &#123;<br>Inc()<br>Load() <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-comment">// 普通版</span><br><span class="hljs-keyword">type</span> CommonCounter <span class="hljs-keyword">struct</span> &#123;<br>counter <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c CommonCounter)</span></span> Inc() &#123;<br>c.counter++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c CommonCounter)</span></span> Load() <span class="hljs-type">int64</span> &#123;<br><span class="hljs-keyword">return</span> c.counter<br>&#125;<br><br><span class="hljs-comment">// 互斥锁版</span><br><span class="hljs-keyword">type</span> MutexCounter <span class="hljs-keyword">struct</span> &#123;<br>counter <span class="hljs-type">int64</span><br>lock    sync.Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MutexCounter)</span></span> Inc() &#123;<br>m.lock.Lock()<br><span class="hljs-keyword">defer</span> m.lock.Unlock()<br>m.counter++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MutexCounter)</span></span> Load() <span class="hljs-type">int64</span> &#123;<br>m.lock.Lock()<br><span class="hljs-keyword">defer</span> m.lock.Unlock()<br><span class="hljs-keyword">return</span> m.counter<br>&#125;<br><br><span class="hljs-comment">// 原子操作版</span><br><span class="hljs-keyword">type</span> AtomicCounter <span class="hljs-keyword">struct</span> &#123;<br>counter <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AtomicCounter)</span></span> Inc() &#123;<br>atomic.AddInt64(&amp;a.counter, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AtomicCounter)</span></span> Load() <span class="hljs-type">int64</span> &#123;<br><span class="hljs-keyword">return</span> atomic.LoadInt64(&amp;a.counter)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(c Counter)</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>start := time.Now()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c.Inc()<br>wg.Done()<br>&#125;()<br>&#125;<br>wg.Wait()<br>end := time.Now()<br>fmt.Println(c.Load(), end.Sub(start))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := CommonCounter&#123;&#125; <span class="hljs-comment">// 非并发安全</span><br>test(c1)<br>c2 := MutexCounter&#123;&#125; <span class="hljs-comment">// 使用互斥锁实现并发安全</span><br>test(&amp;c2)<br>c3 := AtomicCounter&#123;&#125; <span class="hljs-comment">// 并发安全且比互斥锁效率更高</span><br>test(&amp;c3)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者 sync 包的函数&#x2F;类型实现同步更好。</p><h1 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h1><ol><li>使用 goroutine 和 channel 实现一个计算int64随机数各位数和的程序，例如生成随机数61345，计算其每个位数上的数字之和为19。<ol><li>开启一个 goroutine 循环生成int64类型的随机数，发送到<code>jobChan</code></li><li>开启24个 goroutine 从<code>jobChan</code>中取出随机数计算各位数的和，将结果发送到<code>resultChan</code></li><li>主 goroutine 从<code>resultChan</code>取出结果并打印到终端输出</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day10</title>
    <link href="/2025/02/19/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day10/"/>
    <url>/2025/02/19/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day10/</url>
    
    <content type="html"><![CDATA[<p>Go 语言中的错误处理与其他语言不太一样，它把错误当成一种值来处理，更强调判断错误、处理错误，而不是一股脑的 catch 捕获异常。</p><h1 id="Error接口和错误处理"><a href="#Error接口和错误处理" class="headerlink" title="Error接口和错误处理"></a>Error接口和错误处理</h1><h2 id="Error-接口"><a href="#Error-接口" class="headerlink" title="Error 接口"></a>Error 接口</h2><p>Go 语言中把错误当成一种特殊的值来处理，不支持其他语言中使用<code>try/catch</code>捕获异常的方式。</p><h3 id="Error-接口-1"><a href="#Error-接口-1" class="headerlink" title="Error 接口"></a>Error 接口</h3><p>Go 语言中使用一个名为 <code>error</code> 接口来表示错误类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>error</code> 接口只包含一个方法——<code>Error</code>，这个函数需要返回一个描述错误信息的字符串。</p><p>当一个函数或方法需要返回错误时，我们通常是把错误作为最后一个返回值。例如下面标准库 os 中打开文件的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> (*File, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> OpenFile(name, O_RDONLY, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 error 是一个接口类型，默认零值为<code>nil</code>。所以我们通常将调用函数返回的错误与<code>nil</code>进行比较，以此来判断函数是否返回错误。例如你会经常看到类似下面的错误判断代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">file, err := os.Open(<span class="hljs-string">&quot;./xx.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;打开文件失败,err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>当我们使用<code>fmt</code>包打印错误时会自动调用 error 类型的 Error 方法，也就是会打印出错误的描述信息。</p><h3 id="创建错误"><a href="#创建错误" class="headerlink" title="创建错误"></a>创建错误</h3><p>我们可以根据需求自定义 error，最简单的方式是使用<code>errors</code> 包提供的<code>New</code>函数创建一个错误。</p><h4 id="errors-New"><a href="#errors-New" class="headerlink" title="errors.New"></a>errors.New</h4><p>函数签名如下，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><p>它接收一个字符串参数返回包含该字符串的错误。我们可以在函数返回时快速创建一个错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">queryById</span><span class="hljs-params">(id <span class="hljs-type">int64</span>)</span></span> (*Info, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> id &lt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;无效的id&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者用来定义一个错误变量，例如标准库<code>io.EOF</code>错误定义如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> EOF = errors.New(<span class="hljs-string">&quot;EOF&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="fmt-Errorf"><a href="#fmt-Errorf" class="headerlink" title="fmt.Errorf"></a>fmt.Errorf</h3><p>当我们需要传入格式化的错误描述信息时，使用<code>fmt.Errorf</code>是个更好的选择。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Errorf(<span class="hljs-string">&quot;查询数据库失败，err:%v&quot;</span>, err)<br></code></pre></td></tr></table></figure><p>但是上面的方式会丢失原有的错误类型，只拿到错误描述的文本信息。</p><p>为了不丢失函数调用的错误链，使用<code>fmt.Errorf</code>时搭配使用特殊的格式化动词<code>%w</code>，可以实现基于已有的错误再包装得到一个新的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Errorf(<span class="hljs-string">&quot;查询数据库失败，err:%w&quot;</span>, err)<br></code></pre></td></tr></table></figure><p>对于这种二次包装的错误，<code>errors</code>包中提供了以下三个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unwrap</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span>                 <span class="hljs-comment">// 获得err包含下一层错误</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span>              <span class="hljs-comment">// 判断err是否包含target</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">As</span><span class="hljs-params">(err <span class="hljs-type">error</span>, target <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span>  <span class="hljs-comment">// 判断err是否为target类型</span><br></code></pre></td></tr></table></figure><h3 id="错误结构体类型"><a href="#错误结构体类型" class="headerlink" title="错误结构体类型"></a>错误结构体类型</h3><p>此外我们还可以自己定义结构体类型，实现error&#96;接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// OpError 自定义结构体类型</span><br><span class="hljs-keyword">type</span> OpError <span class="hljs-keyword">struct</span> &#123;<br>Op <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// Error OpError 类型实现error接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *OpError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;无权执行%s操作&quot;</span>, e.Op)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang原生os库解析</title>
    <link href="/2025/02/19/Golang%E5%8E%9F%E7%94%9Fos%E5%BA%93%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/02/19/Golang%E5%8E%9F%E7%94%9Fos%E5%BA%93%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="Go-os包核心函数速查手册"><a href="#Go-os包核心函数速查手册" class="headerlink" title="Go os包核心函数速查手册"></a>Go os包核心函数速查手册</h3><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><table><thead><tr><th>方法签名</th><th>参数说明</th><th>返回值</th><th>使用示例</th></tr></thead><tbody><tr><td>func Open(name string) (*File, error)</td><td>文件名</td><td>(文件对象, 错误)</td><td><code>f, err := os.Open(&quot;test.txt&quot;)</code></td></tr><tr><td>func Create(name string) (*File, error)</td><td>文件名</td><td>(文件对象, 错误)</td><td><code>f, err := os.Create(&quot;new.txt&quot;)</code></td></tr><tr><td>func (f *File) Write(b []byte) (n int, err error)</td><td>字节数组</td><td>(写入字节数, 错误)</td><td><code>n, err = f.Write([]byte(&quot;Hello&quot;))</code></td></tr><tr><td>func ReadFile(name string) ([]byte, error)</td><td>文件名</td><td>(文件内容, 错误)</td><td><code>data, err := os.ReadFile(&quot;config.json&quot;)</code></td></tr></tbody></table><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><table><thead><tr><th>方法</th><th>参数</th><th>返回值</th><th>示例</th></tr></thead><tbody><tr><td>Mkdir(name string, perm FileMode) error</td><td>目录路径，权限模式</td><td>错误</td><td><code>os.Mkdir(&quot;logs&quot;, 0755)</code></td></tr><tr><td>ReadDir(name string) ([]DirEntry, error)</td><td>目录路径</td><td>(目录条目列表, 错误)</td><td><code>entries, _ := os.ReadDir(&quot;.&quot;)</code></td></tr><tr><td>Stat(name string) (FileInfo, error)</td><td>路径</td><td>(文件信息, 错误)</td><td><code>fi, _ := os.Stat(&quot;file.go&quot;)</code></td></tr></tbody></table><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">os.Setenv(<span class="hljs-string">&quot;KEY&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>)     <span class="hljs-comment">// 设置环境变量</span><br>value := os.Getenv(<span class="hljs-string">&quot;KEY&quot;</span>)     <span class="hljs-comment">// 获取环境变量</span><br>env := os.Environ()           <span class="hljs-comment">// 获取所有环境变量</span><br></code></pre></td></tr></table></figure><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">os.Exit(<span class="hljs-number">1</span>)                    <span class="hljs-comment">// 立即终止程序</span><br>pid := os.Getpid()            <span class="hljs-comment">// 获取当前进程ID</span><br>args := os.Args               <span class="hljs-comment">// 获取命令行参数</span><br></code></pre></td></tr></table></figure><h4 id="特别提示"><a href="#特别提示" class="headerlink" title="特别提示"></a>特别提示</h4><ol><li>OpenFile进阶用法：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">f, err := os.OpenFile(<span class="hljs-string">&quot;data.log&quot;</span>, os.O_APPEND|os.O_CREATE, <span class="hljs-number">0644</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li>文件模式常量：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">os.ModePerm      <span class="hljs-comment">// 0777</span><br>os.O_RDONLY      <span class="hljs-comment">// 只读模式</span><br>os.O_WRONLY      <span class="hljs-comment">// 只写模式</span><br></code></pre></td></tr></table></figure><ol start="3"><li>标准流操作：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">os.Stdin.Read(buf)<br>os.Stdout.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Output&quot;</span>))<br></code></pre></td></tr></table></figure></craftcontent><p>下面分模块详细说明Go语言os包的核心功能，帮助深入理解每个函数的应用场景和底层细节：</p><hr><p><strong>一、文件系统操作（核心模式标志作用）</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 高级文件打开（完整控制文件权限和访问方式）</span><br>f, err := os.OpenFile(<span class="hljs-string">&quot;access.log&quot;</span>, os.O_WRONLY|os.O_APPEND|os.O_CREATE, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close() <span class="hljs-comment">// 必须显式关闭文件描述符</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">关键flag组合解析：</span><br><span class="hljs-comment">- os.O_APPEND: 追加模式（避免覆盖）</span><br><span class="hljs-comment">- os.O_TRUNC: 打开时清空文件</span><br><span class="hljs-comment">- os.O_EXCL: 必须创建新文件（存在则失败）</span><br><span class="hljs-comment">- 位运算组合多个标志</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>文件权限深度解析</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// FileMode实际是uint32类型</span><br>mode := os.FileMode(<span class="hljs-number">0644</span>) <br>fmt.Printf(<span class="hljs-string">&quot;%04o %s\n&quot;</span>, mode, mode) <span class="hljs-comment">// 输出：0644 -rw-r--r--</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">权限位分解:</span><br><span class="hljs-comment">- 高8位：特殊标志（sticky位等）</span><br><span class="hljs-comment">- 低9位：Unix标准权限（usr-group-other各rwx）</span><br><span class="hljs-comment">创建目录常用0755(rwxr-xr-x)，配置文件常用0644(rw-r--r--)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><hr><p><strong>二、进程环境全掌握</strong><br><strong>1. 高级环境操作模式</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态修改环境变量（影响当前进程及子进程）</span><br>os.Setenv(<span class="hljs-string">&quot;DEBUG&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>)<br><br><span class="hljs-comment">// 环境变量读取时的安全性问题示例</span><br><span class="hljs-keyword">if</span> key := os.Getenv(<span class="hljs-string">&quot;API_KEY&quot;</span>); key == <span class="hljs-string">&quot;&quot;</span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;必须设置API_KEY环境变量!&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 批量操作（需注意线程安全）</span><br>envs := os.Environ()<br>os.Clearenv() <span class="hljs-comment">// 危险操作：清空所有环境变量</span><br></code></pre></td></tr></table></figure><p><strong>2. 进程控制关键点</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 优雅退出方案（defer不会在os.Exit后执行）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;这行不会执行！&quot;</span>)<br>    os.Exit(<span class="hljs-number">1</span>) <span class="hljs-comment">// 立即终止，返回状态码1</span><br>&#125;<br><br><span class="hljs-comment">// 获取进程拓扑信息</span><br>fmt.Printf(<span class="hljs-string">&quot;PID:%d PPID:%d\n&quot;</span>, os.Getpid(), os.Getppid())<br></code></pre></td></tr></table></figure><hr><p><strong>三、路径处理实践方案</strong><br><strong>正确路径操作规范</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 错误示范（硬编码路径分隔符）</span><br>badPath := <span class="hljs-string">&quot;logs\\access.txt&quot;</span> <span class="hljs-comment">// Windows专用写法</span><br><br><span class="hljs-comment">// 正确实践（跨平台方案）</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;path/filepath&quot;</span><br>goodPath := filepath.Join(<span class="hljs-string">&quot;config&quot;</span>, <span class="hljs-string">&quot;prod&quot;</span>, <span class="hljs-string">&quot;app.yaml&quot;</span>) <br><span class="hljs-comment">// 自动处理系统分隔符</span><br></code></pre></td></tr></table></figure><hr><p><strong>四、并发文件操作禁区</strong><br><strong>文件共享冲突案例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 并发写文件的风险示例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unsafeWrite</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        f, _ := os.OpenFile(<span class="hljs-string">&quot;data.txt&quot;</span>, os.O_WRONLY, <span class="hljs-number">0644</span>)<br>        f.WriteString(<span class="hljs-string">&quot;A&quot;</span>)<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        f, _ := os.OpenFile(<span class="hljs-string">&quot;data.txt&quot;</span>, os.O_WRONLY, <span class="hljs-number">0644</span>)<br>        f.WriteString(<span class="hljs-string">&quot;B&quot;</span>) <br>    &#125;()<br>    <span class="hljs-comment">// 输出结果不确定性：可能得到AB BA或其他乱序</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">解决方法：</span><br><span class="hljs-comment">1. 使用文件锁（syscall.Flock）</span><br><span class="hljs-comment">2. 通道协调写入顺序</span><br><span class="hljs-comment">3. 采用atomic操作标记文件状态</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>五、实战性能优化技巧</strong><br><strong>1. 减少系统调用策略</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 低效写法（多次小写操作）</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>    f.Write([]<span class="hljs-type">byte</span>&#123;<span class="hljs-type">byte</span>(i)&#125;) <span class="hljs-comment">// 每次触发系统调用</span><br>&#125;<br><br><span class="hljs-comment">// 优化方案（缓冲区聚合写）</span><br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4096</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>    buf = <span class="hljs-built_in">append</span>(buf, <span class="hljs-type">byte</span>(i))<br>&#125;<br>f.Write(buf) <span class="hljs-comment">// 单个系统调用完成</span><br></code></pre></td></tr></table></figure><p><strong>2. 文件句柄泄漏检测</strong><br>检查流程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Linux下监控进程文件描述符</span><br>lsof -p &lt;pid&gt;<br>watch -n 1 <span class="hljs-string">&quot;ls /proc/&lt;pid&gt;/fd | wc -l&quot;</span><br></code></pre></td></tr></table></figure><hr><p><strong>六、不同系统兼容性处理</strong><br><strong>1. 隐藏文件处理</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Windows下创建隐藏文件特殊技巧</span><br>f, _ := os.OpenFile(<span class="hljs-string">&quot;secret.txt&quot;</span>, os.O_CREATE, <span class="hljs-number">0644</span>)<br><span class="hljs-keyword">if</span> runtime.GOOS == <span class="hljs-string">&quot;windows&quot;</span> &#123;<br>    <span class="hljs-comment">// 设置隐藏属性（需syscall支持）</span><br>    filename, _ := syscall.UTF16PtrFromString(f.Name())<br>    syscall.SetFileAttributes(filename, syscall.FILE_ATTRIBUTE_HIDDEN)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 路径保留字符处理</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 清理用户输入路径</span><br>userInput := <span class="hljs-string">&quot;../../etc/passwd\x00&quot;</span> <span class="hljs-comment">// 可能含有恶意字符</span><br>safePath := filepath.Clean(userInput) <span class="hljs-comment">// 规范路径格式</span><br>safePath = filepath.Base(safePath)   <span class="hljs-comment">// 防止目录穿越</span><br></code></pre></td></tr></table></figure><hr><p><strong>调试技巧与常见陷阱</strong></p><ol><li><strong>文件关闭检查策略</strong></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在defer关闭前记录行号</span><br>f, _ := os.Open(<span class="hljs-string">&quot;data.txt&quot;</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(start time.Time)</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;在%d行关闭文件, 持有时间:%v\n&quot;</span>, <br>        runtime.GetFrame().Line, time.Since(start))<br>&#125;(time.Now())<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>Deadlock典型案例</strong></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    dir, _ := os.MkdirTemp(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;mydir&quot;</span>)<br>    <span class="hljs-keyword">defer</span> os.RemoveAll(dir) <span class="hljs-comment">// 最后一个使用者才删除</span><br><br>    file := filepath.Join(dir, <span class="hljs-string">&quot;test.txt&quot;</span>)<br>    os.WriteFile(file, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;data&quot;</span>), <span class="hljs-number">0600</span>)<br><br>    <span class="hljs-comment">// 错误直接打开目录</span><br>    f, _ := os.Open(dir)<br>    buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">100</span>)<br>    _, err := f.Read(buf) <span class="hljs-comment">// 报错：is a directory</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang开发范式</title>
    <link href="/2025/02/19/Golang%E5%BC%80%E5%8F%91%E8%8C%83%E5%BC%8F/"/>
    <url>/2025/02/19/Golang%E5%BC%80%E5%8F%91%E8%8C%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>以下是Go语言（Golang）的主要开发范式总结，结合官方最佳实践和社区经验：</p><h3 id="一、编程哲学核心"><a href="#一、编程哲学核心" class="headerlink" title="一、编程哲学核心"></a>一、编程哲学核心</h3><ol><li><p><strong>极简主义</strong></p><ul><li>关键字仅25个（Go 1.22）</li><li>强制：禁止未使用变量&#x2F;包（编译错误）</li><li>惯例：单字母变量仅用于短作用域（如 <code>i</code>, <code>r</code>）</li></ul></li><li><p><strong>明确错误处理</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> result, err := do(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;context: %w&quot;</span>, err) <span class="hljs-comment">// 错误包装</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>非面向对象设计</strong></p><ul><li>无类的继承</li><li>组合优于继承（通过struct embedding）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex    <span class="hljs-comment">// 嵌入互斥锁</span><br>    http.Client    <span class="hljs-comment">// 嵌入HTTP客户端</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="二、并发范式"><a href="#二、并发范式" class="headerlink" title="二、并发范式"></a>二、并发范式</h3><ol><li><p><strong>CSP模型核心</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> data := &lt;-stream:<br>    process(data)<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">1</span> * time.Second):<br>    log.Println(<span class="hljs-string">&quot;timeout&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>高效同步方案</strong></p><ul><li>sync.Pool（对象池）：复用高开销对象</li><li>atomic包：无锁并发计数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> counter <span class="hljs-type">int32</span><br>atomic.AddInt32(&amp;counter, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="三、工程化实践"><a href="#三、工程化实践" class="headerlink" title="三、工程化实践"></a>三、工程化实践</h3><ol><li><p><strong>模块化设计</strong></p><ul><li>包设计标准：<ul><li>主包<code>/cmd</code>存放可执行文件</li><li>内部包<code>/internal</code>禁止外部导入</li></ul></li><li>接口最小化原则：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Fetcher <span class="hljs-keyword">interface</span> &#123;<br>    Fetch() ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>高性能编码</strong></p><ul><li>预分配优化：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Bad: 多次扩容</span><br><span class="hljs-keyword">var</span> ids []<span class="hljs-type">string</span><br> <br><span class="hljs-comment">// Good: 容量预判</span><br>ids := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(rawData))<br></code></pre></td></tr></table></figure></li></ol><h3 id="四、错误处理进阶"><a href="#四、错误处理进阶" class="headerlink" title="四、错误处理进阶"></a>四、错误处理进阶</h3><ol><li><p><strong>错误链追踪</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> err := step1(); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;step1 failed&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>错误类型断言</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Timeout() &#123;<br>    <span class="hljs-comment">// 处理网络超时</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="五、现代特性应用"><a href="#五、现代特性应用" class="headerlink" title="五、现代特性应用"></a>五、现代特性应用</h3><ol><li><p><strong>泛型实践</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Map</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s []T, f <span class="hljs-keyword">func</span>(T)</span></span> T) []T &#123;<br>    out := <span class="hljs-built_in">make</span>([]T, <span class="hljs-built_in">len</span>(s))<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>        out[i] = f(v)<br>    &#125;<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>代码生成</strong></p><ul><li>通过<code>go:generate</code>指令实现</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:generate stringer -type=Status</span><br><span class="hljs-keyword">type</span> Status <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>    Pending Status = <span class="hljs-literal">iota</span><br>    Active<br>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="六、性能分析工具链"><a href="#六、性能分析工具链" class="headerlink" title="六、性能分析工具链"></a>六、性能分析工具链</h3><ol><li><p>基准测试+profiling：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">test</span> -bench=. -cpuprofile=prof.out<br>go tool pprof -http=:8080 prof.out<br></code></pre></td></tr></table></figure></li><li><p>内存分析工具：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        log.Println(http.ListenAndServe(<span class="hljs-string">&quot;:6060&quot;</span>, <span class="hljs-literal">nil</span>))<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="关键参考"><a href="#关键参考" class="headerlink" title="关键参考"></a>关键参考</h3><ol><li>Go官方文档《Effective Go》</li><li>《The Go Programming Language》第七章内存模型</li><li>Uber《Go Style Guide》</li><li>Cloudflare《Go in Production》系列实践</li></ol><p>这些范式体现了Go语言的实用主义哲学：用简单机制组合出强大功能，通过严格惯例保障团队协作，用工具链（如race detector）强制质量要求。实际开发中建议配合<code>golangci-lint</code>等现代化检测工具强化范式实践。 </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s namespace卡住解决方案</title>
    <link href="/2025/02/18/k8s%20namespace%E5%8D%A1%E4%BD%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2025/02/18/k8s%20namespace%E5%8D%A1%E4%BD%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>在 Kubernetes 中命名空间（Namespace）出现”卡住”问题时，通常表现为 <strong>无法删除、资源停留在 Terminating 状态</strong> 或 <strong>操作响应缓慢</strong>。以下是分步骤的解决方案及原理分析：</p><hr><h1 id="一、基本原则"><a href="#一、基本原则" class="headerlink" title="一、基本原则"></a>一、基本原则</h1><ol><li><strong>优先尝试优雅删除</strong>：先避免直接操作 etcd；</li><li><strong>检查依赖资源</strong>：残留资源或 Finalizers 通常是主因；</li><li><strong>需集群管理权限</strong>：操作需 <code>cluster-admin</code> 权限。</li></ol><hr><h1 id="二、核心解决方案及命令"><a href="#二、核心解决方案及命令" class="headerlink" title="二、核心解决方案及命令"></a>二、核心解决方案及命令</h1><h2 id="1-强制删除残留资源"><a href="#1-强制删除残留资源" class="headerlink" title="1. 强制删除残留资源"></a>1. 强制删除残留资源</h2><p>当使用 <code>kubectl delete</code> 无法清理时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 强制删除命名空间内所有资源（慎用）</span><br>kubectl delete all --all --grace-period=0 --force -n &lt;NAMESPACE&gt;<br><br><span class="hljs-comment"># 清理非标准资源（如 CRD）</span><br>kubectl api-resources --verbs=list --namespaced |\<br>  awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> | xargs -n 1 kubectl get -n &lt;NAMESPACE&gt; --show-kind --ignore-not-found<br></code></pre></td></tr></table></figure><h4 id="2-诊断-Finalizers-拦截问题"><a href="#2-诊断-Finalizers-拦截问题" class="headerlink" title="2. 诊断 Finalizers 拦截问题"></a>2. 诊断 Finalizers 拦截问题</h4><p>使用以下命令定位卡住的资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get &lt;RESOURCE_TYPE&gt; -n &lt;NAMESPACE&gt; -o json | jq <span class="hljs-string">&#x27;.items[] | select(.metadata.finalizers != null) | .metadata.name&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>手动移除 Finalizers：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get &lt;RESOURCE_TYPE&gt; &lt;RESOURCE_NAME&gt; -n &lt;NAMESPACEACE&gt; -o json |\<br>  jq <span class="hljs-string">&#x27;del(.metadata.finalizers)&#x27;</span> | kubectl replace --raw /api/v1/namespaces/&lt;NAMESPACE&gt;/&lt;RESOURCE_TYPE&gt;/&lt;RESOURCE_NAME&gt;/finalize -f -<br></code></pre></td></tr></table></figure><h2 id="3-特殊手段删除-Namespace"><a href="#3-特殊手段删除-Namespace" class="headerlink" title="3. 特殊手段删除 Namespace"></a>3. 特殊手段删除 Namespace</h2><p>当命名空间自身进入 Terminating 状态时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">NAMESPACE=your_namespace<br>kubectl get ns <span class="hljs-variable">$NAMESPACE</span> -o json &gt; tmp.json<br><span class="hljs-comment"># 打开 tmp.json，删除 `finalizers` 字段和 `spec` 部分</span><br>sed -i <span class="hljs-string">&#x27;/&quot;finalizers&quot;: \[/,/\]/d; /&quot;spec&quot;: &#123;/,/&#125;/d&#x27;</span> tmp.json<br><span class="hljs-comment"># 通过 API 强制更新</span><br>kubectl replace --raw <span class="hljs-string">&quot;/api/v1/namespaces/<span class="hljs-variable">$NAMESPACE</span>/finalize&quot;</span> -f tmp.json<br></code></pre></td></tr></table></figure><h2 id="4-检查控制器状态"><a href="#4-检查控制器状态" class="headerlink" title="4. 检查控制器状态"></a>4. 检查控制器状态</h2><p>若问题由控制器异常导致：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看控制器日志（通常在 kube-system）</span><br>kubectl logs -n kube-system kube-controller-manager-xxxx | grep -i namespace<br><span class="hljs-comment"># 临时重启控制器（仅极端状况）</span><br>kubectl delete pod -n kube-system kube-controller-manager-xxxx<br></code></pre></td></tr></table></figure><h2 id="5-修改etcd数据"><a href="#5-修改etcd数据" class="headerlink" title="5. 修改etcd数据"></a>5. 修改etcd数据</h2><p>通过 <strong>直接操作 etcd</strong> 删除 Kubernetes 命名空间是 <strong>高风险操作</strong>，<strong>仅在所有常规方法失效时</strong> 作为最后手段使用。以下是严格操作的步骤及要求：</p><hr><h3 id="一、前置条件"><a href="#一、前置条件" class="headerlink" title="一、前置条件"></a>一、前置条件</h3><ul><li><strong>必备工具</strong>：<ul><li><code>etcdctl</code> 客户端安装，版本与集群 etcd 匹配（通常要求 v3+）</li><li>获取 etcd 证书：ca.crt、client.crt、client.key</li></ul></li><li><strong>权限要求</strong>：需直接访问 etcd 节点的权限（非 kubectl 操作权限）</li></ul><hr><h3 id="二、操作步骤"><a href="#二、操作步骤" class="headerlink" title="二、操作步骤"></a>二、操作步骤</h3><h4 id="1-备份-etcd"><a href="#1-备份-etcd" class="headerlink" title="1. 备份 etcd"></a>1. 备份 etcd</h4><p><strong>操作前必须生成快照</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ETCDCTL_API=3 etcdctl --endpoints=https://[ETCD_IP]:2379 \<br>  --cacert=/etc/kubernetes/pki/etcd/ca.crt \<br>  --cert=/etc/kubernetes/pki/etcd/server.crt \<br>  --key=/etc/kubernetes/pki/etcd/server.key \<br>  snapshot save /path/to/backup.db<br></code></pre></td></tr></table></figure><h4 id="2-定位命名空间的-etcd-Key-路径"><a href="#2-定位命名空间的-etcd-Key-路径" class="headerlink" title="2. 定位命名空间的 etcd Key 路径"></a>2. 定位命名空间的 etcd Key 路径</h4><p>Kubernetes 命名空间在 etcd 中的存储路径为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ETCD_KEY=<span class="hljs-string">&quot;/registry/namespaces/[NAMESPACE_NAME]&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-删除命名空间条目"><a href="#3-删除命名空间条目" class="headerlink" title="3. 删除命名空间条目"></a>3. 删除命名空间条目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ETCDCTL_API=3 etcdctl --endpoints=https://[ETCD_IP]:2379 \<br>  --cacert=/etc/kubernetes/pki/etcd/ca.crt \<br>  --cert=/etc/kubernetes/pki/etcd/server.crt \<br>  --key=/etc/kubernetes/pki/etcd/server.key \<br>  del <span class="hljs-string">&quot;<span class="hljs-variable">$ETCD_KEY</span>&quot;</span><br></code></pre></td></tr></table></figure><p><strong>删除结果判断</strong>：</p><ul><li>输出 <code>1</code>：成功删除一个键</li><li>输出 <code>0</code>：未找到该键（需确认名称拼写）</li></ul><hr><h3 id="三、配套清理操作"><a href="#三、配套清理操作" class="headerlink" title="三、配套清理操作"></a>三、配套清理操作</h3><h4 id="1-清理残留资源"><a href="#1-清理残留资源" class="headerlink" title="1. 清理残留资源"></a>1. 清理残留资源</h4><p>命名空间删除后，<strong>其下资源可能仍存在于其他路径</strong>，须全集群扫描清理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找该命名空间下所有资源（示例）</span><br>etcdctl get / --prefix --keys-only | grep <span class="hljs-string">&quot;/registry/[^/]*/[NAMESPACE_NAME]/&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-重启-Kubernetes-控制器-选择性执行"><a href="#2-重启-Kubernetes-控制器-选择性执行" class="headerlink" title="2. 重启 Kubernetes 控制器 (选择性执行)"></a>2. 重启 Kubernetes 控制器 (选择性执行)</h4><p>部分残余资源可能被 controller-manager 重建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 强制驱逐控制器 Pod（触发重建）</span><br>kubectl delete pod -n kube-system kube-controller-manager-xxxxx<br></code></pre></td></tr></table></figure><hr><h3 id="四、风险及验证"><a href="#四、风险及验证" class="headerlink" title="四、风险及验证"></a>四、风险及验证</h3><h4 id="关键风险"><a href="#关键风险" class="headerlink" title="关键风险"></a>关键风险</h4><table><thead><tr><th>风险点</th><th>后果</th><th>规避措施</th></tr></thead><tbody><tr><td><strong>误删除其他数据</strong></td><td>集群崩溃</td><td>操作前备份，明确 KEY 路径</td></tr><tr><td><strong>版本兼容性问题</strong></td><td>etcdctl 命令失效</td><td>匹配 etcd 版本（v3 API）</td></tr><tr><td><strong>残留资源引用</strong></td><td>API Server 数据不一致</td><td>全清理后重启控制平面组件</td></tr></tbody></table><h4 id="操作后验证"><a href="#操作后验证" class="headerlink" title="操作后验证"></a>操作后验证</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 确认命名空间已消失</span><br>kubectl get ns [NAMESPACE_NAME]<br><br><span class="hljs-comment"># 2. 检查控制器日志</span><br>kubectl logs -n kube-system kube-controller-manager-xxxxx | grep -C 10 <span class="hljs-string">&quot;namespace&quot;</span><br><br><span class="hljs-comment"># 3. 集群健康检查</span><br>kubectl get --raw=<span class="hljs-string">&#x27;/readyz?verbose&#x27;</span><br></code></pre></td></tr></table></figure><hr><h3 id="五、替代方案（优先尝试）"><a href="#五、替代方案（优先尝试）" class="headerlink" title="五、替代方案（优先尝试）"></a>五、替代方案（优先尝试）</h3><p>若尚未执行以下常规操作，<strong>强烈建议优先尝试</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过 API 强制清理（无需操作 etcd）</span><br>kubectl get ns [NS] -o json | jq <span class="hljs-string">&#x27;del(.spec.finalizers[])&#x27;</span> | kubectl replace --raw <span class="hljs-string">&quot;/api/v1/namespaces/[NS]/finalize&quot;</span> -f -<br></code></pre></td></tr></table></figure><hr><h3 id="六、恢复方法-操作错误时"><a href="#六、恢复方法-操作错误时" class="headerlink" title="六、恢复方法 (操作错误时)"></a>六、恢复方法 (操作错误时)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从快照恢复 etcd（会中断集群）</span><br>ETCDCTL_API=3 etcdctl snapshot restore backup.db \<br>  --data-dir /var/lib/etcd-new \<br>  --initial-cluster [CLUSTER_CONFIGURATION]<br></code></pre></td></tr></table></figure><p><em>需要重新挂载 etcd 数据目录并重启组件</em></p><hr><p><strong>总结</strong>：etcd 的直接删除是 <strong>最后手段</strong>，操作需精确控制键路径，且必须满足特定条件（如命名空间已无 controller 关联资源）。建议优先通过 Finalizers 修正或 API 级强制删除解决问题。 </p><hr><h1 id="三、深入排查手段"><a href="#三、深入排查手段" class="headerlink" title="三、深入排查手段"></a>三、深入排查手段</h1><h2 id="附加排查步骤"><a href="#附加排查步骤" class="headerlink" title="附加排查步骤"></a>附加排查步骤</h2><ol><li><p><strong>网络诊断</strong>：<br>确保 API Server 与各节点的 kubelet 通信正常，检查 Calico&#x2F;Flannel 日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get --raw=<span class="hljs-string">&#x27;/readyz?verbose&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Etcd 健康检查</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get --raw=<span class="hljs-string">&#x27;/healthz/etcd&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>核心组件版本兼容性</strong>：<br>检查 <code>kube-apiserver</code>、<code>kube-controller-manager</code> 版本是否一致：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl version --short<br></code></pre></td></tr></table></figure></li></ol><hr><h1 id="四、预防策略"><a href="#四、预防策略" class="headerlink" title="四、预防策略"></a>四、预防策略</h1><table><thead><tr><th>措施</th><th>说明</th></tr></thead><tbody><tr><td><strong>限制 Finalizers 使用</strong></td><td>自定义控制器中避免非必要 finalizers</td></tr><tr><td><strong>启用 GC 监控</strong></td><td>使用 Prometheus 监控资源删除延迟</td></tr><tr><td><strong>定期 Namespace 清理</strong></td><td>通过策略自动清理测试命名空间</td></tr></tbody></table><hr><h1 id="五、补充建议"><a href="#五、补充建议" class="headerlink" title="五、补充建议"></a>五、补充建议</h1><ul><li><strong>生产环境慎用野⼒删除</strong>：直接操作 etcd 可能引发集群级故障；</li><li><strong>保留 API Server 日志</strong>：通过 <code>--v=4</code> 增加日志级别定位问题；</li><li><strong>临时关闭 Admission 控制器</strong>：如存在冲突的 Webhook，可临时禁用。</li></ul><p>遇到更复杂的情况（如 etcd 数据损坏），可执行 <code>etcdctl snapshot restore</code> 恢复快照，建议在此类操作前通过 <strong>Velero</strong> 备份集群状态。 </p>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day09</title>
    <link href="/2025/02/18/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day09/"/>
    <url>/2025/02/18/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day09/</url>
    
    <content type="html"><![CDATA[<p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><strong>学习目标</strong></p><ul><li>了解为什么需要接口以及接口的特点</li><li>掌握接口的声明和使用</li><li>掌握接口值的概念</li><li>掌握空接口的特点及其使用场景</li></ul><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。相较于之前章节中讲到的那些具体类型（字符串、切片、结构体等）更注重“我是谁”，接口类型更注重“我能做什么”的问题。接口类型就像是一种约定——概括了一种类型应该具备哪些方法，在Go语言中提倡使用面向接口的编程方式实现解耦。</p><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>接口是一种由程序员来定义的类型，一个接口类型就是一组方法的集合，它规定了需要实现的所有方法。</p><p>相较于使用结构体类型，当我们使用接口类型说明相比于它是什么更关心它能做什么。</p><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>每个接口类型由任意个方法签名组成，接口的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> 接口类型名 <span class="hljs-keyword">interface</span>&#123;<br>    方法名<span class="hljs-number">1</span>( 参数列表<span class="hljs-number">1</span> ) 返回值列表<span class="hljs-number">1</span><br>    方法名<span class="hljs-number">2</span>( 参数列表<span class="hljs-number">2</span> ) 返回值列表<span class="hljs-number">2</span><br>    …<br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>接口类型名：Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有关闭操作的接口叫<code>closer</code>等。接口名最好要能突出该接口的类型含义。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><p>举个例子，定义一个包含<code>Write</code>方法的<code>Writer</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span>&#123;<br>    Write([]<span class="hljs-type">byte</span>) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当你看到一个<code>Writer</code>接口类型的值时，你不知道它是什么，唯一知道的就是可以通过调用它的<code>Write</code>方法来做一些事情。</p><h3 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h3><p>接口就是规定了一个<strong>需要实现的方法列表</strong>，在 Go 语言中一个类型只要实现了接口中规定的所有方法，那么我们就称它实现了这个接口。</p><p>我们定义的<code>Singer</code>接口类型，它包含一个<code>Sing</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Singer 接口</span><br><span class="hljs-keyword">type</span> Singer <span class="hljs-keyword">interface</span> &#123;<br>Sing()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们有一个<code>Bird</code> 结构体类型如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Bird <span class="hljs-keyword">struct</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>因为<code>Singer</code>接口只包含一个<code>Sing</code>方法，所以只需要给<code>Bird</code>结构体添加一个<code>Sing</code>方法就可以满足<code>Singer</code>接口的要求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Sing Bird类型的Sing方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b Bird)</span></span> Sing() &#123;<br>fmt.Println(<span class="hljs-string">&quot;汪汪汪&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就称为<code>Bird</code>实现了<code>Singer</code>接口。</p><h3 id="为什么要使用接口？"><a href="#为什么要使用接口？" class="headerlink" title="为什么要使用接口？"></a>为什么要使用接口？</h3><p>现在假设我们的代码世界里有很多小动物，下面的代码片段定义了猫和狗，它们饿了都会叫。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span></span> Say() &#123;<br>fmt.Println(<span class="hljs-string">&quot;喵喵喵~&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Say() &#123;<br>fmt.Println(<span class="hljs-string">&quot;汪汪汪~&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := Cat&#123;&#125;<br>c.Say()<br>d := Dog&#123;&#125;<br>d.Say()<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候又跑来了一只羊，羊饿了也会发出叫声。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Sheep <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Sheep)</span></span> Say() &#123;<br>fmt.Println(<span class="hljs-string">&quot;咩咩咩~&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接下来定义一个饿肚子的场景。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MakeCatHungry 猫饿了会喵喵喵~</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeCatHungry</span><span class="hljs-params">(c Cat)</span></span> &#123;<br>c.Say()<br>&#125;<br><br><span class="hljs-comment">// MakeSheepHungry 羊饿了会咩咩咩~</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeSheepHungry</span><span class="hljs-params">(s Sheep)</span></span> &#123;<br>s.Say()<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会有越来越多的小动物跑过来，我们的代码世界该怎么拓展呢？</p><p>在饿肚子这个场景下，我们可不可以把所有动物都当成一个“会叫的类型”来处理呢？当然可以！使用接口类型就可以实现这个目标。 我们的代码其实并不关心究竟是什么动物在叫，我们只是在代码中调用它的<code>Say()</code>方法，这就足够了。</p><p>我们可以约定一个<code>Sayer</code>类型，它必须实现一个<code>Say()</code>方法，只要饿肚子了，我们就调用<code>Say()</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Sayer <span class="hljs-keyword">interface</span> &#123;<br>    Say()<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们定义一个通用的<code>MakeHungry</code>函数，接收<code>Sayer</code>类型的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MakeHungry 饿肚子了...</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeHungry</span><span class="hljs-params">(s Sayer)</span></span> &#123;<br>s.Say()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过使用接口类型，把所有会叫的动物当成<code>Sayer</code>类型来处理，只要实现了<code>Say()</code>方法都能当成<code>Sayer</code>类型的变量来处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c cat<br>MakeHungry(c)<br><span class="hljs-keyword">var</span> d dog<br>MakeHungry(d)<br></code></pre></td></tr></table></figure><p>在电商系统中我们允许用户使用多种支付方式（支付宝支付、微信支付、银联支付等），我们的交易流程中可能不太在乎用户究竟使用什么支付方式，只要它能提供一个实现支付功能的<code>Pay</code>方法让调用方调用就可以了。</p><p>再比如我们需要在某个程序中添加一个将某些指标数据向外输出的功能，根据不同的需求可能要将数据输出到终端、写入到文件或者通过网络连接发送出去。在这个场景下我们可以不关注最终输出的目的地是什么，只需要它能提供一个<code>Write</code>方法让我们把内容写入就可以了。</p><p>Go语言中为了解决类似上面的问题引入了接口的概念，接口类型区别于我们之前章节中介绍的那些具体类型，让我们专注于该类型提供的方法，而不是类型本身。使用接口类型通常能够让我们写出更加通用和灵活的代码。</p><h3 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h3><p>PHP、Java等语言中也有接口的概念，不过在PHP和Java语言中需要显式声明一个类实现了哪些接口，在Go语言中使用隐式声明的方式实现接口。只要一个类型实现了接口中规定的所有方法，那么它就实现了这个接口。</p><p>Go语言中的这种设计符合程序开发中抽象的一般规律，例如在下面的代码示例中，我们的电商系统最开始只设计了支付宝一种支付方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ZhiFuBao <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 支付宝</span><br>&#125;<br><br><span class="hljs-comment">// Pay 支付宝的支付方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(z *ZhiFuBao)</span></span> Pay(amount <span class="hljs-type">int64</span>) &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;使用支付宝付款：%.2f元。\n&quot;</span>, <span class="hljs-type">float64</span>(amount/<span class="hljs-number">100</span>))<br>&#125;<br><br><span class="hljs-comment">// Checkout 结账</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Checkout</span><span class="hljs-params">(obj *ZhiFuBao)</span></span> &#123;<br><span class="hljs-comment">// 支付100元</span><br>obj.Pay(<span class="hljs-number">100</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>Checkout(&amp;ZhiFuBao&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>随着业务的发展，根据用户需求添加支持微信支付。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> WeChat <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 微信</span><br>&#125;<br><br><span class="hljs-comment">// Pay 微信的支付方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *WeChat)</span></span> Pay(amount <span class="hljs-type">int64</span>) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;使用微信付款：%.2f元。\n&quot;</span>, <span class="hljs-type">float64</span>(amount/<span class="hljs-number">100</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际的交易流程中，我们可以根据用户选择的支付方式来决定最终调用支付宝的Pay方法还是微信支付的Pay方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Checkout 支付宝结账</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckoutWithZFB</span><span class="hljs-params">(obj *ZhiFuBao)</span></span> &#123;<br><span class="hljs-comment">// 支付100元</span><br>obj.Pay(<span class="hljs-number">100</span>)<br>&#125;<br><br><span class="hljs-comment">// Checkout 微信支付结账</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckoutWithWX</span><span class="hljs-params">(obj *WeChat)</span></span> &#123;<br><span class="hljs-comment">// 支付100元</span><br>obj.Pay(<span class="hljs-number">100</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，从上面的代码示例中我们可以看出，我们其实并不怎么关心用户选择的是什么支付方式，我们只关心调用Pay方法时能否正常运行。这就是典型的“不关心它是什么，只关心它能做什么”的场景。</p><p>在这种场景下我们可以将具体的支付方式抽象为一个名为<code>Payer</code>的接口类型，即任何实现了<code>Pay</code>方法的都可以称为<code>Payer</code>类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Payer 包含支付方法的接口类型</span><br><span class="hljs-keyword">type</span> Payer <span class="hljs-keyword">interface</span> &#123;<br>Pay(<span class="hljs-type">int64</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>此时只需要修改下原始的<code>Checkout</code>函数，它接收一个<code>Payer</code>类型的参数。这样就能够在不修改既有函数调用的基础上，支持新的支付方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Checkout 结账</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Checkout</span><span class="hljs-params">(obj Payer)</span></span> &#123;<br><span class="hljs-comment">// 支付100元</span><br>obj.Pay(<span class="hljs-number">100</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>Checkout(&amp;ZhiFuBao&#123;&#125;) <span class="hljs-comment">// 之前调用支付宝支付</span><br><br>Checkout(&amp;WeChat&#123;&#125;) <span class="hljs-comment">// 现在支持使用微信支付</span><br>&#125;<br></code></pre></td></tr></table></figure><p>像类似的例子在我们编程过程中会经常遇到：</p><ul><li><p>比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？</p></li><li><p>比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？</p></li><li><p>比如满减券、立减券、打折券都属于电商场景下常见的优惠方式，我们能不能把它们当成“优惠券”来处理呢？</p></li></ul><p>接口类型是Go语言提供的一种工具，在实际的编码过程中是否使用它由你自己决定，但是通常使用接口类型可以使代码更清晰易读。</p><h3 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h3><p>那实现了接口又有什么用呢？一个接口类型的变量能够存储所有实现了该接口的类型变量。</p><p>例如在上面的示例中，<code>Dog</code>和<code>Cat</code>类型均实现了<code>Sayer</code>接口，此时一个<code>Sayer</code>类型的变量就能够接收<code>Cat</code>和<code>Dog</code>类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x Sayer <span class="hljs-comment">// 声明一个Sayer类型的变量x</span><br>a := Cat&#123;&#125;  <span class="hljs-comment">// 声明一个Cat类型变量a</span><br>b := Dog&#123;&#125;  <span class="hljs-comment">// 声明一个Dog类型变量b</span><br>x = a       <span class="hljs-comment">// 可以把Cat类型变量直接赋值给x</span><br>x.Say()     <span class="hljs-comment">// 喵喵喵</span><br>x = b       <span class="hljs-comment">// 可以把Dog类型变量直接赋值给x</span><br>x.Say()     <span class="hljs-comment">// 汪汪汪</span><br></code></pre></td></tr></table></figure><h2 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h2><p>在结构体那一章节中，我们介绍了在定义结构体方法时既可以使用值接收者也可以使用指针接收者。那么对于实现接口来说使用值接收者和使用指针接收者有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p><p>我们定义一个<code>Mover</code>接口，它包含一个<code>Move</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Mover 定义一个接口类型</span><br><span class="hljs-keyword">type</span> Mover <span class="hljs-keyword">interface</span> &#123;<br>Move()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a>值接收者实现接口</h3><p>我们定义一个<code>Dog</code>结构体类型，并使用值接收者为其定义一个<code>Move</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Dog 狗结构体类型</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Move 使用值接收者定义Move方法实现Mover接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Move() &#123;<br>fmt.Println(<span class="hljs-string">&quot;狗会动&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>此时实现<code>Mover</code>接口的是<code>Dog</code>类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x Mover    <span class="hljs-comment">// 声明一个Mover类型的变量x</span><br><br><span class="hljs-keyword">var</span> d1 = Dog&#123;&#125; <span class="hljs-comment">// d1是Dog类型</span><br>x = d1         <span class="hljs-comment">// 可以将d1赋值给变量x</span><br>x.Move()<br><br><span class="hljs-keyword">var</span> d2 = &amp;Dog&#123;&#125; <span class="hljs-comment">// d2是Dog指针类型</span><br>x = d2          <span class="hljs-comment">// 也可以将d2赋值给变量x</span><br>x.Move()<br></code></pre></td></tr></table></figure><p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是结构体类型还是对应的结构体指针类型的变量都可以赋值给该接口变量。</p><h3 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a>指针接收者实现接口</h3><p>我们再来测试一下使用指针接收者实现接口有什么区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Cat 猫结构体类型</span><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Move 使用指针接收者定义Move方法实现Mover接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span></span> Move() &#123;<br>fmt.Println(<span class="hljs-string">&quot;猫会动&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>此时实现<code>Mover</code>接口的是<code>*Cat</code>类型，我们可以将<code>*Cat</code>类型的变量直接赋值给<code>Mover</code>接口类型的变量<code>x</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c1 = &amp;Cat&#123;&#125; <span class="hljs-comment">// c1是*Cat类型</span><br>x = c1          <span class="hljs-comment">// 可以将c1当成Mover类型</span><br>x.Move()<br></code></pre></td></tr></table></figure><p>但是不能给将<code>Cat</code>类型的变量赋值给<code>Mover</code>接口类型的变量<code>x</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 下面的代码无法通过编译</span><br><span class="hljs-keyword">var</span> c2 = Cat&#123;&#125; <span class="hljs-comment">// c2是Cat类型</span><br>x = c2         <span class="hljs-comment">// 不能将c2当成Mover类型</span><br></code></pre></td></tr></table></figure><p>由于Go语言中有对指针求值的语法糖，对于值接收者实现的接口，无论使用值类型还是指针类型都没有问题。但是我们并不总是能对一个值求址，所以对于指针接收者实现的接口要额外注意。</p><h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h2><h3 id="一个类型实现多个接口"><a href="#一个类型实现多个接口" class="headerlink" title="一个类型实现多个接口"></a>一个类型实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。例如狗不仅可以叫，还可以动。我们完全可以分别定义<code>Sayer</code>接口和<code>Mover</code>接口，具体代码示例如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Sayer 接口</span><br><span class="hljs-keyword">type</span> Sayer <span class="hljs-keyword">interface</span> &#123;<br>Say()<br>&#125;<br><br><span class="hljs-comment">// Mover 接口</span><br><span class="hljs-keyword">type</span> Mover <span class="hljs-keyword">interface</span> &#123;<br>Move()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Dog</code>既可以实现<code>Sayer</code>接口，也可以实现<code>Mover</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 实现Sayer接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Say() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s会叫汪汪汪\n&quot;</span>, d.Name)<br>&#125;<br><br><span class="hljs-comment">// 实现Mover接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Move() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s会动\n&quot;</span>, d.Name)<br>&#125;<br></code></pre></td></tr></table></figure><p>同一个类型实现不同的接口互相不影响使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> d = Dog&#123;Name: <span class="hljs-string">&quot;旺财&quot;</span>&#125;<br><br><span class="hljs-keyword">var</span> s Sayer = d<br><span class="hljs-keyword">var</span> m Mover = d<br><br>s.Say()  <span class="hljs-comment">// 对Sayer类型调用Say方法</span><br>m.Move() <span class="hljs-comment">// 对Mover类型调用Move方法</span><br></code></pre></td></tr></table></figure><h3 id="多种类型实现同一接口"><a href="#多种类型实现同一接口" class="headerlink" title="多种类型实现同一接口"></a>多种类型实现同一接口</h3><p>Go语言中不同的类型还可以实现同一接口。例如在我们的代码世界中不仅狗可以动，汽车也可以动。我们可以使用如下代码体现这个关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 实现Mover接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Move() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s会动\n&quot;</span>, d.Name)<br>&#125;<br><br><span class="hljs-comment">// Car 汽车结构体类型</span><br><span class="hljs-keyword">type</span> Car <span class="hljs-keyword">struct</span> &#123;<br>Brand <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// Move Car类型实现Mover接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Car)</span></span> Move() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s速度70迈\n&quot;</span>, c.Brand)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们在代码中就可以把狗和汽车当成一个会动的类型来处理，不必关注它们具体是什么，只需要调用它们的<code>Move</code>方法就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> obj Mover<br><br>obj = Dog&#123;Name: <span class="hljs-string">&quot;旺财&quot;</span>&#125;<br>obj.Move()<br><br>obj = Car&#123;Brand: <span class="hljs-string">&quot;宝马&quot;</span>&#125;<br>obj.Move()<br></code></pre></td></tr></table></figure><p>上面的代码执行结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">旺财会跑<br>宝马速度<span class="hljs-number">70</span>迈<br></code></pre></td></tr></table></figure><p>一个接口的所有方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WashingMachine 洗衣机</span><br><span class="hljs-keyword">type</span> WashingMachine <span class="hljs-keyword">interface</span> &#123;<br>wash()<br>dry()<br>&#125;<br><br><span class="hljs-comment">// 甩干器</span><br><span class="hljs-keyword">type</span> dryer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 实现WashingMachine接口的dry()方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dryer)</span></span> dry() &#123;<br>fmt.Println(<span class="hljs-string">&quot;甩一甩&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 海尔洗衣机</span><br><span class="hljs-keyword">type</span> haier <span class="hljs-keyword">struct</span> &#123;<br>dryer <span class="hljs-comment">//嵌入甩干器</span><br>&#125;<br><br><span class="hljs-comment">// 实现WashingMachine接口的wash()方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h haier)</span></span> wash() &#123;<br>fmt.Println(<span class="hljs-string">&quot;洗刷刷&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h2><p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库<code>io</code>源码中就有很多接口之间互相组合的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/io/io.go</span><br><br><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Closer <span class="hljs-keyword">interface</span> &#123;<br>Close() <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型</span><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>Reader<br>Writer<br>&#125;<br><br><span class="hljs-comment">// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型</span><br><span class="hljs-keyword">type</span> ReadCloser <span class="hljs-keyword">interface</span> &#123;<br>Reader<br>Closer<br>&#125;<br><br><span class="hljs-comment">// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型</span><br><span class="hljs-keyword">type</span> WriteCloser <span class="hljs-keyword">interface</span> &#123;<br>Writer<br>Closer<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p><p>接口也可以作为结构体的一个字段，我们来看一段Go标准库<code>sort</code>源码中的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/sort/sort.go</span><br><br><span class="hljs-comment">// Interface 定义通过索引对元素排序的接口类型</span><br><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>    Len() <span class="hljs-type">int</span><br>    Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span><br>    Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br><br><br><span class="hljs-comment">// reverse 结构体中嵌入了Interface接口</span><br><span class="hljs-keyword">type</span> reverse <span class="hljs-keyword">struct</span> &#123;<br>    Interface<br>&#125;<br></code></pre></td></tr></table></figure><p>通过在结构体中嵌入一个接口类型，从而让该结构体类型实现了该接口类型，并且还可以改写该接口的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Less 为reverse类型添加Less方法，重写原Interface接口类型的Less方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r reverse)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> r.Interface.Less(j, i)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Interface</code>类型原本的<code>Less</code>方法签名为 <code>Less(i, j int) bool</code>，此处重写为<code>r.Interface.Less(j, i)</code>，即通过将索引参数交换位置实现反转。</p><p>在这个示例中还有一个需要注意的地方是<code>reverse</code>结构体本身是不可导出的（结构体类型名称首字母小写），<code>sort.go</code>中通过定义一个可导出的<code>Reverse</code>函数来让使用者创建<code>reverse</code>结构体实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(data Interface)</span></span> Interface &#123;<br><span class="hljs-keyword">return</span> &amp;reverse&#123;data&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做的目的是保证得到的<code>reverse</code>结构体中的<code>Interface</code>属性一定不为<code>nil</code>，否者<code>r.Interface.Less(j, i)</code>就会出现空指针panic。</p><p>此外在Go内置标准库<code>database/sql</code>中也有很多类似的结构体内嵌接口类型的使用示例，各位读者可自行查阅。</p><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><h3 id="空接口的定义"><a href="#空接口的定义" class="headerlink" title="空接口的定义"></a>空接口的定义</h3><p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 空接口</span><br><br><span class="hljs-comment">// Any 不包含任何方法的空接口类型</span><br><span class="hljs-keyword">type</span> Any <span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-comment">// Dog 狗结构体</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x Any<br><br>x = <span class="hljs-string">&quot;你好&quot;</span> <span class="hljs-comment">// 字符串型</span><br>fmt.Printf(<span class="hljs-string">&quot;type:%T value:%v\n&quot;</span>, x, x)<br>x = <span class="hljs-number">100</span> <span class="hljs-comment">// int型</span><br>fmt.Printf(<span class="hljs-string">&quot;type:%T value:%v\n&quot;</span>, x, x)<br>x = <span class="hljs-literal">true</span> <span class="hljs-comment">// 布尔型</span><br>fmt.Printf(<span class="hljs-string">&quot;type:%T value:%v\n&quot;</span>, x, x)<br>x = Dog&#123;&#125; <span class="hljs-comment">// 结构体类型</span><br>fmt.Printf(<span class="hljs-string">&quot;type:%T value:%v\n&quot;</span>, x, x)<br>&#125;<br></code></pre></td></tr></table></figure><p>通常我们在使用空接口类型时不必使用<code>type</code>关键字声明，可以像下面的代码一样直接使用<code>interface&#123;&#125;</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125;  <span class="hljs-comment">// 声明一个空接口类型变量x</span><br></code></pre></td></tr></table></figure><h3 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h3><h4 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a>空接口作为函数的参数</h4><p>使用空接口实现可以接收任意类型的函数参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 空接口作为函数参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;type:%T value:%v\n&quot;</span>, a, a)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="空接口作为map的值"><a href="#空接口作为map的值" class="headerlink" title="空接口作为map的值"></a>空接口作为map的值</h4><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 空接口作为map值</span><br><span class="hljs-keyword">var</span> studentInfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>studentInfo[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;沙河娜扎&quot;</span><br>studentInfo[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">18</span><br>studentInfo[<span class="hljs-string">&quot;married&quot;</span>] = <span class="hljs-literal">false</span><br>fmt.Println(studentInfo)<br></code></pre></td></tr></table></figure><h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p>由于接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体<strong>值</strong>之外，还需要记录这个值属于的<strong>类型</strong>。也就是说接口值由“类型”和“值”组成，鉴于这两部分会根据存入值的不同而发生变化，我们称之为接口的<code>动态类型</code>和<code>动态值</code>。</p><p>![[附件&#x2F;5f2c28ee654334f08d60f9319064ed5c_MD5.png]]</p><p>我们接下来通过一个示例来加深对接口值的理解。</p><p>下面的示例代码中，定义了一个<code>Mover</code>接口类型和两个实现了该接口的<code>Dog</code>和<code>Car</code>结构体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mover <span class="hljs-keyword">interface</span> &#123;<br>Move()<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog)</span></span> Move() &#123;<br>fmt.Println(<span class="hljs-string">&quot;狗在跑~&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Car <span class="hljs-keyword">struct</span> &#123;<br>Brand <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Car)</span></span> Move() &#123;<br>fmt.Println(<span class="hljs-string">&quot;汽车在跑~&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，我们创建一个<code>Mover</code>接口类型的变量<code>m</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m Mover<br></code></pre></td></tr></table></figure><p>此时，接口变量<code>m</code>是接口类型的零值，也就是它的类型和值部分都是<code>nil</code>，就如下图所示。</p><p>![[附件&#x2F;4bf152ef54e66b91ece5e27703d8004a_MD5.png]]</p><p>我们可以使用<code>m == nil</code>来判断此时的接口值是否为空。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(m == <span class="hljs-literal">nil</span>)  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>**注意：**我们不能对一个空接口值调用任何方法，否则会产生panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">m.Move() <span class="hljs-comment">// panic: runtime error: invalid memory address or nil pointer dereference</span><br></code></pre></td></tr></table></figure><p>接下来，我们将一个<code>*Dog</code>结构体指针赋值给变量<code>m</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">m = &amp;Dog&#123;Name: <span class="hljs-string">&quot;旺财&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>此时，接口值<code>m</code>的动态类型会被设置为<code>*Dog</code>，动态值为结构体变量的拷贝。</p><p>![[附件&#x2F;464c766cab25c18f2ada96c05c2b9e05_MD5.png]]</p><p>然后，我们给接口变量<code>m</code>赋值为一个<code>*Car</code>类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c *Car<br>m = c<br></code></pre></td></tr></table></figure><p>这一次，接口值<code>m</code>的动态类型为<code>*Car</code>，动态值为<code>nil</code>。</p><p>![[附件&#x2F;9da7cc877ad4f8a33d96e9a2b4550f84_MD5.png]]</p><p>**注意：**此时接口变量<code>m</code>与<code>nil</code>并不相等，因为它只是动态值的部分为<code>nil</code>，而动态类型部分保存着对应值的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(m == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>x Mover = <span class="hljs-built_in">new</span>(Dog)<br>y Mover = <span class="hljs-built_in">new</span>(Car)<br>)<br>fmt.Println(x == y) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>但是有一种特殊情况需要特别注意，如果接口值保存的动态类型相同，但是这个动态类型不支持互相比较（比如切片），那么对它们相互比较时就会引发panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> z <span class="hljs-keyword">interface</span>&#123;&#125; = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>fmt.Println(z == z) <span class="hljs-comment">// panic: runtime error: comparing uncomparable type []int</span><br></code></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>接口值可能赋值为任意类型的值，那我们如何从接口值获取其存储的具体数据呢？</p><p>我们可以借助标准库<code>fmt</code>包的格式化打印获取到接口值的动态类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m Mover<br><br>m = &amp;Dog&#123;Name: <span class="hljs-string">&quot;旺财&quot;</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, m) <span class="hljs-comment">// *main.Dog</span><br><br>m = <span class="hljs-built_in">new</span>(Car)<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, m) <span class="hljs-comment">// *main.Car</span><br></code></pre></td></tr></table></figure><p>而<code>fmt</code>包内部其实是使用反射的机制在程序运行时获取到动态类型的名称。关于反射的内容我们会在后续章节详细介绍。</p><p>而想要从接口值中获取到对应的实际值需要使用类型断言，其语法格式如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">x.(T)<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>x：表示接口类型的变量</li><li>T：表示断言<code>x</code>可能是的类型。</li></ul><p>该语法返回两个参数，第一个参数是<code>x</code>转化为<code>T</code>类型后的变量，第二个值是一个布尔值，若为<code>true</code>则表示断言成功，为<code>false</code>则表示断言失败。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> n Mover = &amp;Dog&#123;Name: <span class="hljs-string">&quot;旺财&quot;</span>&#125;<br>v, ok := n.(*Dog)<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;类型断言成功&quot;</span>)<br>v.Name = <span class="hljs-string">&quot;富贵&quot;</span> <span class="hljs-comment">// 变量v是*Dog类型</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;类型断言失败&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果对一个接口值有多个实际类型需要判断，推荐使用<code>switch</code>语句来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// justifyType 对传入的空接口类型变量x进行类型断言</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">justifyType</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">switch</span> v := x.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>fmt.Printf(<span class="hljs-string">&quot;x is a string，value is %v\n&quot;</span>, v)<br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>fmt.Printf(<span class="hljs-string">&quot;x is a int is %v\n&quot;</span>, v)<br><span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:<br>fmt.Printf(<span class="hljs-string">&quot;x is a bool is %v\n&quot;</span>, v)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;unsupport type！&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于接口类型变量能够动态存储不同类型值的特点，所以很多初学者会滥用接口类型（特别是空接口）来实现编码过程中的便捷。只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。切记不要为了使用接口类型而增加不必要的抽象，导致不必要的运行时损耗。</p><p>在 Go 语言中接口是一个非常重要的概念和特性，使用接口类型能够实现代码的抽象和解耦，也可以隐藏某个功能的内部实现，但是缺点就是在查看源码的时候，不太方便查找到具体实现接口的类型。</p><p>相信很多读者在刚接触到接口类型时都会有很多疑惑，请牢记接口是一种类型，一种抽象的类型。区别于我们在之前章节提到的那些具体类型（整型、数组、结构体类型等），它是一个只要求实现特定方法的抽象类型。</p><p><strong>小技巧：</strong> 下面的代码可以在程序编译阶段验证某一结构体是否满足特定的接口类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 摘自gin框架routergroup.go</span><br><span class="hljs-keyword">type</span> IRouter <span class="hljs-keyword">interface</span>&#123; ... &#125;<br><br><span class="hljs-keyword">type</span> RouterGroup <span class="hljs-keyword">struct</span> &#123; ... &#125;<br><br><span class="hljs-keyword">var</span> _ IRouter = &amp;RouterGroup&#123;&#125;  <span class="hljs-comment">// 确保RouterGroup实现了接口IRouter</span><br></code></pre></td></tr></table></figure><p>上面的代码中也可以使用<code>var _ IRouter = (*RouterGroup)(nil)</code>进行验证。</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>使用接口的方式实现一个既可以往终端写日志也可以往文件写日志的简易日志库。</li></ol>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day08</title>
    <link href="/2025/02/18/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day08/"/>
    <url>/2025/02/18/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day08/</url>
    
    <content type="html"><![CDATA[<p>在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。</p><h1 id="包与依赖管理"><a href="#包与依赖管理" class="headerlink" title="包与依赖管理"></a>包与依赖管理</h1><p><strong>本章学习目标</strong></p><ul><li>掌握包的定义和使用</li><li>掌握init初始化函数的使用</li><li>掌握依赖管理工具go module的使用</li></ul><p>在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何引入其他包。同时也将介绍如何在项目中使用go module管理依赖。</p><h2 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h2><h3 id="包介绍"><a href="#包介绍" class="headerlink" title="包介绍"></a>包介绍</h3><p>Go语言中支持模块化的开发理念，在Go语言中使用<code>包（package）</code>来支持代码模块化和代码复用。一个包是由一个或多个Go源码文件（.go结尾的文件）组成，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如<code>fmt</code>、<code>os</code>、<code>io</code>等。</p><p>例如，在之前的章节中我们频繁使用了<code>fmt</code>这个内置包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  fmt.Println(<span class="hljs-string">&quot;Hello world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面短短的几行代码就涉及到了如何定义包以及如何引入其它包两个内容，接下来我们依次介绍一下它们。</p><h3 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h3><p>我们可以根据自己的需要创建自定义包。一个包可以简单理解为一个存放<code>.go</code>文件的文件夹。该文件夹下面的所有<code>.go</code>文件都要在非注释的第一行添加如下声明，声明该文件归属的包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> packagename<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><p>package：声明包的关键字</p></li><li><p>packagename：包名，可以不与文件夹的名称一致，不能包含 <code>-</code> 符号，最好与其实现的功能相对应。</p></li></ul><p>另外需要注意一个文件夹下面直接包含的文件只能归属一个包，同一个包的文件不能在多个文件夹下。包名为<code>main</code>的包是应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含<code>main</code>包的源代码则不会得到可执行文件。</p><h3 id="标识符可见性"><a href="#标识符可见性" class="headerlink" title="标识符可见性"></a>标识符可见性</h3><p>在同一个包内部声明的标识符都位于同一个命名空间下，在不同的包内部声明的标识符就属于不同的命名空间。想要在包的外部使用包内部的标识符就需要添加包名前缀，例如<code>fmt.Println(&quot;Hello world!&quot;)</code>，就是指调用<code>fmt</code>包中的<code>Println</code>函数。</p><p>如果想让一个包中的标识符（如变量、常量、类型、函数等）能被外部的包使用，那么标识符必须是对外可见的（public）。在Go语言中是通过标识符的首字母大&#x2F;小写来控制标识符的对外可见（public）&#x2F;不可见（private）的。在一个包内部只有首字母大写的标识符才是对外可见的。</p><p>例如我们定义一个名为<code>demo</code>的包，在其中定义了若干标识符。在另外一个包中并不是所有的标识符都能通过<code>demo.</code>前缀访问到，因为只有那些首字母是大写的标识符才是对外可见的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> demo<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 包级别标识符的可见性</span><br><br><span class="hljs-comment">// num 定义一个全局整型变量</span><br><span class="hljs-comment">// 首字母小写，对外不可见(只能在当前包内使用)</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">100</span><br><br><span class="hljs-comment">// Mode 定义一个常量</span><br><span class="hljs-comment">// 首字母大写，对外可见(可在其它包中使用)</span><br><span class="hljs-keyword">const</span> Mode = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// person 定义一个代表人的结构体</span><br><span class="hljs-comment">// 首字母小写，对外不可见(只能在当前包内使用)</span><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// Add 返回两个整数和的函数</span><br><span class="hljs-comment">// 首字母大写，对外可见(可在其它包中使用)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><br><span class="hljs-comment">// sayHi 打招呼的函数</span><br><span class="hljs-comment">// 首字母小写，对外不可见(只能在当前包内使用)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHi</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot;七米&quot;</span> <span class="hljs-comment">// 函数局部变量，只能在当前函数内使用</span><br>fmt.Println(myName)<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的规则也适用于结构体，结构体中可导出字段的字段名称必须首字母大写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span> <span class="hljs-comment">// 可在包外访问的方法</span><br>class <span class="hljs-type">string</span> <span class="hljs-comment">// 仅限包内访问的字段</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="包的引入"><a href="#包的引入" class="headerlink" title="包的引入"></a>包的引入</h3><p>要在当前包中使用另外一个包的内容就需要使用<code>import</code>关键字引入这个包，并且import语句通常放在文件的开头，<code>package</code>声明语句的下方。完整的引入声明语句格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> importname <span class="hljs-string">&quot;path/to/package&quot;</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><p>importname：引入的包名，通常都省略。默认值为引入包的包名。</p></li><li><p>path&#x2F;to&#x2F;package：引入包的路径名称，必须使用双引号包裹起来。</p></li><li><p>Go语言中禁止循环导入包。</p></li></ul><p>一个Go源码文件中可以同时引入多个包，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span><br></code></pre></td></tr></table></figure><p>当然可以使用批量引入的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>当引入的多个包中存在相同的包名或者想自行为某个引入的包设置一个新包名时，都需要通过<code>importname</code>指定一个在当前文件中使用的新包名。例如，在引入<code>fmt</code>包时为其指定一个新包名<code>f</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> f <span class="hljs-string">&quot;fmt&quot;</span><br></code></pre></td></tr></table></figure><p>这样在当前这个文件中就可以通过使用<code>f</code>来调用<code>fmt</code>包中的函数了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">f.Println(<span class="hljs-string">&quot;Hello world!&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果引入一个包的时候为其设置了一个特殊<code>_</code>作为包名，那么这个包的引入方式就称为匿名引入。一个包被匿名引入的目的主要是为了加载这个包，从而使得这个包中的资源得以初始化。 被匿名引入的包中的<code>init</code>函数将被执行并且仅执行一遍。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span><br></code></pre></td></tr></table></figure><p>匿名引入的包与其他方式导入的包一样都会被编译到可执行文件中。</p><p>需要注意的是，Go语言中不允许引入包却不在代码中使用这个包的内容，如果引入了未使用的包则会触发编译错误。</p><h3 id="init初始化函数"><a href="#init初始化函数" class="headerlink" title="init初始化函数"></a>init初始化函数</h3><p>在每一个Go源文件中，都可以定义任意个如下格式的特殊函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种特殊的函数不接收任何参数也没有任何返回值，我们也不能在代码中主动调用它。当程序启动的时候，init函数会按照它们声明的顺序自动执行。</p><p>一个包的初始化过程是按照代码中引入的顺序来进行的，所有在该包中声明的<code>init</code>函数都将被串行调用并且仅调用执行一次。每一个包初始化的时候都是先执行依赖的包中声明的<code>init</code>函数再执行当前包中声明的<code>init</code>函数。确保在程序的<code>main</code>函数开始执行时所有的依赖包都已初始化完成。![[附件&#x2F;5bd937bf6feefc982cc289b11fb3247d_MD5.png]]</p><p>每一个包的初始化是先从初始化包级别变量开始的。例如从下面的示例中我们就可以看出包级别变量的初始化会先于<code>init</code>初始化函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> x <span class="hljs-type">int8</span> = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;x:&quot;</span>, x)<br>  fmt.Println(<span class="hljs-string">&quot;pi:&quot;</span>, pi)<br>  sayHi()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHi</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;你好，世界！&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">x: 10<br>pi: 3.14<br>Hello World!<br>你好，世界！<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们了解了Go语言中包的定义及包的初始化过程，这让我们能够在开发时按照自己的需要定义包。同时我们还学到了如何在我们的代码中引入其它的包，不过在本小节的所有示例中我们都是引入Go内置的包。现代编程语言大多都允许开发者对外发布包&#x2F;库，也支持开发者在自己的代码中引入第三方库。这样的设计能够让广大开发者一起参与到语言的生态环境建设当中，把生态建设的更加完善。</p><h2 id="go-module"><a href="#go-module" class="headerlink" title="go module"></a>go module</h2><p>在Go语言的早期版本中，我们编写Go项目代码时所依赖的所有第三方包都需要保存在GOPATH这个目录下面。这样的依赖管理方式存在一个致命的缺陷，那就是不支持版本管理，同一个依赖包只能存在一个版本的代码。可是我们本地的多个项目完全可能分别依赖同一个第三方包的不同版本。</p><h3 id="go-module介绍"><a href="#go-module介绍" class="headerlink" title="go module介绍"></a>go module介绍</h3><p>Go module 是 Go1.11 版本发布的依赖管理方案，从 Go1.14 版本开始推荐在生产环境使用，于Go1.16版本默认开启。Go module 提供了以下命令供我们使用：</p><p>go module相关命令</p><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>go mod init</td><td>初始化项目依赖，生成go.mod文件</td></tr><tr><td>go mod download</td><td>根据go.mod文件下载依赖</td></tr><tr><td>go mod tidy</td><td>比对项目文件中引入的依赖与go.mod进行比对</td></tr><tr><td>go mod graph</td><td>输出依赖关系图</td></tr><tr><td>go mod edit</td><td>编辑go.mod文件</td></tr><tr><td>go mod vendor</td><td>将项目的所有依赖导出至vendor目录</td></tr><tr><td>go mod verify</td><td>检验一个依赖包是否被篡改过</td></tr><tr><td>go mod why</td><td>解释为什么需要某个依赖</td></tr></tbody></table><p>Go语言在 go module 的过渡阶段提供了 <code>GO111MODULE</code> 这个环境变量来作为是否启用 go module 功能的开关，考虑到 Go1.16 之后 go module 已经默认开启，所以本书不再介绍该配置，对于刚接触Go语言的读者而言完全没有必要了解这个历史包袱。</p><p><strong>GOPROXY</strong></p><p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。</p><p>GOPROXY 的默认值是：<code>https://proxy.golang.org,direct</code>，由于某些原因国内无法正常访问该地址，所以我们通常需要配置一个可访问的地址。目前社区使用比较多的有两个<code>https://goproxy.cn</code>和<code>https://goproxy.io</code>，当然如果你的公司有提供GOPROXY地址那么就直接使用。设置GOPAROXY的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure><p>GOPROXY 允许设置多个代理地址，多个地址之间需使用英文逗号 “,” 分隔。最后的 “direct” 是一个特殊指示符，用于指示 Go 回源到源地址去抓取（比如 GitHub 等）。当配置有多个代理地址时，如果第一个代理地址返回 404 或 410 错误时，Go 会自动尝试下一个代理地址，当遇见 “direct” 时触发回源，也就是回到源地址去抓取。</p><p><strong>GOPRIVATE</strong></p><p>设置了GOPROXY 之后，go 命令就会从配置的代理地址拉取和校验依赖包。当我们在项目中引入了非公开的包（公司内部git仓库或 github 私有仓库等），此时便无法正常从代理拉取到这些非公开的依赖包，这个时候就需要配置 GOPRIVATE 环境变量。GOPRIVATE用来告诉 go 命令哪些仓库属于私有仓库，不必通过代理服务器拉取和校验。</p><p>GOPRIVATE 的值也可以设置多个，多个地址之间使用英文逗号 “,” 分隔。我们通常会把自己公司内部的代码仓库设置到 GOPRIVATE 中，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go <span class="hljs-built_in">env</span> -w GOPRIVATE=<span class="hljs-string">&quot;git.mycompany.com&quot;</span><br></code></pre></td></tr></table></figure><p>这样在拉取以<code>git.mycompany.com</code>为路径前缀的依赖包时就能正常拉取了。</p><p>此外，如果公司内部自建了 GOPROXY 服务，那么我们可以通过设置 <code>GONOPROXY=none</code>，允许通内部代理拉取私有仓库的包。</p><h3 id="使用go-module引入包"><a href="#使用go-module引入包" class="headerlink" title="使用go module引入包"></a>使用go module引入包</h3><p>接下来我们将通过一个示例来演示如何在开发项目时使用 go module 拉取和管理项目依赖。</p><p><strong>初始化项目</strong> 我们在本地新建一个名为<code>holiday</code>项目，按如下方式创建一个名为<code>holiday</code>的文件夹并切换到该目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> holiday<br>$ <span class="hljs-built_in">cd</span> holiday<br></code></pre></td></tr></table></figure><p>目前我们位于<code>holiday</code>文件夹下，接下来执行下面的命令初始化项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go mod init holiday<br>go: creating new go.mod: module holiday<br></code></pre></td></tr></table></figure><p>该命令会自动在项目目录下创建一个<code>go.mod</code>文件，其内容如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">module holiday<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.16</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>module holiday：定义当前项目的导入路径</li><li>go 1.16：标识当前项目使用的 Go 版本</li></ul><p><code>go.mod</code>文件会记录项目使用的第三方依赖包信息，包括包名和版本，由于我们的<code>holiday</code>项目目前还没有使用到第三方依赖包，所以<code>go.mod</code>文件暂时还没有记录任何依赖包信息，只有当前项目的一些信息。</p><p>接下来，我们在项目目录下新建一个<code>main.go</code>文件，其内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// holiday/main.go</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;现在是假期时间...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们的<code>holiday</code>项目现在需要引入一个第三方包<code>github.com/q1mi/hello</code>来实现一些必要的功能。类似这样的场景在我们的日常开发中是很常见的。我们需要先将依赖包下载到本地同时在<code>go.mod</code>中记录依赖信息，然后才能在我们的代码中引入并使用这个包。下载依赖包主要有两种方法。</p><p>第一种方法是在项目目录下执行<code>go get</code>命令手动下载依赖的包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">holiday $ go get -u github.com/q1mi/hello<br>go get: added github.com/q1mi/hello v0.1.1<br></code></pre></td></tr></table></figure><p>这样默认会下载最新的发布版本，你也可以指定想要下载指定的版本号的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">holiday $ go get -u github.com/q1mi/hello@v0.1.0<br>go: downloading github.com/q1mi/hello v0.1.0<br>go get: downgraded github.com/q1mi/hello v0.1.1 =&gt; v0.1.0<br></code></pre></td></tr></table></figure><p>如果依赖包没有发布任何版本则会拉取最新的提交，最终<code>go.mod</code>中的依赖信息会变成类似下面这种由默认v0.0.0的版本号和最新一次commit的时间和hash组成的版本格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">require github.com/q1mi/hello v0<span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">-20210218074646</span><span class="hljs-number">-139</span>b0bcd549d<br></code></pre></td></tr></table></figure><p>如果想指定下载某个commit对应的代码，可以直接指定commit hash，不过没有必要写出完整的commit hash，一般前7位即可。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">holiday $ go get github.com/q1mi/hello@2ccfadd<br>go: downloading github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3<br>go get: added github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3<br></code></pre></td></tr></table></figure><p>此时，我们打开<code>go.mod</code>文件就可以看到下载的依赖包及版本信息都已经被记录下来了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">module holiday<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.16</span><br><br>require github.com/q1mi/hello v0<span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br></code></pre></td></tr></table></figure><p>行尾的<code>indirect</code>表示该依赖包为间接依赖，说明在当前程序中的所有 import 语句中没有发现引入这个包。</p><p>另外在执行<code>go get</code>命令下载一个新的依赖包时一般会额外添加<code>-u</code>参数，强制更新现有依赖。</p><p>第二种方式是我们直接编辑<code>go.mod</code>文件，将依赖包和版本信息写入该文件。例如我们修改<code>holiday/go.mod</code>文件内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">module holiday<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.16</span><br><br>require github.com/q1mi/hello latest<br></code></pre></td></tr></table></figure><p>表示当前项目需要使用<code>github.com/q1mi/hello</code>库的最新版本，然后在项目目录下执行<code>go mod download</code>下载依赖包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">holiday $ go mod download<br></code></pre></td></tr></table></figure><p>如果不输出其它提示信息就说明依赖已经下载成功，此时<code>go.mod</code>文件已经变成如下内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">module holiday<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.16</span><br><br>require github.com/q1mi/hello v0<span class="hljs-number">.1</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><p>从中我们可以知道最新的版本号是<code>v0.1.1</code>。如果事先知道依赖包的具体版本号，可以直接在<code>go.mod</code>中指定需要的版本然后再执行<code>go mod download</code>下载。</p><p>这种方法同样支持指定想要下载的commit进行下载，例如直接在<code>go.mod</code>文件中按如下方式指定commit hash，这里只写出来了commit hash的前7位。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">require github.com/q1mi/hello <span class="hljs-number">2</span>ccfadda<br></code></pre></td></tr></table></figure><p>执行<code>go mod download</code>下载完依赖后，<code>go.mod</code>文件中对应的版本信息会自动更新为类似下面的格式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">module holiday<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.16</span><br><br>require github.com/q1mi/hello v0<span class="hljs-number">.1</span><span class="hljs-number">.2</span><span class="hljs-number">-0.20210219092711</span><span class="hljs-number">-2</span>ccfaddad6a3<br></code></pre></td></tr></table></figure><p>下载好要使用的依赖包之后，我们现在就可以在<code>holiday/main.go</code>文件中使用这个包了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/q1mi/hello&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;现在是假期时间...&quot;</span>)<br><br>hello.SayHi() <span class="hljs-comment">// 调用hello包的SayHi函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将上述代码编译执行，就能看到执行结果了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">holiday $ go build<br>holiday $ ./holiday<br>现在是假期时间...<br>你好，我是七米。很高兴认识你。<br></code></pre></td></tr></table></figure><p>当我们的项目功能越做越多，代码越来越多的时候，通常会选择在项目内部按功能或业务划分成多个不同包。Go语言支持在一个项目（project）下定义多个包（package）。</p><p>例如，我们在<code>holiday</code>项目内部创建一个新的package——<code>summer</code>，此时新的项目目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">holidy<br>├── go.mod<br>├── go.sum<br>├── main.go<br>└── summer<br>    └── summer.go<br></code></pre></td></tr></table></figure><p>其中<code>holiday/summer/summer.go</code>文件内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> summer<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// Diving 潜水...</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Diving</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;夏天去诗巴丹潜水...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>此时想要在当前项目目录下的其他包或者<code>main.go</code>中调用这个<code>Diving</code>函数需要如何引入呢？这里以在<code>main.go</code>中演示详细的调用过程为例，在项目内其他包的引入方式类似。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;holiday/summer&quot;</span> <span class="hljs-comment">// 导入当前项目下的包</span><br><br><span class="hljs-string">&quot;github.com/q1mi/hello&quot;</span> <span class="hljs-comment">// 导入github上第三方包</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;现在是假期时间...&quot;</span>)<br>hello.SayHi()<br><br>summer.Diving()<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的示例可以看出，项目中定义的包都会以项目的导入路径为前缀。</p><p>如果你想要导入本地的一个包，并且这个包也没有发布到到其他任何代码仓库，这时候你可以在<code>go.mod</code>文件中使用<code>replace</code>语句将依赖临时替换为本地的代码包。例如在我的电脑上有另外一个名为<code>liwenzhou.com/overtime</code>的项目，它位于<code>holiday</code>项目同级目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── holiday<br>│   ├── go.mod<br>│   ├── go.sum<br>│   ├── main.go<br>│   └── summer<br>│       └── summer.go<br>└── overtime<br>    ├── go.mod<br>    └── overtime.go<br></code></pre></td></tr></table></figure><p>由于<code>liwenzhou.com/overtime</code>包只存在于我本地，并不能通过网络获取到这个代码包，这个时候应该如何在<code>holidy</code>项目中引入它呢？</p><p>我们可以在<code>holidy/go.mod</code>文件中正常引入<code>liwenzhou.com/overtime</code>包，然后像下面的示例那样使用<code>replace</code>语句将这个依赖替换为使用相对路径表示的本地包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">module holiday<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.16</span><br><br>require github.com/q1mi/hello v0<span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>require liwenzhou.com/overtime v0<span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><br>replace liwenzhou.com/overtime  =&gt; ../overtime<br></code></pre></td></tr></table></figure><p>这样，我们就可以在<code>holiday/main.go</code>下正常引入并使用<code>overtime</code>包了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;holiday/summer&quot;</span> <span class="hljs-comment">// 导入当前项目下的包</span><br><br><span class="hljs-string">&quot;liwenzhou.com/overtime&quot;</span> <span class="hljs-comment">// 通过replace导入的本地包</span><br><br><span class="hljs-string">&quot;github.com/q1mi/hello&quot;</span> <span class="hljs-comment">// 导入github上第三方包</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;现在是假期时间...&quot;</span>)<br>hello.SayHi()<br><br>summer.Diving()<br><br>overtime.Do()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也经常使用<code>replace</code>将项目依赖中的某个包，替换为其他版本的代码包或我们自己修改后的代码包。</p><p><strong>go.mod文件</strong></p><p><code>go.mod</code>文件中记录了当前项目中所有依赖包的相关信息，声明依赖的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">require module/path v1.2.3<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>require：声明依赖的关键字</li><li>module&#x2F;path：依赖包的引入路径</li><li>v1.2.3：依赖包的版本号。支持以下几种格式：<ul><li>latest：最新版本</li><li>v1.0.0：详细版本号</li><li>commit hash：指定某次commit hash</li></ul></li></ul><p>引入某些没有发布过<code>tag</code>版本标识的依赖包时，<code>go.mod</code>中记录的依赖版本信息就会出现类似<code>v0.0.0-20210218074646-139b0bcd549d</code>的格式，由版本号、commit时间和commit的hash值组成。</p><p>![[附件&#x2F;1abbe77b242f7aa60ecbd672ee7bd63e_MD5.png]]</p><p><strong>go.sum文件</strong></p><p>使用go module下载了依赖后，项目目录下还会生成一个<code>go.sum</code>文件，这个文件中详细记录了当前项目中引入的依赖包的信息及其hash 值。<code>go.sum</code>文件内容通常是以类似下面的格式出现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;module&gt; &lt;version&gt;/<span class="hljs-keyword">go</span>.mod &lt;hash&gt;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;module&gt; &lt;version&gt; &lt;hash&gt;<br>&lt;module&gt; &lt;version&gt;/<span class="hljs-keyword">go</span>.mod &lt;hash&gt;<br></code></pre></td></tr></table></figure><p>不同于其他语言提供的基于中心的包管理机制，例如 npm 和 pypi等，Go并没有提供一个中央仓库来管理所有依赖包，而是采用分布式的方式来管理包。为了防止依赖包被非法篡改，Go module 引入了<code>go.sum</code>机制来对依赖包进行校验。</p><p><strong>依赖保存位置</strong></p><p>Go module 会把下载到本地的依赖包会以类似下面的形式保存在 <code>$GOPATH/pkg/mod</code>目录下，每个依赖包都会带有版本号进行区分，这样就允许在本地存在同一个包的多个不同版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">mod<br>├── cache<br>├── cloud.google.com<br>├── github.com<br>    └──q1mi<br>          ├── hello@v0.0.0-20210218074646-139b0bcd549d<br>          ├── hello@v0.1.1<br>          └── hello@v0.1.0<br>...<br></code></pre></td></tr></table></figure><p>如果想清除所有本地已缓存的依赖包数据，可以执行 <code>go clean -modcache</code> 命令。</p><h3 id="使用go-module发布包"><a href="#使用go-module发布包" class="headerlink" title="使用go module发布包"></a>使用go module发布包</h3><p>在上面的小节中我们学习了如何在项目中引入别人提供的依赖包，那么当我们想要在社区发布一个自己编写的代码包或者在公司内部编写一个供内部使用的公用组件时，我们该怎么做呢？接下来，我们就一起编写一个代码包并将它发布到<code>github.com</code>仓库，让它能够被全球的Go语言开发者使用。</p><p>我们首先在自己的 github 账号下新建一个项目，并把它下载到本地。我这里就以创建和发布一个名为<code>hello</code>的项目为例进行演示。这个<code>hello</code>包将对外提供一个名为<code>SayHi</code>的函数，它的作用非常简单就是向调用者发去问候。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/q1mi/hello<br>$ <span class="hljs-built_in">cd</span> hello<br></code></pre></td></tr></table></figure><p>我们当前位于<code>hello</code>项目目录下，执行下面的命令初始化项目，创建<code>go.mod</code>文件。需要注意的是这里定义项目的引入路径为<code>github.com/q1mi/hello</code>，读者在自行测试时需要将这部分替换为自己的仓库路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hello $ go mod init github.com/q1mi/hello<br>go: creating new go.mod: module github.com/q1mi/hello<br></code></pre></td></tr></table></figure><p>接下来我们在该项目根目录下创建 <code>hello.go</code> 文件，添加下面的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> hello<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SayHi</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;你好，我是七米。很高兴认识你。&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将该项目的代码 push 到仓库的远端分支，这样就对外发布了一个Go包。其他的开发者可以通过<code>github.com/q1mi/hello</code>这个引入路径下载并使用这个包了。</p><p>一个设计完善的包应该包含开源许可证及文档等内容，并且我们还应该尽心维护并适时发布适当的版本。github 上发布版本号使用git tag为代码包打上标签即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hello $ git tag -a v0.1.0 -m <span class="hljs-string">&quot;release version v0.1.0&quot;</span><br>hello $ git push origin v0.1.0<br></code></pre></td></tr></table></figure><p>经过上面的操作我们就发布了一个版本号为<code>v0.1.0</code>的版本。</p><p>Go modules中建议使用语义化版本控制，其建议的版本号格式如下：</p><p>![[附件&#x2F;06a8a4f3943f54028f3d6737f08b0288_MD5.png]]</p><p>其中：</p><ul><li>主版本号：发布了不兼容的版本迭代时递增（breaking changes）。</li><li>次版本号：发布了功能性更新时递增。</li><li>修订号：发布了bug修复类更新时递增。</li></ul><p><strong>发布新的主版本</strong></p><p>现在我们的<code>hello</code>项目要进行与之前版本不兼容的更新，我们计划让<code>SayHi</code>函数支持向指定人发出问候。更新后的<code>SayHi</code>函数内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> hello<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// SayHi 向指定人打招呼的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SayHi</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;你好%s，我是七米。很高兴认识你。\n&quot;</span>, name)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于这次改动巨大（修改了函数之前的调用规则），对之前使用该包作为依赖的用户影响巨大。因此我们需要发布一个主版本号递增的<code>v2</code>版本。在这种情况下，我们通常会修改当前包的引入路径，像下面的示例一样为引入路径添加版本后缀。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// hello/go.mod</span><br><br>module github.com/q1mi/hello/v2<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.16</span><br></code></pre></td></tr></table></figure><p>把修改后的代码提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hello $ git add .<br>hello $ git commit -m <span class="hljs-string">&quot;feat: SayHi现在支持给指定人打招呼啦&quot;</span><br>hello $ git push<br></code></pre></td></tr></table></figure><p>打好 tag 推送到远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hello $ git tag -a v2.0.0 -m <span class="hljs-string">&quot;release version v2.0.0&quot;</span><br>hello $ git push origin v2.0.0<br></code></pre></td></tr></table></figure><p>这样在不影响使用旧版本的用户的前提下，我们新的版本也发布出去了。想要使用<code>v2</code>版本的代码包的用户只需按修改后的引入路径下载即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/q1mi/hello/v2@v2.0.0<br></code></pre></td></tr></table></figure><p>在代码中使用的过程与之前类似，只是需要注意引入路径要添加 v2 版本后缀。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/q1mi/hello/v2&quot;</span> <span class="hljs-comment">// 引入v2版本</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;现在是假期时间...&quot;</span>)<br><br>hello.SayHi(<span class="hljs-string">&quot;张三&quot;</span>) <span class="hljs-comment">// v2版本的SayHi函数需要传入字符串参数</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>废弃已发布版本</strong></p><p>如果某个发布的版本存在致命缺陷不再想让用户使用时，我们可以使用<code>retract</code>声明废弃的版本。例如我们在<code>hello/go.mod</code>文件中按如下方式声明即可对外废弃<code>v0.1.2</code>版本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">module github.com/q1mi/hello<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.16</span><br><br><br>retract v0<span class="hljs-number">.1</span><span class="hljs-number">.2</span><br></code></pre></td></tr></table></figure><p>用户使用go get下载<code>v0.1.2</code>版本时就会收到提示，催促其升级到其他版本。</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>编写一个<code>calc</code>包实现加减乘除四个功能函数，在<code>snow</code>这个包中引入<code>calc</code>包并调用其加减乘除四个函数实现数学运算。</li></ol>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cursor食用指北</title>
    <link href="/2025/02/17/cursor%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97/"/>
    <url>/2025/02/17/cursor%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<p><strong>转载自<a href="https://linux.do/t/topic/309516">我的Cursor使用心得——项目实现</a></strong></p><h2 id="1-Cursor的使用"><a href="#1-Cursor的使用" class="headerlink" title="1. Cursor的使用"></a>1. Cursor的使用</h2><p>我并没有使用太多cursor提供的能力，实用至上，一昧的折腾工具并不能帮助你实现项目。</p><p>论坛中有佬分享使用技巧，大伙儿可以去参考，写的很棒，我一直在用：</p><ul><li><a href="https://linux.do/t/topic/172395">一些关于 Cursor 的使用技巧</a></li><li><a href="https://linux.do/t/topic/181361">Cursor 技巧（第二弹）</a></li></ul><h3 id="1-1-快捷键"><a href="#1-1-快捷键" class="headerlink" title="1.1. 快捷键"></a>1.1. 快捷键</h3><p><code>Ctrl+L</code>：唤起聊天栏。最基础的功能。</p><p><code>Ctrl+K</code>：编辑代码块。直接选中部分代码使用该快捷键，可以直接让LLM修改和实现代码。适合具体细节的改动，如调整方法或生成片段内容。</p><p><code>Ctrl+回车</code>：使用整个项目文件作为上文进行提问。在聊天栏中使用该快捷键，cursor会自动对项目内容进行量化，避免占用过多token。这个功能在进行一些大方向提问时非常好用，但是不适合细节实现，因为会丢失细节，遗漏文件。自行根据需求选择性使用</p><blockquote><p>我没有选择使用composer，因为我需要在速度和效果中得到一个平衡，比起不动手，目前阶段还是手动实现更容易达到预期效果。</p></blockquote><h3 id="1-2-模型选择"><a href="#1-2-模型选择" class="headerlink" title="1.2. 模型选择"></a>1.2. 模型选择</h3><p>绝大部分时候，我都是使用<code>claude-3-5-sonnet-20241022</code>，这是我个人认为最好用的模型，响应快速，理解合格，有时还能用诙谐的语气回答问题，我非常满意。</p><h3 id="1-3-prompt集成"><a href="#1-3-prompt集成" class="headerlink" title="1.3. prompt集成"></a>1.3. prompt集成</h3><p>在<code>cursor setting</code> - <code>general</code> - <code>Rules for Al</code>，填入以下prompt。</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk"><span class="hljs-type">DO</span> <span class="hljs-type">NOT</span> <span class="hljs-type">GIVE</span> <span class="hljs-type">ME</span> <span class="hljs-type">HIGH</span> <span class="hljs-type">LEVEL</span> <span class="hljs-type">STUFF</span>, <span class="hljs-type">IF</span> <span class="hljs-type">I</span> <span class="hljs-type">ASK</span> <span class="hljs-type">FOR</span> <span class="hljs-type">FIX</span> <span class="hljs-type">OR</span> <span class="hljs-type">EXPLANATION</span>, <span class="hljs-type">I</span> <span class="hljs-type">WANT</span> <span class="hljs-type">ACTUAL</span> <span class="hljs-type">CODE</span> <span class="hljs-type">OR</span> <span class="hljs-type">EXPLANATION</span>!!! <span class="hljs-type">I</span> <span class="hljs-type">DON</span><span class="hljs-string">&#x27;T WANT &quot;Here&#x27;</span>s how you can blablabla<span class="hljs-comment">&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">- Be casual unless otherwise specified</span><br><span class="hljs-comment">- Be terse</span><br><span class="hljs-comment">- Suggest solutions that I didn’t think about—anticipate my needs</span><br><span class="hljs-comment">- Treat me as an expert</span><br><span class="hljs-comment">- Be accurate and thorough</span><br><span class="hljs-comment">- Give the answer immediately. Provide detailed explanations and restate my query in your own words if necessary after giving the answer</span><br><span class="hljs-comment">- Value good arguments over authorities, the source is irrelevant</span><br><span class="hljs-comment">- Consider new technologies and contrarian ideas, not just the conventional wisdom</span><br><span class="hljs-comment">- You may use high levels of speculation or prediction, just flag it for me</span><br><span class="hljs-comment">- No moral lectures</span><br><span class="hljs-comment">- Discuss safety only when it&#x27;s crucial and non-obvious</span><br><span class="hljs-comment">- If your content policy is an issue, provide the closest acceptable response and explain the content policy issue afterward</span><br><span class="hljs-comment">- Cite sources whenever possible at the end, not inline</span><br><span class="hljs-comment">- No need to mention your knowledge cutoff</span><br><span class="hljs-comment">- No need to disclose you&#x27;re an AI</span><br><span class="hljs-comment">- Please respect my prettier preferences when you provide code.</span><br><span class="hljs-comment">- Split into multiple responses if one response isn&#x27;t enough to answer the question.</span><br><span class="hljs-comment">  If I ask for adjustments to code I have provided you, do not repeat all of my code unnecessarily. Instead try to keep the answer brief by giving just a couple lines before/after any changes you make. Multiple code blocks are ok.</span><br><span class="hljs-comment">  Reply in 中文 when interpreting the code.</span><br></code></pre></td></tr></table></figure><h3 id="1-4-自动生成美观的commit-logs"><a href="#1-4-自动生成美观的commit-logs" class="headerlink" title="1.4. 自动生成美观的commit logs"></a>1.4. 自动生成美观的commit logs</h3><blockquote><p>注意添加.gitignore文件，将.history之类的文件加入忽视清单，避免git追踪区域混乱。</p></blockquote><p>写commit logs是一件很麻烦的事，但是如果不好好写，没有人愿意回头去看代码，包括你自己。</p><p>在chat聊天框中输入<code>@commit</code>，回车选择<code>Commit (Diff of Working State)</code>，它会自动将项目git未提交区域的文件填入上文，然后在文本框中粘贴：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br>You <span class="hljs-keyword">are</span> an expert software engineer.<br>Review the provided context <span class="hljs-keyword">and</span> diffs which <span class="hljs-keyword">are</span> about <span class="hljs-keyword">to</span> be committed <span class="hljs-keyword">to</span> a git repo.<br>Review the diffs carefully.<br>Generate a <span class="hljs-keyword">commit</span> message <span class="hljs-keyword">for</span> those changes.<br>The <span class="hljs-keyword">commit</span> message MUST use the imperative tense.<br>The <span class="hljs-keyword">commit</span> message should be structured <span class="hljs-keyword">as</span> follows: <span class="hljs-operator">&lt;</span>type<span class="hljs-operator">&gt;</span>: <span class="hljs-operator">&lt;</span>description<span class="hljs-operator">&gt;</span><br>Use these <span class="hljs-keyword">for</span> <span class="hljs-operator">&lt;</span>type<span class="hljs-operator">&gt;</span>: fix, feat, build, chore, ci, docs, style, refactor, perf, test<br>Reply <span class="hljs-keyword">with</span> JUST the <span class="hljs-keyword">commit</span> message, <span class="hljs-keyword">without</span> quotes, comments, questions, etc<span class="hljs-operator">!</span><br>回复中文<br><br></code></pre></td></tr></table></figure><p>这个prompt会自动总结你的commit diff，给出标准格式的logs，然后你再根据具体改动调整一下话语即可，大多时候都不需要调整。</p><p>之后将内容复制到message处，提交即可。</p><h2 id="2-应该怎么做"><a href="#2-应该怎么做" class="headerlink" title="2. 应该怎么做"></a>2. 应该怎么做</h2><h3 id="2-1-明确定位"><a href="#2-1-明确定位" class="headerlink" title="2.1.明确定位"></a>2.1.明确定位</h3><p>一开始我就明确了自己的角色定位：产品经理。我不懂编程语言和代码实现，我的职责就是设计指导LLM实现项目，在过程中通过咨询细节再调整具体的实现步骤。</p><p>在问答的过程中，一定要当一个好奇宝宝，不停的问怎么做和为什么，你跟LLM客气什么？不懂就问，哪里不会问哪里！</p><p>我一开始就是什么都不懂，然后再和LLM的交流基础上，以它的回答作为阶梯一步步优化提问内容。</p><p>下面是我的第一次做网站的对话过程：</p><ul><li>怎么实现网站？</li><li>我想请求API，想用Vercel部署，用nextjs还是vue更合适？</li><li>怎么构建nextjs项目？</li><li>从npx开始给出构建命令</li><li>这些选项都是什么意思？应该选哪个？</li></ul><p>至此，我就完成了Next.js项目的创建，十分钟前我一窍不通，十分钟后我觉得我已经了解了一个产品经理需要掌握的内容。</p><h3 id="2-2-项目规划"><a href="#2-2-项目规划" class="headerlink" title="2.2. 项目规划"></a>2.2. 项目规划</h3><p>在实现项目前期就一定要做好规划，这是与LLM配合顺利的基础。为了不重蹈项目混乱，无法调整，心烦意乱的覆辙，在任何项目开始前，最好都要根据实现难度，花上一定时间去和LLM好好</p><p>梳理项目结构，让它不要给出具体代码而是给出项目的目录结构，这样你心里就有数，之后如果出现错漏，你也能根据这个结构单独向LLM询问具体细节。</p><p>项目规划就通过README来编写，一般情况下需要有：</p><ul><li>项目介绍</li><li>技术栈</li><li>项目功能</li><li>目录结构之后就围绕README去实现就心里有底了。</li></ul><p><code>目录结构</code>之后基本都是要改变的，只是作为参考，不用过于关注。</p><p>大部分时候我一直修改的是<code>项目功能</code>，我会使用 <code>- []</code>清单来管理功能实现列表，避免遗漏和关注点偏移，因为LLM很轻易的就能写出让你觉得贼牛逼的代码，但是切忌自我感动，在项目基础功能实现前，不要让LLM自我发挥，先把Demo完成再说其他。</p><h3 id="2-3-与git配合"><a href="#2-3-与git配合" class="headerlink" title="2.3. 与git配合"></a>2.3. 与git配合</h3><p>一定要使用git管理代码，编程习惯决定了实现效率。我的经验就是：<strong>多暂存、勤提交、控版本</strong></p><p>在规划好项目系统架构后，让LLM 实现一个基础的网站框架，我就会commit第一个版本，在这个基础上进行增删改查。因为使用LLM编写代码，最忌讳一口气用LLM实现太多功能，导致出现问题了积重难返身心俱疲。</p><p>每次在进行大规模改动或者是调整功能之前，一定要去使用<code>Stage All Changes</code>暂存改动，避免影响了本来已经实现的代码。</p><p>并且一定要做好功能拆分，克制克制再克制，只要实现一个功能就提交，不然牵一发而动全身，越改越乱。我已经在这上面吃亏太多次了。</p><h3 id="2-3-拆分模块"><a href="#2-3-拆分模块" class="headerlink" title="2.3. 拆分模块"></a>2.3. 拆分模块</h3><p>拿网站来举例，拆分模块就是抽样代码功能，比如在page中有两个部分：顶栏和内容区域，那么我们最好拆分出<code>HeadBar.tsx</code>专门负责顶栏的逻辑；然后在顶栏中有头像、主页按钮、logo三部分，那么我就拆分出：<code>Avatar.tsx</code>、<code>HomeButton.tsx</code> 、<code>Logo.tsx</code>，分别负责自己组件的功能。</p><p>按照这个思路，还可以拆分功能逻辑，比如创建网络请求组件、路由调用切片、工厂模式组件等，不要看名字高大上听不懂，实际上这些都是LLM会在实现过程中自然呈现的逻辑，目的就是为了抽样代码，避免重复实现和方便统一管理。</p><p>尽可能保证每个文件只负责单独的模块功能，代码行数控制在200行以内。</p><p>不要嫌麻烦，创建文件不需要自己动手，直接让LLM帮你拆分实现，你点击<code>Apply</code>按钮它就会自动创建并填入代码。</p><p>这是一个非常重要的习惯，先执行，等回过头来你自然会意识到它的价值。</p><h3 id="2-4-创建新对话，精简上下文"><a href="#2-4-创建新对话，精简上下文" class="headerlink" title="2.4. 创建新对话，精简上下文"></a>2.4. 创建新对话，精简上下文</h3><p>上下文长度直接决定了LLM回答的质量。</p><p>为了最好的回答效果，我会尽可能的避免过长的对话内容，并且保证一次对话只解决一个问题，之后还可以通过回看对话历史来查缺补漏。</p><p>上面拆分模块也能极大的减少上下文，你只需要添加相关的代码，对话即可解决需求，而不需要每次携带多余的代码进行提问。</p><p>如果在一次对话中，一直没有解决问题，最好创建新对话，退后一步，让LLM从更多的角度去思考问题出现在哪，然后你再根据它的回答，依次提问尝试解决。</p><p>我在实现telegram bot的时候就遇到过无法启动机器人的情况，LLM一直执着于解决时延和时序问题，但是在一次回答中它提到了可能是代理设置错误，我捕捉到了这个答案，并且马上尝试，果然解决了问题。</p><p>依赖LLM，但是要意识到它的局限性，错误的对话历史会让它越错越远，你要知道适时的重启对话来避免“降智”。</p><hr><p>我暂时就写这些，肯定还有很多需要调整优化补充的细节，期待更多的交流。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次权限漏洞修复</title>
    <link href="/2025/02/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9D%83%E9%99%90%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/"/>
    <url>/2025/02/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9D%83%E9%99%90%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="OSS-AccessKey-安全风险故障处理文档"><a href="#OSS-AccessKey-安全风险故障处理文档" class="headerlink" title="OSS AccessKey 安全风险故障处理文档"></a>OSS AccessKey 安全风险故障处理文档</h1><hr><h2 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a><strong>故障现象</strong></h2><p>客户接口直接返回 OSS 的 <strong>AccessKey ID 和 AccessKey Secret</strong>，导致：</p><ol><li><strong>文件列表泄露</strong>：攻击者可利用 Key 拉取所有文件列表。</li><li><strong>文件内容泄露&#x2F;篡改</strong>：攻击者可下载敏感文件或覆盖&#x2F;删除现有文件。</li></ol><hr><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a><strong>原因分析</strong></h2><ol><li><strong>敏感信息暴露</strong>：AccessKey 明文传输导致泄露风险。</li><li><strong>权限过大</strong>：提供的 AccessKey 可能具备过高权限（如读写所有文件）。</li><li><strong>缺乏安全机制</strong>：未使用临时凭证或版本控制等防护措施。</li></ol><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><h3 id="1-最小化身份权限（关键措施）"><a href="#1-最小化身份权限（关键措施）" class="headerlink" title="1. 最小化身份权限（关键措施）"></a><strong>1. 最小化身份权限（关键措施）</strong></h3><ul><li><strong>创建 RAM 子账号</strong><br>通过阿里云 RAM 服务创建专用子账号，仅赋予最低权限：<ul><li><strong>上传权限</strong>：<code>oss:PutObject</code></li><li><strong>下载权限</strong>（如必须）：<code>oss:GetObject</code></li><li><strong>拒绝高危操作</strong>：如 <code>oss:DeleteObject</code>, <code>oss:ListObjects</code></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 示例权限策略（Policy）:</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;oss:PutObject&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;acs:oss:*:*:your-bucket-name/*&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><strong>禁用主账号 AccessKey</strong>：主账号密钥权限过高，优先使用子账号。</li></ul><hr><h3 id="2-文件版本控制（防覆盖）"><a href="#2-文件版本控制（防覆盖）" class="headerlink" title="2. 文件版本控制（防覆盖）"></a><strong>2. 文件版本控制（防覆盖）</strong></h3><ul><li><strong>启用版本控制</strong>：<br>在 OSS 控制台为 Bucket 开启<strong>版本管理</strong>，同名文件上传时会生成唯一版本 ID，旧文件仍保留。</li><li><strong>生命周期管理</strong>：<br>配置规则自动清理历史版本，避免存储成本增加。</li></ul><hr><h3 id="3-密钥轮换与监控"><a href="#3-密钥轮换与监控" class="headerlink" title="3. 密钥轮换与监控"></a><strong>3. 密钥轮换与监控</strong></h3><ul><li><strong>立即更换泄露的 AccessKey</strong>：<ol><li>在阿里云控制台 <strong>禁用旧 Key</strong>。</li><li><strong>生成新 Key</strong> 并绑定最小权限策略。</li><li>更新所有依赖该 Key 的应用配置。</li></ol></li><li><strong>日志审计</strong>：<br>启用 OSS 访问日志，监控异常请求（如高频 ListObjects 操作）。</li></ul><hr><h3 id="4-使用-STS-临时凭证（推荐方案）"><a href="#4-使用-STS-临时凭证（推荐方案）" class="headerlink" title="4. 使用 STS 临时凭证（推荐方案）"></a><strong>4. 使用 STS 临时凭证（推荐方案）</strong></h3><p><strong>通过服务端颁发临时 Token</strong>，实现客户端安全上传：</p><ul><li><strong>限制权限</strong>：临时 Token 仅包含 <code>oss:PutObject</code> 权限。</li><li><strong>控制有效期</strong>：Token 有效期建议设为 15~60 分钟。</li><li><strong>防下载策略示例</strong>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;oss:PutObject&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;acs:oss:*:*:your-bucket-name/*&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Deny&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;oss:Get*&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;oss:List*&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="操作流程总结"><a href="#操作流程总结" class="headerlink" title="操作流程总结"></a><strong>操作流程总结</strong></h2><ol><li><strong>紧急处理</strong>：<ul><li>撤回泄露 Key 的截图或日志。</li><li>立即禁用并更换泄露的 AccessKey。</li></ul></li><li><strong>权限收敛</strong>：改用子账号或 STS 临时凭证。</li><li><strong>防护加固</strong>：<ul><li>开启版本控制 + 日志审计。</li><li>配置防盗链（Referer 白名单）、IP 访问限制（可选）。</li></ul></li></ol><hr><h2 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a><strong>预防措施</strong></h2><ul><li><strong>前端隔离</strong>：<strong>前端绝不暴露 AccessKey</strong>，上传逻辑需通过服务端签发临时凭证。</li><li><strong>定期轮换密钥</strong>：设定 Key 自动轮换策略（如每 90 天）。</li><li><strong>渗透测试</strong>：定期扫描接口是否存在敏感信息泄露风险。</li></ul><hr><p><strong>关联文档</strong></p><ul><li><a href="https://help.aliyun.com/document_detail/122607.html">阿里云 RAM 权限配置指南</a></li><li><a href="https://help.aliyun.com/document_detail/109227.html">OSS 版本控制最佳实践</a></li><li><a href="https://help.aliyun.com/document_detail/100624.html">STS 临时凭证使用说明</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次nginx404问题</title>
    <link href="/2025/02/17/%E8%AE%B0%E4%B8%80%E6%AC%A1nginx404%E9%97%AE%E9%A2%98/"/>
    <url>/2025/02/17/%E8%AE%B0%E4%B8%80%E6%AC%A1nginx404%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次nginx404问题"><a href="#记一次nginx404问题" class="headerlink" title="记一次nginx404问题"></a>记一次nginx404问题</h1><h2 id="事故描述"><a href="#事故描述" class="headerlink" title="事故描述"></a>事故描述</h2><p>笔者所在公司使用的是nginx作为静态资源服务器，但是最近发现一个奇怪的问题，就是访问静态资源的时候，会出现404错误。</p><h2 id="事故排查"><a href="#事故排查" class="headerlink" title="事故排查"></a>事故排查</h2><p>笔者在浏览器控制台发现，访问的资源路径是OSS给出的地址，但是oss对应的路径上并没有对应的资源。因此报404错误</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>首先考虑把静态资源放到oss上去，但是由于服务是自动cicd的，所以无法这样处理，切可能会导致资源更新不及时的问题。</p><p>因此笔者考虑新建CDN域名，回源地址设置为nginx服务器的IP，即回源到本地的static目录，然后在nginx中添加oss域名的虚拟主机，把静态资源放到配置里面去。这里笔者还闹了个笑话，改完配置后没有重载nginx，导致配置不生效，白白浪费了半个小时。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>修改nginx配置文件时，切记先备份再操作，且修改完之后一定要-t检查-s reload加载配置。</p><p>遇到类似404问题，处理方案：检查404地址，cdn→回源地址。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次jenkins和gitlab故障</title>
    <link href="/2025/02/17/%E8%AE%B0%E4%B8%80%E6%AC%A1jenkins%E5%92%8Cgitlab%E6%95%85%E9%9A%9C/"/>
    <url>/2025/02/17/%E8%AE%B0%E4%B8%80%E6%AC%A1jenkins%E5%92%8Cgitlab%E6%95%85%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次jenkins和gitlab故障"><a href="#记一次jenkins和gitlab故障" class="headerlink" title="记一次jenkins和gitlab故障"></a>记一次jenkins和gitlab故障</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>笔者所在公司主要的开发语言是java和go，使用gitlab作为代码管理工具，使用jenkins作为CI&#x2F;CD工具。<br>公司封装了自己的运维平台，通过gitlab的webhook触发jenkins的构建和部署。然而之前的同事在测试环境做了一些gitlab的cicd配置，集成到ack集群中，导致项目部署的时候，jenkins构建的内容会被gitlab的cicd覆盖。由于主要使用的还是jenkins，因此需要停止gitlab的cicd，但是由于gitlab runner关联了ack集群，导致fluxcd会锁定应用版本，检查配置文件与gitlab中的是否一致，导致无法部署。jenkins部署无法生效。</p><h2 id="2-问题排查"><a href="#2-问题排查" class="headerlink" title="2. 问题排查"></a>2. 问题排查</h2><h3 id="2-1-排查gitlab的cicd配置"><a href="#2-1-排查gitlab的cicd配置" class="headerlink" title="2.1 排查gitlab的cicd配置"></a>2.1 排查gitlab的cicd配置</h3><p>故障项目使用的是gitlab的插件以及runner，在gitlab的cicd配置中，配置了runner，并且关联了ack集群。因此笔者首先暂停了git在分支代码出现变化了，触发runner，但是依然会被覆盖，经过查询<br>发现gitlab的runner会关联ack集群，生成flux-system命名空间，以及一些crd，通过这些crd与git仓库关联，读取配置并应用，然后尝试删除crd，失败，定位到git仓库的指定文件，笔者本来想直接修改，同事选择直接卸载了gitlab的runner插件，也达成效果。</p><h2 id="3-问题总结"><a href="#3-问题总结" class="headerlink" title="3. 问题总结"></a>3. 问题总结</h2><ol><li><p>在使用多个CI&#x2F;CD工具时，需要明确各个工具的职责范围，避免功能重叠导致冲突。</p></li><li><p>GitLab Runner与ACK集群集成后，会通过FluxCD进行配置同步，这种机制在某些场景下可能会与其他部署工具产生冲突。</p></li><li><p>解决此类问题时，可以采取以下方案：</p><ul><li>停用或卸载冲突的GitLab Runner插件</li><li>清理相关的CRD资源</li><li>确保团队使用统一的CI&#x2F;CD流程</li></ul></li><li><p>建议在测试环境进行配置更改时，需要评估对现有系统的影响，并做好文档记录，方便后续维护和故障排查。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用github actions自动发布hexo博客</title>
    <link href="/2025/02/17/%E4%BD%BF%E7%94%A8github%20actions%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83hexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2025/02/17/%E4%BD%BF%E7%94%A8github%20actions%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83hexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="使用github-actions自动发布hexo博客"><a href="#使用github-actions自动发布hexo博客" class="headerlink" title="使用github actions自动发布hexo博客"></a>使用github actions自动发布hexo博客</h1><p>假设我们有两个 Github 仓库，分别用于存放博客源代码和博客静态资源（存放博客静态资源的仓库名字通常为 usrname.github.io）。存放博客源代码的仓库下文称 src 仓库，存放博客静态资源的仓库下文称为 prd 仓库。</p><h2 id="1-设置密钥"><a href="#1-设置密钥" class="headerlink" title="1. 设置密钥"></a>1. 设置密钥</h2><p>首先在本地生成密钥对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>在 src 仓库中创建一个名为 <code>id_rsa</code> 的密钥对，并将其添加到 Github 仓库的 <code>Settings</code> -&gt; <code>Secrets</code> -&gt; <code>New repository secret</code> 中，命名为 <code>HEXO_DEPLOY_PRI</code>。</p><p>接着设置 prd 仓库的 <code>Settings</code> -&gt; <code>Deploy keys</code> -&gt; <code>Add deploy key</code> 中，命名为 <code>HEXO_DEPLOY_PUB</code>，并勾选 <code>Allow write access</code>。</p><h2 id="2-设置-Github-Actions"><a href="#2-设置-Github-Actions" class="headerlink" title="2. 设置 Github Actions"></a>2. 设置 Github Actions</h2><p>在 src 仓库中创建一个名为 <code>.github/workflows</code> 的文件夹，并在其中创建一个名为 <code>deploy.yml</code> 的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">name: Deploy hexo blog</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">    - hexo</span><br><span class="line"></span><br><span class="line"><span class="built_in">env</span>:</span><br><span class="line">  GIT_USER: starrynightzyq[bot]</span><br><span class="line">  GIT_EMAIL: starrynightzyq[bot]@gmail.com</span><br><span class="line"></span><br><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  build:</span><br><span class="line">    name: Build with node <span class="variable">$&#123;&#123; matrix.node-version &#125;</span>&#125; on <span class="variable">$&#123;&#123; matrix.os &#125;</span>&#125;</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    <span class="keyword">if</span>: github.event.repository.owner.id == github.event.sender.id</span><br><span class="line"></span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        os: [ubuntu-latest]</span><br><span class="line">        node-version: [16.x]</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout</span><br><span class="line">        uses: actions/checkout@v4</span><br><span class="line">      - name: Use Node.js <span class="variable">$&#123;&#123; matrix.node-version &#125;</span>&#125;</span><br><span class="line">        uses: actions/setup-node@v4</span><br><span class="line">        with:</span><br><span class="line">          node-version: <span class="variable">$&#123;&#123; matrix.node-version &#125;</span>&#125;</span><br><span class="line">      - name: Install SSH key</span><br><span class="line">        uses: shimataro/ssh-key-action@v2</span><br><span class="line">        with:</span><br><span class="line">          key: <span class="variable">$&#123;&#123; secrets.HEXO_DEPLOY_PRI &#125;</span>&#125;</span><br><span class="line">          name: id_rsa</span><br><span class="line">          known_hosts: <span class="string">&#x27;github.com&#x27;</span></span><br><span class="line">          if_key_exists: replace</span><br><span class="line">      - name: Configuration environment</span><br><span class="line">        run: |</span><br><span class="line">          <span class="built_in">sudo</span> timedatectl set-timezone <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">          git config --global user.name <span class="variable">$GIT_USER</span></span><br><span class="line">          git config --global user.email <span class="variable">$GIT_EMAIL</span></span><br><span class="line">      - name: Setup pandoc</span><br><span class="line">        uses: nikeee/setup-pandoc@v1</span><br><span class="line">      - name: Install dependencies</span><br><span class="line">        run: |</span><br><span class="line">          npm install</span><br><span class="line">      - name: Deploy hexo</span><br><span class="line">        run: |</span><br><span class="line">          npm run publish</span><br></pre></td></tr></table></figure><p>配置好之后，我们在 src 仓库的 source&#x2F;_posts&#x2F; 目录下创建一个 Markdown 文件，编写博客内容，然后提交代码，Github Actions 就会自动构建博客，并将博客部署到 prd 仓库。</p>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github Actions</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次nginx405问题</title>
    <link href="/2025/02/17/%E8%AE%B0%E4%B8%80%E6%AC%A1nginx405%E9%97%AE%E9%A2%98/"/>
    <url>/2025/02/17/%E8%AE%B0%E4%B8%80%E6%AC%A1nginx405%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>公司服务突然出现405问题，导致服务无法正常访问，而且日志也中断了。研发人员尝试重启服务，发现重启不了，笔者登陆服务器查看资源占用情况正常，服务运行正常。<br>同事提到405可能是waf拦截了，安全检查后发现确实拦截了。</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>由于公司服务是跨云部署，一部分在阿里云，一部分在天翼云，阿里云出口ip就是nat网关的ip，因此在流量增大时，会导致nat出口ip被waf加入黑名单，导致服务不可用。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>暂时将nat出口ip加入白名单</p><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ol><li><p>跨云部署架构中，需要特别注意各个云服务商之间的网络通信问题，尤其是NAT网关的出口IP管理。</p></li><li><p>WAF（Web应用防火墙）在保护服务安全的同时，也可能因为误判导致正常业务中断：</p><ul><li>当流量突增时，容易触发WAF的防护规则</li><li>NAT网关出口IP被误判为攻击源</li><li>405错误通常表示请求方法不被允许</li></ul></li><li><p>临时解决方案：</p><ul><li>将NAT出口IP加入WAF白名单</li></ul></li><li><p>长期优化建议：</p><ul><li>评估是否需要调整WAF的防护规则</li><li>考虑使用专线或VPN等更稳定的跨云连接方案</li><li>建立完善的监控告警机制，及时发现类似问题</li><li>做好NAT网关出口IP的变更管理</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>故障梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>405</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day07</title>
    <link href="/2025/02/17/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day07/"/>
    <url>/2025/02/17/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day07/</url>
    
    <content type="html"><![CDATA[<p>区别于C&#x2F;C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p><p>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p><h1 id="Go语言中的指针"><a href="#Go语言中的指针" class="headerlink" title="Go语言中的指针"></a>Go语言中的指针</h1><p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p><p>比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量<code>A</code>，把内存地址赋值给变量<code>B</code>。这时候变量<code>B</code>就是一个指针变量。通过变量<code>A</code>和变量<code>B</code>都能找到我的座右铭。</p><p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：<code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）。</p><h2 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h2><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用<code>&amp;</code>字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code>等。</p><p>取变量指针的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v    <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>v:代表被取地址的变量，类型为<code>T</code></li><li>ptr:用于接收地址的变量，ptr的类型就为<code>*T</code>，称做T的指针类型。*代表指针。</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := &amp;a</span><br><span class="line">fmt.Printf(<span class="string">&quot;a:%d ptr:%p\n&quot;</span>, a, &amp;a) <span class="comment">// a:10 ptr:0xc00001a078</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;b:%p type:%T\n&quot;</span>, b, b) <span class="comment">// b:0xc00001a078 type:*int</span></span><br><span class="line">fmt.Println(&amp;b)                    <span class="comment">// 0xc00000e018</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下<code>b := &amp;a</code>的图示：![[附件&#x2F;675fca20f188f55b47390d0c2cae6089_MD5.png]]</p><h2 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h2><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//指针取值</span></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := &amp;a <span class="comment">// 取变量a的地址，将指针保存到b中</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b)</span><br><span class="line">c := *b <span class="comment">// 指针取值（根据指针去内存取值）</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of c:%T\n&quot;</span>, c)</span><br><span class="line">fmt.Printf(<span class="string">&quot;value of c:%v\n&quot;</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> of b:*<span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> of c:<span class="type">int</span></span><br><span class="line">value of c:<span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><p><strong>指针传值示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify1</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify2</span><span class="params">(x *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">*x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">modify1(a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 10</span></span><br><span class="line">modify2(&amp;a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><p>我们先来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line">*a = <span class="number">100</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">b[<span class="string">&quot;沙河娜扎&quot;</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new是一个内置的函数，它的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span></span> *Type</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li><li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li></ul><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">b := <span class="built_in">new</span>(<span class="type">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, b) <span class="comment">// *bool</span></span><br><span class="line">fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节开始的示例代码中<code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line">a = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">*a = <span class="number">10</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make也是用于内存分配的，区别于new，它只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span></span> Type</span><br></pre></td></tr></table></figure><p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。</p><p>本节开始的示例中<code>var b map[string]int</code>只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">b[<span class="string">&quot;沙河娜扎&quot;</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new与make的区别"><a href="#new与make的区别" class="headerlink" title="new与make的区别"></a>new与make的区别</h3><ol><li>二者都是用来做内存分配的。</li><li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li><li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ol><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><h1 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h1><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p><p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br></pre></td></tr></table></figure><p>通过<code>type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名是<code>Go1.9</code>版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure><p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">byte</span> = <span class="type">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">rune</span> = <span class="type">int32</span></span><br></pre></td></tr></table></figure><h2 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a>类型定义和类型别名的区别</h2><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a NewInt</span><br><span class="line"><span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p><p>Go语言中通过<code>struct</code>来实现面向对象。</p><h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，具体代码格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li><li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li><li>字段类型：表示结构体字段的具体类型。</li></ul><p>举个例子，我们定义一个<code>Person</code>（人）结构体，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">city <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">name, city <span class="type">string</span></span><br><span class="line">age        <span class="type">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拥有了一个<code>person</code>的自定义类型，它有<code>name</code>、<code>city</code>、<code>age</code>三个字段，分别表示姓名、城市和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p><h2 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h2><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></table></figure><h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h3><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">city <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">p1.age = <span class="number">18</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p1=%v\n&quot;</span>, p1)  <span class="comment">//p1=&#123;沙河娜扎 北京 18&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p1=%#v\n&quot;</span>, p1) <span class="comment">//p1=main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过<code>.</code>来访问结构体的字段（成员变量）,例如<code>p1.name</code>和<code>p1.age</code>等。</p><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">     </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="type">string</span>; Age <span class="type">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h3><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">p2.age = <span class="number">28</span></span><br><span class="line">p2.city = <span class="string">&quot;上海&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;上海&quot;, age:28&#125;</span></span><br></pre></td></tr></table></figure><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">&quot;七米&quot;</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;七米&quot;, city:&quot;成都&quot;, age:30&#125;</span></span><br></pre></td></tr></table></figure><p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p><h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><p>没有初始化的结构体，其成员变量都是对应其类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">city <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p4 person</span><br><span class="line">fmt.Printf(<span class="string">&quot;p4=%#v\n&quot;</span>, p4) <span class="comment">//p4=main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p5=%#v\n&quot;</span>, p5) <span class="comment">//p5=main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p6=%#v\n&quot;</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p7=%#v\n&quot;</span>, p7) <span class="comment">//p7=&amp;main.person&#123;name:&quot;&quot;, city:&quot;北京&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line"><span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line"><span class="string">&quot;北京&quot;</span>,</span><br><span class="line"><span class="number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p8=%#v\n&quot;</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:28&#125;</span></span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ol><li>必须初始化结构体的所有字段。</li><li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li><li>该方式不能和键值初始化方式混用。</li></ol><h2 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h2><p>结构体占用一块连续的内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="type">int8</span></span><br><span class="line">b <span class="type">int8</span></span><br><span class="line">c <span class="type">int8</span></span><br><span class="line">d <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.a %p\n&quot;</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.b %p\n&quot;</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.c %p\n&quot;</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.d %p\n&quot;</span>, &amp;n.d)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure><p>【进阶知识点】关于Go语言中的内存对齐推荐阅读:<a href="https://www.liwenzhou.com/posts/Go/struct-memory-layout/">Go结构体的内存对齐</a></p><h3 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h3><p>空结构体是不占用空间的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(v))  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>请问下面代码的执行结果是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*student)</span><br><span class="line">stus := []student&#123;</span><br><span class="line">&#123;name: <span class="string">&quot;小王子&quot;</span>, age: <span class="number">18</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;娜扎&quot;</span>, age: <span class="number">23</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;大王八&quot;</span>, age: <span class="number">9000</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">m[stu.name] = &amp;stu</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, <span class="string">&quot;=&gt;&quot;</span>, v.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p9 := newPerson(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;沙河&quot;</span>, <span class="number">90</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p9) <span class="comment">//&amp;main.person&#123;name:&quot;张三&quot;, city:&quot;沙河&quot;, age:90&#125;</span></span><br></pre></td></tr></table></figure><h2 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h2><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p><p>方法的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *Person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">name: name,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Dream() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的<code>this</code>或者<code>self</code>。 例如我们为<code>Person</code>添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetAge(newAge <span class="type">int8</span>) &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">p1.SetAge(<span class="number">30</span>)</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> SetAge2(newAge <span class="type">int8</span>) &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h3><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><h2 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h2><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span></span> SayHello() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, 我是一个int。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m1 MyInt</span><br><span class="line">m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">m1 = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v  %T\n&quot;</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong> 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h2 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">string</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := Person&#123;</span><br><span class="line"><span class="string">&quot;小王子&quot;</span>,</span><br><span class="line"><span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">//main.Person&#123;string:&quot;北京&quot;, int:18&#125;</span></span><br><span class="line">fmt.Println(p1.<span class="type">string</span>, p1.<span class="type">int</span>) <span class="comment">//北京 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意：**这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h2 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h2><p>一个结构体中可以嵌套包含另一个结构体或结构体指针，就像下面的示例代码那样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="type">string</span></span><br><span class="line">City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">Gender  <span class="type">string</span></span><br><span class="line">Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := User&#123;</span><br><span class="line">Name:   <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: <span class="string">&quot;山东&quot;</span>,</span><br><span class="line">City:     <span class="string">&quot;威海&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套匿名字段"><a href="#嵌套匿名字段" class="headerlink" title="嵌套匿名字段"></a>嵌套匿名字段</h3><p>上面user结构体中嵌套的<code>Address</code>结构体也可以采用匿名字段的方式，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="type">string</span></span><br><span class="line">City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">Gender  <span class="type">string</span></span><br><span class="line">Address <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user2 User</span><br><span class="line">user2.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">user2.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">user2.Address.Province = <span class="string">&quot;山东&quot;</span>    <span class="comment">// 匿名字段默认使用类型名作为字段名</span></span><br><span class="line">user2.City = <span class="string">&quot;威海&quot;</span>                <span class="comment">// 匿名字段可以省略</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;user2=%#v\n&quot;</span>, user2) <span class="comment">//user2=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。</p><h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province   <span class="type">string</span></span><br><span class="line">City       <span class="type">string</span></span><br><span class="line">CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">Account    <span class="type">string</span></span><br><span class="line">CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="type">string</span></span><br><span class="line">Gender <span class="type">string</span></span><br><span class="line">Address</span><br><span class="line">Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user3 User</span><br><span class="line">user3.Name = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">user3.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="comment">// user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime</span></span><br><span class="line">user3.Address.CreateTime = <span class="string">&quot;2000&quot;</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">user3.Email.CreateTime = <span class="string">&quot;2000&quot;</span>   <span class="comment">//指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h2><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Feet    <span class="type">int8</span></span><br><span class="line">*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := &amp;Dog&#123;</span><br><span class="line">Feet: <span class="number">4</span>,</span><br><span class="line">Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h2><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h2 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键&#x2F;值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="type">int</span></span><br><span class="line">Gender <span class="type">string</span></span><br><span class="line">Name   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">Title    <span class="type">string</span></span><br><span class="line">Students []Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;Class&#123;</span><br><span class="line">Title:    <span class="string">&quot;101&quot;</span>,</span><br><span class="line">Students: <span class="built_in">make</span>([]Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">stu := Student&#123;</span><br><span class="line">Name:   fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i),</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">ID:     i,</span><br><span class="line">&#125;</span><br><span class="line">c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">data, err := json.Marshal(c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json:%s\n&quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">str := <span class="string">`&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;,&#123;&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;&#125;,&#123;&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;&#125;,&#123;&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;&#125;,&#123;&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;&#125;,&#123;&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;&#125;,&#123;&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;&#125;,&#123;&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;&#125;]&#125;`</span></span><br><span class="line">c1 := &amp;Class&#123;&#125;</span><br><span class="line">err = json.Unmarshal([]<span class="type">byte</span>(str), c1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h2><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，具体的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:<span class="string">&quot;value1&quot;</span> key2:<span class="string">&quot;value2&quot;</span>`</span><br></pre></td></tr></table></figure><p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p><p><strong>注意事项：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p><p>例如我们为<code>Student</code>结构体的每个字段定义json序列化时使用的Tag：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">Gender <span class="type">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">name   <span class="type">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := Student&#123;</span><br><span class="line">ID:     <span class="number">1</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">name:   <span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(s1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体和方法补充知识点"><a href="#结构体和方法补充知识点" class="headerlink" title="结构体和方法补充知识点"></a>结构体和方法补充知识点</h2><p>因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。我们来看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="type">string</span></span><br><span class="line">age    <span class="type">int8</span></span><br><span class="line">dreams []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetDreams(dreams []<span class="type">string</span>) &#123;</span><br><span class="line">p.dreams = dreams</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := Person&#123;name: <span class="string">&quot;小王子&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">data := []<span class="type">string</span>&#123;<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;打豆豆&quot;</span>&#125;</span><br><span class="line">p1.SetDreams(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你真的想要修改 p1.dreams 吗？</span></span><br><span class="line">data[<span class="number">1</span>] = <span class="string">&quot;不睡觉&quot;</span></span><br><span class="line">fmt.Println(p1.dreams)  <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetDreams(dreams []<span class="type">string</span>) &#123;</span><br><span class="line">p.dreams = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(dreams))</span><br><span class="line"><span class="built_in">copy</span>(p.dreams, dreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题。</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>使用“面向对象”的思维方式编写一个学生信息管理系统。<ol><li>学生有id、姓名、年龄、分数等信息</li><li>程序提供展示学生列表、添加学生、编辑学生信息、删除学生等功能</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day06</title>
    <link href="/2025/02/16/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day06/"/>
    <url>/2025/02/16/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day06/</url>
    
    <content type="html"><![CDATA[<p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。本文介绍了Go语言中函数的相关内容。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</li><li>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用<code>,</code>分隔。</li><li>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。</li><li>函数体：实现指定功能的代码块。</li></ul><p>我们先来定义一个求两个数之和的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello 沙河&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>定义了函数之后，我们可以通过<code>函数名()</code>的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello()</span><br><span class="line">ret := intSum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，调用有返回值的函数时，可以不接收其返回值。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="类型简写"><a href="#类型简写" class="headerlink" title="类型简写"></a>类型简写</h3><p>函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>intSum</code>函数有两个参数，这两个参数的类型均为<code>int</code>，因此可以省略<code>x</code>的类型，因为<code>y</code>后面有类型说明，<code>x</code>参数也是该类型。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p><p>注意：可变参数通常要作为函数的最后一个参数。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum2</span><span class="params">(x ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fmt.Println(x) <span class="comment">//x是一个切片</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret1 := intSum2()</span><br><span class="line">ret2 := intSum2(<span class="number">10</span>)</span><br><span class="line">ret3 := intSum2(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">ret4 := intSum2(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">fmt.Println(ret1, ret2, ret3, ret4) <span class="comment">//0 10 30 60</span></span><br></pre></td></tr></table></figure><p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum3</span><span class="params">(x <span class="type">int</span>, y ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">sum := x</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> y &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上述函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret5 := intSum3(<span class="number">100</span>)</span><br><span class="line">ret6 := intSum3(<span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">ret7 := intSum3(<span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">ret8 := intSum3(<span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">fmt.Println(ret5, ret6, ret7, ret8) <span class="comment">//100 110 130 160</span></span><br></pre></td></tr></table></figure><p>本质上，函数的可变参数是通过切片来实现的。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>Go语言中通过<code>return</code>关键字向外输出返回值。</p><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">sum := x + y</span><br><span class="line">sub := x - y</span><br><span class="line"><span class="keyword">return</span> sum, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值命名"><a href="#返回值命名" class="headerlink" title="返回值命名"></a>返回值命名</h3><p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>)</span></span> (sum, sub <span class="type">int</span>) &#123;</span><br><span class="line">sum = x + y</span><br><span class="line">sub = x - y</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值补充"><a href="#返回值补充" class="headerlink" title="返回值补充"></a>返回值补充</h3><p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunc</span><span class="params">(x <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 没必要返回[]int&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量num</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGlobalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;num=%d\n&quot;</span>, num) <span class="comment">//函数中可以访问全局变量num</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testGlobalVar() <span class="comment">//num=10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义一个函数局部变量x,仅在该函数内生效</span></span><br><span class="line"><span class="keyword">var</span> x <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;x=%d\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testLocalVar()</span><br><span class="line">fmt.Println(x) <span class="comment">// 此时无法使用变量x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果局部变量和全局变量重名，优先访问局部变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量num</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;num=%d\n&quot;</span>, num) <span class="comment">// 函数中优先使用局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testNum() <span class="comment">// num=100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar2</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x, y) <span class="comment">//函数的参数也是只在本函数中生效</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">z := <span class="number">100</span> <span class="comment">//变量z只在if语句块生效</span></span><br><span class="line">fmt.Println(z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println(z)//此处无法使用变量z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i) <span class="comment">//变量i只在当前for语句块中生效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println(i) //此处无法使用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h2><h3 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h3><p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p><p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add和sub都能赋值给calculation类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c calculation</span><br><span class="line">c = add</span><br></pre></td></tr></table></figure><h3 id="函数类型变量"><a href="#函数类型变量" class="headerlink" title="函数类型变量"></a>函数类型变量</h3><p>我们可以声明函数类型的变量并且为该变量赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c calculation               <span class="comment">// 声明一个calculation类型的变量c</span></span><br><span class="line">c = add                         <span class="comment">// 把add赋值给c</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of c:%T\n&quot;</span>, c) <span class="comment">// type of c:main.calculation</span></span><br><span class="line">fmt.Println(c(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用add一样调用c</span></span><br><span class="line"></span><br><span class="line">f := add                        <span class="comment">// 将函数add赋值给变量f</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of f:%T\n&quot;</span>, f) <span class="comment">// type of f:func(int, int) int</span></span><br><span class="line">fmt.Println(f(<span class="number">10</span>, <span class="number">20</span>))          <span class="comment">// 像调用add一样调用f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数分为函数作为参数和函数作为返回值两部分。</p><h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><p>函数可以作为参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret2 := calc(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">fmt.Println(ret2) <span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>函数也可以作为返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> add, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> sub, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err := errors.New(<span class="string">&quot;无法识别的操作符&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将匿名函数保存到变量</span></span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 通过变量调用匿名函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自执行函数：匿名函数定义完加()直接执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数多用于实现回调函数和闭包。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。 首先我们来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = adder()</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//60</span></span><br><span class="line"></span><br><span class="line">f1 := adder()</span><br><span class="line">fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//40</span></span><br><span class="line">fmt.Println(f1(<span class="number">50</span>)) <span class="comment">//90</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。 闭包进阶示例1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder2</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = adder2(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//20</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//40</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//70</span></span><br><span class="line"></span><br><span class="line">f1 := adder2(<span class="number">20</span>)</span><br><span class="line">fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//60</span></span><br><span class="line">fmt.Println(f1(<span class="number">50</span>)) <span class="comment">//110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffixFunc</span><span class="params">(suffix <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line"><span class="keyword">return</span> name + suffix</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jpgFunc := makeSuffixFunc(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">txtFunc := makeSuffixFunc(<span class="string">&quot;.txt&quot;</span>)</span><br><span class="line">fmt.Println(jpgFunc(<span class="string">&quot;test&quot;</span>)) <span class="comment">//test.jpg</span></span><br><span class="line">fmt.Println(txtFunc(<span class="string">&quot;test&quot;</span>)) <span class="comment">//test.txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例3：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(base <span class="type">int</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">base += i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">base -= i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1, f2 := calc(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>)) <span class="comment">//11 9</span></span><br><span class="line">fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>)) <span class="comment">//12 8</span></span><br><span class="line">fmt.Println(f1(<span class="number">5</span>), f2(<span class="number">6</span>)) <span class="comment">//13 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p><h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p><h3 id="defer执行时机"><a href="#defer执行时机" class="headerlink" title="defer执行时机"></a>defer执行时机</h3><p>在Go语言的函数中<code>return</code>语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而<code>defer</code>语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：<img src="https://www.liwenzhou.com/images/Go/func/defer.png" alt="defer执行时机"></p><h3 id="defer经典案例"><a href="#defer经典案例" class="headerlink" title="defer经典案例"></a>defer经典案例</h3><p>阅读下面的代码，写出最后的打印结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">x := <span class="number">5</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> (x <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> (y <span class="type">int</span>) &#123;</span><br><span class="line">x := <span class="number">5</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span></span> (x <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;(x)</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f1())</span><br><span class="line">fmt.Println(f2())</span><br><span class="line">fmt.Println(f3())</span><br><span class="line">fmt.Println(f4())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer面试题"><a href="#defer面试题" class="headerlink" title="defer面试题"></a>defer面试题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">1</span></span><br><span class="line">y := <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">y = <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问，上面代码的输出结果是？（提示：defer注册要延迟执行的函数时该函数所有的参数都需要确定其值）</p><h1 id="内置函数介绍"><a href="#内置函数介绍" class="headerlink" title="内置函数介绍"></a>内置函数介绍</h1><table><thead><tr><th>内置函数</th><th>介绍</th></tr></thead><tbody><tr><td>close</td><td>主要用来关闭channel</td></tr><tr><td>len</td><td>用来求长度，比如string、array、slice、map、channel</td></tr><tr><td>new</td><td>用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td>make</td><td>用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td>append</td><td>用来追加元素到数组、slice中</td></tr><tr><td>panic和recover</td><td>用来做错误处理</td></tr></tbody></table><h3 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic&#x2F;recover"></a>panic&#x2F;recover</h3><p>Go语言中目前（Go1.12）是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效。 首先来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;func A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;panic in B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;func C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br><span class="line">funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func A</span><br><span class="line">panic: panic <span class="keyword">in</span> B</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.funcB(...)</span><br><span class="line">        .../code/func/main.go:12</span><br><span class="line">main.main()</span><br><span class="line">        .../code/func/main.go:20 +0x98</span><br></pre></td></tr></table></figure><p>程序运行期间<code>funcB</code>中引发了<code>panic</code>导致程序崩溃，异常退出了。这个时候我们就可以通过<code>recover</code>将程序恢复回来，继续往后执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;func A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := <span class="built_in">recover</span>()</span><br><span class="line"><span class="comment">//如果程序出出现了panic错误,可以通过recover恢复过来</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;recover in B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;panic in B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;func C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br><span class="line">funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><code>recover()</code>必须搭配<code>defer</code>使用。</li><li><code>defer</code>一定要在可能引发<code>panic</code>的语句之前定义。</li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>分金币</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">你有50枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。</span></span><br><span class="line"><span class="comment">分配规则如下：</span></span><br><span class="line"><span class="comment">a. 名字中每包含1个&#x27;e&#x27;或&#x27;E&#x27;分1枚金币</span></span><br><span class="line"><span class="comment">b. 名字中每包含1个&#x27;i&#x27;或&#x27;I&#x27;分2枚金币</span></span><br><span class="line"><span class="comment">c. 名字中每包含1个&#x27;o&#x27;或&#x27;O&#x27;分3枚金币</span></span><br><span class="line"><span class="comment">d: 名字中每包含1个&#x27;u&#x27;或&#x27;U&#x27;分4枚金币</span></span><br><span class="line"><span class="comment">写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？</span></span><br><span class="line"><span class="comment">程序结构如下，请实现 ‘dispatchCoin’ 函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">coins = <span class="number">50</span></span><br><span class="line">users = []<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Matthew&quot;</span>, <span class="string">&quot;Sarah&quot;</span>, <span class="string">&quot;Augustus&quot;</span>, <span class="string">&quot;Heidi&quot;</span>, <span class="string">&quot;Emilie&quot;</span>, <span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Giana&quot;</span>, <span class="string">&quot;Adriano&quot;</span>, <span class="string">&quot;Aaron&quot;</span>, <span class="string">&quot;Elizabeth&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">distribution = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="built_in">len</span>(users))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">left := dispatchCoin()</span><br><span class="line">fmt.Println(<span class="string">&quot;剩下：&quot;</span>, left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 跨域配置</title>
    <link href="/2025/02/13/nginx%E8%B7%A8%E5%9F%9F/"/>
    <url>/2025/02/13/nginx%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<p>在 Nginx 中实现跨域（CORS，Cross-Origin Resource Sharing）是通过配置 HTTP 响应头来允许浏览器跨域访问资源。以下是详细的配置方法和解析：</p><hr><h2 id="1-跨域问题的背景"><a href="#1-跨域问题的背景" class="headerlink" title="1. 跨域问题的背景"></a>1. <strong>跨域问题的背景</strong></h2><ul><li><strong>跨域</strong> 是指浏览器从一个域名（源）向另一个域名发起请求时，由于浏览器的同源策略（Same-Origin Policy），请求会被阻止。</li><li><strong>CORS</strong> 是一种机制，允许服务器声明哪些源可以访问其资源。</li></ul><hr><h2 id="2-Nginx-跨域配置"><a href="#2-Nginx-跨域配置" class="headerlink" title="2. Nginx 跨域配置"></a>2. <strong>Nginx 跨域配置</strong></h2><h3 id="2-1-基本配置"><a href="#2-1-基本配置" class="headerlink" title="2.1 基本配置"></a>2.1 <strong>基本配置</strong></h3><p>在 Nginx 配置文件中，添加以下配置以支持跨域请求：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs powershell">server &#123;<br>    listen <span class="hljs-number">80</span>;<br>    server_name example.com;<br><br>    location / &#123;<br>        <span class="hljs-comment"># 允许所有域名跨域访问</span><br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br><br>        <span class="hljs-comment"># 允许的请求方法</span><br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br><br>        <span class="hljs-comment"># 允许的请求头</span><br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br><br>        <span class="hljs-comment"># 预检请求（OPTIONS）的缓存时间</span><br>        add_header <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br><br>        <span class="hljs-comment"># 允许客户端携带凭证（如 Cookie）</span><br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br><br>        <span class="hljs-comment"># 处理 OPTIONS 请求</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">204</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-2-配置解析"><a href="#2-2-配置解析" class="headerlink" title="2.2 配置解析"></a>2.2 <strong>配置解析</strong></h3><ul><li><strong><code>Access-Control-Allow-Origin</code></strong>：<ul><li>指定允许跨域访问的源（域名）。</li><li>&#96;&#96; 表示允许所有域名访问，也可以指定具体的域名（如 <code>https://example.com</code>）。</li></ul></li><li><strong><code>Access-Control-Allow-Methods</code></strong>：<ul><li>指定允许的 HTTP 方法（如 <code>GET</code>、<code>POST</code>、<code>OPTIONS</code>）。</li></ul></li><li><strong><code>Access-Control-Allow-Headers</code></strong>：<ul><li>指定允许的请求头（如 <code>Content-Type</code>、<code>Authorization</code>）。</li></ul></li><li><strong><code>Access-Control-Max-Age</code></strong>：<ul><li>指定预检请求（OPTIONS）的缓存时间（单位：秒）。</li></ul></li><li><strong><code>Access-Control-Allow-Credentials</code></strong>：<ul><li>指定是否允许客户端携带凭证（如 Cookie）。</li><li>如果设置为 <code>true</code>，则 <code>Access-Control-Allow-Origin</code> 不能为 &#96;&#96;，必须指定具体的域名。</li></ul></li><li><strong><code>OPTIONS</code> 请求处理</strong>：<ul><li>预检请求（OPTIONS）用于检查服务器是否允许跨域请求。</li><li>返回 <code>204 No Content</code> 表示允许跨域请求。</li></ul></li></ul><hr><h2 id="3-高级配置"><a href="#3-高级配置" class="headerlink" title="3. 高级配置"></a>3. <strong>高级配置</strong></h2><h3 id="3-1-允许特定域名跨域"><a href="#3-1-允许特定域名跨域" class="headerlink" title="3.1 允许特定域名跨域"></a>3.1 <strong>允许特定域名跨域</strong></h3><p>如果只想允许特定域名跨域访问，可以将 <code>Access-Control-Allow-Origin</code> 设置为具体的域名：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;&lt;https://example.com&gt;&#x27;</span>;<br><br></code></pre></td></tr></table></figure><h3 id="3-2-动态设置允许的域名"><a href="#3-2-动态设置允许的域名" class="headerlink" title="3.2 动态设置允许的域名"></a>3.2 <strong>动态设置允许的域名</strong></h3><p>如果需要根据请求的 <code>Origin</code> 动态设置允许的域名，可以使用 Nginx 的变量：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">set</span> <span class="hljs-variable">$cors_origin</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-attribute">if</span> (<span class="hljs-variable">$http_origin</span> <span class="hljs-regexp">~* &quot;^https://(example.com|another.com)$&quot;)</span> &#123;<br>    <span class="hljs-attribute">set</span> <span class="hljs-variable">$cors_origin</span> <span class="hljs-variable">$http_origin</span>;<br>&#125;<br><span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$cors_origin</span>;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-允许复杂请求"><a href="#3-3-允许复杂请求" class="headerlink" title="3.3 允许复杂请求"></a>3.3 <strong>允许复杂请求</strong></h3><p>对于复杂请求（如携带自定义头或使用非简单方法），需要正确处理预检请求（OPTIONS）：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$cors_origin</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br><br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$cors_origin</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="4-测试跨域配置"><a href="#4-测试跨域配置" class="headerlink" title="4. 测试跨域配置"></a>4. <strong>测试跨域配置</strong></h2><ol><li><p>使用浏览器开发者工具（如 Chrome DevTools）检查请求的响应头，确认是否包含 <code>Access-Control-Allow-Origin</code> 等跨域头。</p></li><li><p>使用 <code>curl</code> 命令测试 OPTIONS 请求：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X OPTIONS -H <span class="hljs-string">&quot;Origin: &lt;https://example.com&gt;&quot;</span> -H <span class="hljs-string">&quot;Access-Control-Request-Method: GET&quot;</span> -I &lt;https://your-nginx-server.com&gt;<br><br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><ul><li>在 Nginx 中实现跨域访问需要通过配置 HTTP 响应头（如 <code>Access-Control-Allow-Origin</code>）来允许浏览器跨域请求资源。</li><li>可以根据需求配置允许的域名、请求方法、请求头等。</li><li>对于复杂请求，需要正确处理预检请求（OPTIONS）。</li></ul><p>如果还有其他问题，欢迎继续讨论！</p>]]></content>
    
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 超时问题</title>
    <link href="/2025/02/13/nginx%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2025/02/13/nginx%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a><strong>背景概述</strong></h2><p>最近计划着重分析一下线上各api的HTTP响应耗时情况，检查是否有接口平均耗时、99分位耗时等相关指标过大的情况，了解到nginx统计请求耗时有四个指标：request_time、upstream_response_time、upstream_connect_time与upstream_header_time，在查找资料的过程中，发现无论是nginx官方文档还是热心网友们的分享，都并没有让自己感觉特别详细、明白地说清楚了这四个指标详细具体含义的资料，于是自己动手探究了一番nginx源码，尝试从其中找出这4个指标的代码级别具体含义。</p><p>特别说明：本文代码分析基于nginx 1.10.0版本，从源码层面分析一次完整HTTP请求log中request_time、upstream_response_time、upstream_connect_time与upstream_header_time四个指标的具体含义，本文中得出的相应结论仅基于个人学习、研究所得，非权威结论，如有不当之处欢迎指正、一起探讨。</p><h2 id="一次完整HTTP请求-响应的各耗时阶段拆分"><a href="#一次完整HTTP请求-响应的各耗时阶段拆分" class="headerlink" title="一次完整HTTP请求&#x2F;响应的各耗时阶段拆分"></a><strong>一次完整HTTP请求&#x2F;响应的各耗时阶段拆分</strong></h2><p>首先详细拆分一下一个完整HTTP请求(非keep alive)生命周期的多个阶段（以下C指代客户端，N指代nginx服务器，S指代上游server）：</p><ol><li>C向N发起TCP三次握手建立连接成功，C开始向N通过TCP发送HTTP请求具体数据(header&#x2F;body…)</li><li>N开始接收到C发送的数据到全部接收完成</li><li>N作为代理向S发起TCP三次握手并建立连接成功，N开始向S发送HTTP数据</li><li>S开始接收N发送的数据并全部接收完成</li><li>S业务代码根据业务规则进行处理完成并生成HTTP响应结果</li><li>S开始将响应结果发送给N</li><li>N开始接收响应结果并接收header部分完成</li><li>N接收S返回的全部响应结果完成，准备关闭该连接</li><li>N开始向C返回全部的HTTP响应结果并发送完成</li><li>C开始接收N返回的数据并全部接收完成</li><li>N向C发起四次挥手关闭TCP连接</li></ol><p>其中1-2和9-11这5个阶段 的速度直接受到C到N之间的网络质量影响，服务端虽然可以通过降低传输数据量、使用更快的协议(如HTTP3.0基于QUIC)等降低传输耗时，但无法起到决定性的作用，一般可视为超出了可优化的控制范围。</p><p>3-8这6个阶段一般都发生在内网，即N与S都处于同一个机房(甚至同一个机架&#x2F;同一台物理机上)，网络质量稳定且RTT基本在1ms内，网络耗时较少，正常情况下其主要时间应集中在阶段5–各种业务逻辑处理数据并生成结果–这也正是一般后端优化的目标阶段。</p><h2 id="各耗时指标nginx官方解释-疑问"><a href="#各耗时指标nginx官方解释-疑问" class="headerlink" title="各耗时指标nginx官方解释 &amp;&amp; 疑问"></a><strong>各耗时指标nginx官方解释 &amp;&amp; 疑问</strong></h2><p>参考:<a href="http://nginx.org/en/docs/http/ngx_http_log_module.html">http://nginx.org/en/docs/http/ngx_http_log_module.html</a></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">$request_time</span><br>request processing <span class="hljs-keyword">time</span> in seconds with a milliseconds resolution; <span class="hljs-keyword">time</span> elapsed between the first bytes were <span class="hljs-keyword">read</span> from the client <span class="hljs-keyword">and</span> the <span class="hljs-keyword">log</span> <span class="hljs-keyword">write</span> after the <span class="hljs-keyword">last</span> bytes were sent to the client<br><br></code></pre></td></tr></table></figure><p>request_time是N接收到C第一个字节数起至N向C发送完最后一个字节数止后日志记录的时间。</p><p>疑问：接收到第一个字节包括TCP三次握手的字节吗？发送完最后一个字节的具体定义是什么–N发送最后一个字节必须收到C的ACK才算发送完成？</p><p>参考: <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html">http://nginx.org/en/docs/http/ngx_http_upstream_module.html</a></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$upstream_connect_time<br>keeps <span class="hljs-built_in">time</span> spent <span class="hljs-keyword">on</span> establishing a connection <span class="hljs-keyword">with</span> the upstream server (<span class="hljs-number">1.9</span>.<span class="hljs-number">1</span>); the <span class="hljs-built_in">time</span> <span class="hljs-keyword">is</span> kept <span class="hljs-keyword">in</span> seconds <span class="hljs-keyword">with</span> millisecond resolution. <span class="hljs-keyword">In</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">of</span> SSL, includes <span class="hljs-built_in">time</span> spent <span class="hljs-keyword">on</span> handshake. Times <span class="hljs-keyword">of</span> several connections are separated by commas <span class="hljs-keyword">and</span> colons like addresses <span class="hljs-keyword">in</span> the $upstream_addr <span class="hljs-keyword">variable</span>.<br><br></code></pre></td></tr></table></figure><p>upstream_connect_time记录N与S建立起一个连接的耗时，在SSL中也包括SSL握手的时间。</p><p>疑问：有一丝不确定这个时间具体是指N到S的 TCP三次握手开始到连接建立完成时间–对应上面阶段3？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$<span class="hljs-function">upstream_header_time</span><br><span class="hljs-function">keeps time spent <span class="hljs-keyword">on</span> receiving the response header <span class="hljs-keyword">from</span> the upstream <span class="hljs-title">server</span> (<span class="hljs-params"><span class="hljs-number">1.7</span><span class="hljs-number">.10</span></span>)</span>; the time <span class="hljs-keyword">is</span> kept <span class="hljs-keyword">in</span> seconds <span class="hljs-keyword">with</span> millisecond resolution. Times of several responses are separated <span class="hljs-keyword">by</span> commas <span class="hljs-keyword">and</span> colons like addresses <span class="hljs-keyword">in</span> the $upstream_addr variable.<br><br></code></pre></td></tr></table></figure><p>upstream_header_time记录N接收到S响应header的时间。</p><p>疑问：能够理解会包含N到S连接建立后收到S header的时间–阶段4~7，但是否包括upstream_connect_time这个建连时间–阶段3呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">$upstream_response_time<br>keeps <span class="hljs-type">time</span> spent <span class="hljs-keyword">on</span> receiving the response <span class="hljs-keyword">from</span> the upstream server; the <span class="hljs-type">time</span> <span class="hljs-keyword">is</span> kept <span class="hljs-keyword">in</span> seconds <span class="hljs-keyword">with</span> millisecond resolution. Times <span class="hljs-keyword">of</span> several responses <span class="hljs-keyword">are</span> separated <span class="hljs-keyword">by</span> commas <span class="hljs-keyword">and</span> colons <span class="hljs-keyword">like</span> addresses <span class="hljs-keyword">in</span> the $upstream_addr variable.<br><br></code></pre></td></tr></table></figure><p>upstream_response_time记录N接收S完整响应的时间。</p><p>疑问：应包含阶段4-8，但是否包括upstream_connect_time这个建连时间–阶段3？</p><p>如上，按照字面意思翻译得到的各指标含义很简洁，但是让人不是很明了，不由的生出一些疑问，于是决定探究一下nginx源码尝试彻底弄清楚这几个指标的具体含义。</p><h2 id="nginx源码探究"><a href="#nginx源码探究" class="headerlink" title="nginx源码探究"></a><strong>nginx源码探究</strong></h2><h3 id="request-time指标"><a href="#request-time指标" class="headerlink" title="request_time指标"></a><strong>request_time指标</strong></h3><p>手上有一份nginx 1.10.0的源码，虽然版本比较旧，但是想来指标统计的基本逻辑是不会变的，先探查范围最大的指标request_time，该指标属于模块ngx_http_log_module,其相关代码在http&#x2F;ngx_http_variables.c 的ngx_http_variable_request_time函数中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">http/ngx_http_variables.c</span><br><span class="hljs-number">2041 </span><span class="hljs-string">static</span> <span class="hljs-string">ngx_int_t</span><br><span class="hljs-number">2042 </span><span class="hljs-string">ngx_http_variable_request_time(ngx_http_request_t</span> <span class="hljs-string">*r,</span><br><span class="hljs-number">2043     </span><span class="hljs-string">ngx_http_variable_value_t</span> <span class="hljs-string">*v,</span> <span class="hljs-string">uintptr_t</span> <span class="hljs-string">data)</span><br><span class="hljs-number">2044</span> &#123;<br><span class="hljs-string">...</span><br><span class="hljs-number">2054     </span><span class="hljs-string">tp</span> <span class="hljs-string">=</span> <span class="hljs-string">ngx_timeofday();</span> <span class="hljs-string">//</span> <span class="hljs-string">获取当前时刻</span><br><span class="hljs-number">2055</span><br><span class="hljs-number">2056     </span><span class="hljs-string">ms</span> <span class="hljs-string">=</span> <span class="hljs-string">(ngx_msec_int_t)</span> <span class="hljs-string">//</span> <span class="hljs-string">当前时刻减去开始时刻得到耗时</span><br><span class="hljs-number">2057</span>              <span class="hljs-string">((tp-&gt;sec</span> <span class="hljs-bullet">-</span> <span class="hljs-string">r-&gt;start_sec)</span> <span class="hljs-string">*</span> <span class="hljs-number">1000</span> <span class="hljs-string">+</span> <span class="hljs-string">(tp-&gt;msec</span> <span class="hljs-bullet">-</span> <span class="hljs-string">r-&gt;start_msec));</span><br><span class="hljs-number">2058     </span><span class="hljs-string">ms</span> <span class="hljs-string">=</span> <span class="hljs-string">ngx_max(ms</span>, <span class="hljs-number">0</span><span class="hljs-string">);</span><br><span class="hljs-number">2059</span><br><span class="hljs-number">2060     </span><span class="hljs-string">v-&gt;len</span> <span class="hljs-string">=</span> <span class="hljs-string">ngx_sprintf(p</span>, <span class="hljs-string">&quot;%T.%03M&quot;</span>, <span class="hljs-string">(time_t)</span> <span class="hljs-string">ms</span> <span class="hljs-string">/</span> <span class="hljs-number">1000</span>, <span class="hljs-string">ms</span> <span class="hljs-string">%</span> <span class="hljs-number">1000</span><span class="hljs-string">)</span> <span class="hljs-bullet">-</span> <span class="hljs-string">p;</span><br><span class="hljs-string">...</span><br><span class="hljs-number">2066     </span><span class="hljs-string">return</span> <span class="hljs-string">NGX_OK;</span><br><span class="hljs-number">2067</span> &#125;<br><br></code></pre></td></tr></table></figure><p>关键在于ngx_http_variable_request_time函数的调用时机以及r-&gt;start_sec、msec(ngx_http_request_t.start_sec&#x2F;msec)的记录时机，查找源码可以发现ngx_http_request_t.start_sec的记录时间位于http&#x2F;ngx_http_request.c的ngx_http_create_request函数中，ngx_http_create_request函数会在ngx_http_wait_request_handler被调用，一步步往上追溯最后会发现，ngx_http_create_request实际是在N的监听进程与C建立TCP连接后接收到数据触发可读事件后被调用，即start_sec&#x2F;msec记录的是连接建立后收到第一个可读字节时的–此时HTTP所在的应用层还未真正读取数据，数据只是交付到了TCP所在的传输层。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// http/ngx_http_request.c</span><br><span class="hljs-number">503</span> ngx_http_request_t *<br> <span class="hljs-number">504</span> <span class="hljs-title function_ invoke__">ngx_http_create_request</span>(ngx_connection_t *c)<br> <span class="hljs-number">505</span> &#123;<br> ...<br>  <span class="hljs-number">579</span>     r<span class="hljs-punctuation">-&gt;</span>main = r;<br> <span class="hljs-number">580</span>     r<span class="hljs-punctuation">-&gt;</span>count = <span class="hljs-number">1</span>;<br> <span class="hljs-number">581</span><br> <span class="hljs-number">582</span>     tp = <span class="hljs-title function_ invoke__">ngx_timeofday</span>();<br> <span class="hljs-number">583</span>     r<span class="hljs-punctuation">-&gt;</span>start_sec = tp<span class="hljs-punctuation">-&gt;</span>sec;<br> <span class="hljs-number">584</span>     r<span class="hljs-punctuation">-&gt;</span>start_msec = tp<span class="hljs-punctuation">-&gt;</span>msec;<br> <span class="hljs-number">585</span>...<br>  <span class="hljs-number">611</span> &#125;<br><br></code></pre></td></tr></table></figure><p>而对于ngx_http_variable_request_time的调用时机，追溯源码发现其被放置于放在ngx_http_core_module全局变量中，而ngx_http_core_module会在ngx_http_log_init函数中注册到main_conf，最终http&#x2F;ngx_http_request.c的ngx_http_free_request函数中会调用ngx_http_log_request，而后在其中通过main_conf得到log相关handler并执行，其相关代码如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">http/ngx_http_request.c</span><br><span class="hljs-number">3410 </span><span class="hljs-string">void</span><br><span class="hljs-number">3411 </span><span class="hljs-string">ngx_http_free_request(ngx_http_request_t</span> <span class="hljs-string">*r,</span> <span class="hljs-string">ngx_int_t</span> <span class="hljs-string">rc)</span><br><span class="hljs-number">3412</span> &#123;<br><span class="hljs-string">...</span><br><span class="hljs-number">3456     </span><span class="hljs-string">log-&gt;action</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;logging request&quot;</span><span class="hljs-string">;</span><br><span class="hljs-number">3457</span><br><span class="hljs-number">3458     </span><span class="hljs-string">ngx_http_log_request(r);</span><br><span class="hljs-number">3459</span><br><span class="hljs-number">3460     </span><span class="hljs-string">log-&gt;action</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;closing request&quot;</span><span class="hljs-string">;</span><br><span class="hljs-number">3461</span><br><span class="hljs-number">3462     </span><span class="hljs-string">if</span> <span class="hljs-string">(r-&gt;connection-&gt;timedout)</span> &#123;<br><span class="hljs-number">3463         </span><span class="hljs-string">clcf</span> <span class="hljs-string">=</span> <span class="hljs-string">ngx_http_get_module_loc_conf(r</span>, <span class="hljs-string">ngx_http_core_module);</span><br><span class="hljs-number">3464</span><br><span class="hljs-number">3465         </span><span class="hljs-string">if</span> <span class="hljs-string">(clcf-&gt;reset_timedout_connection)</span> &#123;<br><span class="hljs-number">3466             </span><span class="hljs-string">linger.l_onoff</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">;</span><br><span class="hljs-number">3467             </span><span class="hljs-string">linger.l_linger</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span><br><span class="hljs-number">3468</span><br><span class="hljs-number">3469             </span><span class="hljs-string">if</span> <span class="hljs-string">(setsockopt(r-&gt;connection-&gt;fd</span>, <span class="hljs-string">SOL_SOCKET</span>, <span class="hljs-string">SO_LINGER</span>,<br><span class="hljs-number">3470</span>                            <span class="hljs-string">(const</span> <span class="hljs-string">void</span> <span class="hljs-string">*)</span> <span class="hljs-string">&amp;linger</span>, <span class="hljs-string">sizeof(struct</span> <span class="hljs-string">linger))</span> <span class="hljs-string">==</span> <span class="hljs-number">-1</span><span class="hljs-string">)</span><br><span class="hljs-number">3471</span>             &#123;<br><span class="hljs-number">3472                 </span><span class="hljs-string">ngx_log_error(NGX_LOG_ALERT</span>, <span class="hljs-string">log</span>, <span class="hljs-string">ngx_socket_errno</span>,<br><span class="hljs-number">3473</span>                               <span class="hljs-string">&quot;setsockopt(SO_LINGER) failed&quot;</span><span class="hljs-string">);</span><br><span class="hljs-number">3474</span>             &#125;<br><span class="hljs-number">3475</span>         &#125;<br><span class="hljs-number">3476</span>     &#125;<br><span class="hljs-string">...</span><br><span class="hljs-number">3500 </span><span class="hljs-string">ngx_http_log_request(ngx_http_request_t</span> <span class="hljs-string">*r)</span><br><span class="hljs-number">3501</span> &#123;<br><span class="hljs-number">3502     </span><span class="hljs-string">ngx_uint_t</span>                  <span class="hljs-string">i</span>, <span class="hljs-string">n;</span><br><span class="hljs-number">3503     </span><span class="hljs-string">ngx_http_handler_pt</span>        <span class="hljs-string">*log_handler;</span><br><span class="hljs-number">3504     </span><span class="hljs-string">ngx_http_core_main_conf_t</span>  <span class="hljs-string">*cmcf;</span><br><span class="hljs-number">3505</span><br><span class="hljs-number">3506     </span><span class="hljs-string">cmcf</span> <span class="hljs-string">=</span> <span class="hljs-string">ngx_http_get_module_main_conf(r</span>, <span class="hljs-string">ngx_http_core_module);</span><br><span class="hljs-number">3507</span><br><span class="hljs-number">3509     </span><span class="hljs-string">log_handler</span> <span class="hljs-string">=</span> <span class="hljs-string">cmcf-&gt;phases</span>[<span class="hljs-string">NGX_HTTP_LOG_PHASE</span>]<span class="hljs-string">.handlers.elts;</span><br><span class="hljs-number">3510     </span><span class="hljs-string">n</span> <span class="hljs-string">=</span> <span class="hljs-string">cmcf-&gt;phases</span>[<span class="hljs-string">NGX_HTTP_LOG_PHASE</span>]<span class="hljs-string">.handlers.nelts;</span><br><span class="hljs-number">3511</span><br><span class="hljs-number">3512     </span><span class="hljs-string">for</span> <span class="hljs-string">(i</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span> <span class="hljs-string">i</span> <span class="hljs-string">&lt;</span> <span class="hljs-string">n;</span> <span class="hljs-string">i++)</span> &#123;<br><span class="hljs-number">3513         </span><span class="hljs-string">log_handler</span>[<span class="hljs-string">i</span>]<span class="hljs-string">(r);</span><br><span class="hljs-number">3514</span>     &#125;<br><span class="hljs-number">3515</span> &#125;<br><br></code></pre></td></tr></table></figure><p>可以看到ngx_http_log_request正好在使用setsockopt优雅关闭连接前调用，<strong>由此得出结论,request_time起始时间为N接收到TCP包触发第一次可读event后，应用层正式读取数据前的时刻，而结束时间为N发送完全部数据给C，调用setsockopt优雅关闭连接前一时刻，即包括阶段2~9，注意这里N认为的发送完成是指N调用send发送完成返回，只代表了数据已经存到了协议栈buffer之中，而不是代表已经发送到C并收到C的ack，所以request_time仅统计到N认为自己发送完成时的时间，不包括数据实际发送到C并被C接收ack时间，更不包括TCP四次挥手的时间了。</strong></p><h3 id="upstream-connect-time"><a href="#upstream-connect-time" class="headerlink" title="upstream_connect_time"></a><strong>upstream_connect_time</strong></h3><p>upstream_connect_time、upstream_header_time与upstream_response_time三个指标均属于ngx_http_upstream模块，对应nginx中的connect_time、header_time、response_time三个变量，其初始化代码位于ngx_http_upstream.c中的ngx_http_upstream_connect函数，相关代码如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">http/ngx_http_upstream.c</span><br><span class="hljs-number">1328 </span><span class="hljs-string">static</span> <span class="hljs-string">void</span><br><span class="hljs-number">1329 </span><span class="hljs-string">ngx_http_upstream_connect(ngx_http_request_t</span> <span class="hljs-string">*r,</span> <span class="hljs-string">ngx_http_upstream_t</span> <span class="hljs-string">*u)</span><br><span class="hljs-number">1330</span> &#123;<br><span class="hljs-number">1331     </span><span class="hljs-string">ngx_int_t</span>          <span class="hljs-string">rc;</span><br><span class="hljs-number">1332     </span><span class="hljs-string">ngx_connection_t</span>  <span class="hljs-string">*c;</span><br><span class="hljs-string">...</span><br><span class="hljs-number">1346</span><br><span class="hljs-number">1347     </span><span class="hljs-string">ngx_memzero(u-&gt;state</span>, <span class="hljs-string">sizeof(ngx_http_upstream_state_t));</span><br><span class="hljs-number">1348</span><br><span class="hljs-number">1349     </span><span class="hljs-string">u-&gt;state-&gt;response_time</span> <span class="hljs-string">=</span> <span class="hljs-string">ngx_current_msec;</span><br><span class="hljs-number">1350     </span><span class="hljs-string">u-&gt;state-&gt;connect_time</span> <span class="hljs-string">=</span> <span class="hljs-string">(ngx_msec_t)</span> <span class="hljs-number">-1</span><span class="hljs-string">;</span><br><span class="hljs-number">1351     </span><span class="hljs-string">u-&gt;state-&gt;header_time</span> <span class="hljs-string">=</span> <span class="hljs-string">(ngx_msec_t)</span> <span class="hljs-number">-1</span><span class="hljs-string">;</span><br><span class="hljs-number">1352</span><br><span class="hljs-number">1353     </span><span class="hljs-string">rc</span> <span class="hljs-string">=</span> <span class="hljs-string">ngx_event_connect_peer(&amp;u-&gt;peer);</span><br><span class="hljs-number">1354</span><br><span class="hljs-number">1355     </span><span class="hljs-string">ngx_log_debug1(NGX_LOG_DEBUG_HTTP</span>, <span class="hljs-string">r-&gt;connection-&gt;log</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">1356</span>                    <span class="hljs-string">&quot;http upstream connect: %i&quot;</span>, <span class="hljs-string">rc);</span><br><span class="hljs-string">...</span><br><span class="hljs-number">1467     </span><span class="hljs-string">ngx_http_upstream_send_request(r</span>, <span class="hljs-string">u</span>, <span class="hljs-number">1</span><span class="hljs-string">);</span><br><span class="hljs-number">1468</span> &#125;<br><br></code></pre></td></tr></table></figure><p>可以看到其初始值设置正好处于ngx_event_connect_peer函数前，即N即将开始与S建立连接之前，注意此时response_time被设置为了当前时刻时间，而后继续追溯源码可以发现connect_time最终在ngx_http_upstream_connect函数末尾调用的ngx_http_upstream_send_request函数中进行了赋值，相关代码如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">http/ngx_http_upstream.c</span><br><span class="hljs-number">1782 </span><span class="hljs-string">static</span> <span class="hljs-string">void</span><br><span class="hljs-number">1783 </span><span class="hljs-string">ngx_http_upstream_send_request(ngx_http_request_t</span> <span class="hljs-string">*r,</span> <span class="hljs-string">ngx_http_upstream_t</span> <span class="hljs-string">*u,</span><br><span class="hljs-number">1784     </span><span class="hljs-string">ngx_uint_t</span> <span class="hljs-string">do_write)</span><br><span class="hljs-number">1785</span> &#123;<br><span class="hljs-string">...</span><br><span class="hljs-number">1791     </span><span class="hljs-string">ngx_log_debug0(NGX_LOG_DEBUG_HTTP</span>, <span class="hljs-string">c-&gt;log</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">1792</span>                    <span class="hljs-string">&quot;http upstream send request&quot;</span><span class="hljs-string">);</span><br><span class="hljs-number">1793</span><br><span class="hljs-number">1794     </span><span class="hljs-string">if</span> <span class="hljs-string">(u-&gt;state-&gt;connect_time</span> <span class="hljs-string">==</span> <span class="hljs-string">(ngx_msec_t)</span> <span class="hljs-number">-1</span><span class="hljs-string">)</span> &#123;<br><span class="hljs-number">1795         </span><span class="hljs-string">u-&gt;state-&gt;connect_time</span> <span class="hljs-string">=</span> <span class="hljs-string">ngx_current_msec</span> <span class="hljs-bullet">-</span> <span class="hljs-string">u-&gt;state-&gt;response_time;</span><br><span class="hljs-number">1796</span>     &#125;<br><span class="hljs-string">...</span><br><span class="hljs-string">...</span><br><span class="hljs-number">1864     </span><span class="hljs-string">if</span> <span class="hljs-string">(c-&gt;read-&gt;ready)</span> &#123;<br><span class="hljs-number">1865         </span><span class="hljs-string">ngx_http_upstream_process_header(r</span>, <span class="hljs-string">u);</span><br><span class="hljs-number">1866         </span><span class="hljs-string">return;</span><br><span class="hljs-number">1867</span>     &#125;<br><span class="hljs-number">1868</span> &#125;<br><br></code></pre></td></tr></table></figure><p><strong>由此可以得出结论，upstream_connect_time起始时刻为N将与S建立连接前一刻，结束时刻为N与S建立连接成功后，即包括阶段3。</strong></p><h3 id="upstream-header-time"><a href="#upstream-header-time" class="headerlink" title="upstream_header_time"></a><strong>upstream_header_time</strong></h3><p>接下来探究upstream_header_time，可在ngx_http_upstream_send_request函数末尾调用的ngx_http_upstream_process_header中发现header_time的赋值语句：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">2047 </span><span class="hljs-string">static</span> <span class="hljs-string">void</span><br><span class="hljs-number">2048 </span><span class="hljs-string">ngx_http_upstream_process_header(ngx_http_request_t</span> <span class="hljs-string">*r,</span> <span class="hljs-string">ngx_http_upstream_t</span> <span class="hljs-string">*u)</span><br><span class="hljs-number">2049</span> &#123;<br><span class="hljs-string">...</span><br><span class="hljs-number">2058</span><br><span class="hljs-number">2059     </span><span class="hljs-string">c-&gt;log-&gt;action</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;reading response header from upstream&quot;</span><span class="hljs-string">;</span><br><span class="hljs-string">...</span><br><span class="hljs-number">2104     </span><span class="hljs-string">for</span> <span class="hljs-string">(</span> <span class="hljs-string">;;</span> <span class="hljs-string">)</span> &#123;<br><span class="hljs-number">2105</span><br><span class="hljs-number">2106         </span><span class="hljs-string">n</span> <span class="hljs-string">=</span> <span class="hljs-string">c-&gt;recv(c</span>, <span class="hljs-string">u-&gt;buffer.last</span>, <span class="hljs-string">u-&gt;buffer.end</span> <span class="hljs-bullet">-</span> <span class="hljs-string">u-&gt;buffer.last);</span><br><span class="hljs-string">...</span><br>&#125;<br><span class="hljs-string">...</span><br><span class="hljs-number">2172     </span><span class="hljs-string">u-&gt;state-&gt;header_time</span> <span class="hljs-string">=</span> <span class="hljs-string">ngx_current_msec</span> <span class="hljs-bullet">-</span> <span class="hljs-string">u-&gt;state-&gt;response_time;</span><br><span class="hljs-string">...</span><br><span class="hljs-number">2184</span><br><span class="hljs-number">2185     </span><span class="hljs-string">if</span> <span class="hljs-string">(ngx_http_upstream_process_headers(r</span>, <span class="hljs-string">u)</span> <span class="hljs-type">!=</span> <span class="hljs-string">NGX_OK)</span> &#123;<br><span class="hljs-number">2186         </span><span class="hljs-string">return;</span><br><span class="hljs-number">2187</span>     &#125;<br><span class="hljs-string">...</span><br><br></code></pre></td></tr></table></figure><p><strong>由此可得出结论，即header_time起始时刻应为N与S将建立连接前一刻，结束时刻为建立连接成功并在应用层接收header数据完成，即阶段3~7。</strong></p><h3 id="upstream-response-time"><a href="#upstream-response-time" class="headerlink" title="upstream_response_time"></a><strong>upstream_response_time</strong></h3><p>最后探究upstream_response_time，追溯代码可以发现response_time最终在ngx_http_upstream_finalize_request函数中被赋值，相关代码如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">http/ngx_http_upstream.c</span><br><span class="hljs-number">4064 </span><span class="hljs-string">static</span> <span class="hljs-string">void</span><br><span class="hljs-number">4065 </span><span class="hljs-string">ngx_http_upstream_finalize_request(ngx_http_request_t</span> <span class="hljs-string">*r,</span><br><span class="hljs-number">4066     </span><span class="hljs-string">ngx_http_upstream_t</span> <span class="hljs-string">*u,</span> <span class="hljs-string">ngx_int_t</span> <span class="hljs-string">rc)</span><br><span class="hljs-number">4067</span> &#123;<br><span class="hljs-string">...</span><br><span class="hljs-number">4086</span><br><span class="hljs-number">4087     </span><span class="hljs-string">if</span> <span class="hljs-string">(u-&gt;state</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">u-&gt;state-&gt;response_time)</span> &#123;<br><span class="hljs-number">4088         </span><span class="hljs-string">u-&gt;state-&gt;response_time</span> <span class="hljs-string">=</span> <span class="hljs-string">ngx_current_msec</span> <span class="hljs-bullet">-</span> <span class="hljs-string">u-&gt;state-&gt;response_time;</span><br><span class="hljs-number">4089</span><br><span class="hljs-number">4090         </span><span class="hljs-string">if</span> <span class="hljs-string">(u-&gt;pipe</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">u-&gt;pipe-&gt;read_length)</span> &#123;<br><span class="hljs-number">4091             </span><span class="hljs-string">u-&gt;state-&gt;response_length</span> <span class="hljs-string">=</span> <span class="hljs-string">u-&gt;pipe-&gt;read_length;</span><br><span class="hljs-number">4092</span>         &#125;<br><span class="hljs-number">4093</span>     &#125;<br><span class="hljs-number">4094</span><br><span class="hljs-number">4095     </span><span class="hljs-string">u-&gt;finalize_request(r</span>, <span class="hljs-string">rc);</span><br><span class="hljs-number">4096</span><br><span class="hljs-number">4097     </span><span class="hljs-string">if</span> <span class="hljs-string">(u-&gt;peer.free</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">u-&gt;peer.sockaddr)</span> &#123;<br><span class="hljs-number">4098         </span><span class="hljs-string">u-&gt;peer.free(&amp;u-&gt;peer</span>, <span class="hljs-string">u-&gt;peer.data</span>, <span class="hljs-number">0</span><span class="hljs-string">);</span><br><span class="hljs-number">4099         </span><span class="hljs-string">u-&gt;peer.sockaddr</span> <span class="hljs-string">=</span> <span class="hljs-literal">NULL</span><span class="hljs-string">;</span><br><span class="hljs-number">4100</span>     &#125;<br><span class="hljs-number">4101</span><br><span class="hljs-number">4102     </span><span class="hljs-string">if</span> <span class="hljs-string">(u-&gt;peer.connection)</span> &#123;<br><span class="hljs-number">4103</span><br><span class="hljs-number">4104</span> <span class="hljs-comment">#if (NGX_HTTP_SSL)</span><br><span class="hljs-number">4105</span><br><span class="hljs-attr">4106         /* TODO:</span> <span class="hljs-string">do</span> <span class="hljs-string">not</span> <span class="hljs-string">shutdown</span> <span class="hljs-string">persistent</span> <span class="hljs-string">connection</span> <span class="hljs-string">*/</span><br><span class="hljs-number">4107</span><br><span class="hljs-number">4108         </span><span class="hljs-string">if</span> <span class="hljs-string">(u-&gt;peer.connection-&gt;ssl)</span> &#123;<br><span class="hljs-number">4109</span><br><span class="hljs-number">4110</span>             <span class="hljs-string">/*</span><br><span class="hljs-number">4111</span>              <span class="hljs-string">*</span> <span class="hljs-string">We</span> <span class="hljs-string">send</span> <span class="hljs-string">the</span> <span class="hljs-string">&quot;close notify&quot;</span> <span class="hljs-string">shutdown</span> <span class="hljs-string">alert</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">upstream</span> <span class="hljs-string">only</span><br><span class="hljs-number">4112</span>              <span class="hljs-string">*</span> <span class="hljs-string">and</span> <span class="hljs-string">do</span> <span class="hljs-string">not</span> <span class="hljs-string">wait</span> <span class="hljs-string">its</span> <span class="hljs-string">&quot;close notify&quot;</span> <span class="hljs-string">shutdown</span> <span class="hljs-string">alert.</span><br><span class="hljs-number">4113</span>              <span class="hljs-string">*</span> <span class="hljs-string">It</span> <span class="hljs-string">is</span> <span class="hljs-string">acceptable</span> <span class="hljs-string">according</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">TLS</span> <span class="hljs-string">standard.</span><br><span class="hljs-number">4114</span>              <span class="hljs-string">*/</span><br><span class="hljs-number">4115</span><br><span class="hljs-number">4116             </span><span class="hljs-string">u-&gt;peer.connection-&gt;ssl-&gt;no_wait_shutdown</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">;</span><br><span class="hljs-number">4117</span><br><span class="hljs-number">4118</span>             <span class="hljs-string">(void)</span> <span class="hljs-string">ngx_ssl_shutdown(u-&gt;peer.connection);</span><br><span class="hljs-number">4119</span>         &#125;<br><span class="hljs-number">4120</span> <span class="hljs-comment">#endif</span><br><span class="hljs-number">4121</span><br><span class="hljs-number">4122         </span><span class="hljs-string">ngx_log_debug1(NGX_LOG_DEBUG_HTTP</span>, <span class="hljs-string">r-&gt;connection-&gt;log</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">4123</span>                        <span class="hljs-string">&quot;close http upstream connection: %d&quot;</span>,<br><span class="hljs-number">4124                        </span><span class="hljs-string">u-&gt;peer.connection-&gt;fd);</span><br><span class="hljs-number">4125</span><br><span class="hljs-number">4126         </span><span class="hljs-string">if</span> <span class="hljs-string">(u-&gt;peer.connection-&gt;pool)</span> &#123;<br><span class="hljs-number">4127             </span><span class="hljs-string">ngx_destroy_pool(u-&gt;peer.connection-&gt;pool);</span><br><span class="hljs-number">4128</span>         &#125;<br><span class="hljs-number">4129</span><br><span class="hljs-number">4130         </span><span class="hljs-string">ngx_close_connection(u-&gt;peer.connection);</span><br><span class="hljs-number">4131</span>     &#125;<br><span class="hljs-string">...</span><br><br></code></pre></td></tr></table></figure><p>可以看到u-&gt;state-&gt;response_time &#x3D; ngx_current_msec - u-&gt;state-&gt;response_time; 在ngx_close_connection之前执行，<strong>由此可以得出结论，upstream_response_time起始时刻为N与S将建立连接前一刻，结束时间为N接收完S全部响应数据将关闭连接前一刻，即阶段3~8。</strong></p><h2 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a><strong>最终结论</strong></h2><p>经过源码追溯最终可以得出request_time、upstream_response_time、upstream_connect_time与upstream_header_time四个指标的关系为:</p><p><strong>upstream_header_time &#x3D; upstream_connect_time(阶段3) + N向S发送数据被接收完成时间(阶段4) + S业务代码处理数据返回并被N接收完header部分数据的时间(阶段5~7)</strong></p><p><strong>upstream_response_time &#x3D; upstream_header_time + N接收完S除header部分剩余全部数据的时间(阶段8)</strong></p><p><strong>request_time &#x3D; N开始接收C全部数据并完成的时间(阶段2) + upstream_response_time + N向C send响应数据并完成(阶段9)</strong></p><p>至于一开始对于文档解释request_time 接收第一个字节的、发送完最后一个字节的具体定义，在阅读过程中也有了答案：</p><p>HTTP是应用层协议，其建立于传输层的TCP协议之上，而TCP是保证有序和可靠的–其每一个有效数据包都必须收到对端的ACK确认才算发送成功，因此站在N的角度看待数据接收与发送完成，可以得出以下结论：</p><p>其所谓的接收第一个字节时刻必然是属于C发向N的第一个TCP有效数据包被接收时刻–不会包括三次握手纯SYN&#x2F;ACK包–除非第三个握手包已经带了有效数据。</p><p>而所谓的发送完最后一个字节时刻，则由于N使用send发送响应给C，指的是调用send函数发送完数据的时刻–仅代表数据已成功写入协议栈buffer，并不代表N已经接收到了C确认收到所有数据的ack。</p><p>转载请注明出处，原文地址： <a href="https://www.cnblogs.com/AcAc-t/p/nginx_request_time_upstream_respone_time_analysis.html">https://www.cnblogs.com/AcAc-t/p/nginx_request_time_upstream_respone_time_analysis.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><p><a href="http://nginx.org/en/docs/http/ngx_http_log_module.html">http://nginx.org/en/docs/http/ngx_http_log_module.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd 工具和客户端库</title>
    <link href="/2025/02/13/etcd-tools/"/>
    <url>/2025/02/13/etcd-tools/</url>
    
    <content type="html"><![CDATA[<p>以下是关于 etcd 工具和客户端库的汇总<br>翻译自：<a href="https://etcd.io/docs/v3.5/integrations/">https://etcd.io/docs/v3.5/integrations/</a></p><h3 id="库和工具"><a href="#库和工具" class="headerlink" title="库和工具"></a>库和工具</h3><p>etcd 工具和客户端库列表。<br>请注意，以下提到的第三方库和工具（不托管在 <a href="https://github.com/etcd-io">https://github.com/etcd-io</a> 上）没有经过 etcd 团队的测试和维护。在使用它们之前，建议用户先阅读和调查这些库和工具。</p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul><li><strong>etcdctl</strong> - etcd 的命令行客户端。</li><li><strong>etcd-dump</strong> - 用于转储&#x2F;恢复 etcd 的命令行工具。</li><li><strong>etcd-fs</strong> - 基于 FUSE 的 etcd 文件系统。</li><li><strong>etcddir</strong> - 实时同步 etcd 和本地目录，适用于 Windows 和 Linux。</li><li><strong>etcd-browser</strong> - 一个基于 AngularJS 的 etcd 网页键值编辑器。</li><li><strong>etcd-lock</strong> - 使用 etcd 实现的主节点选举和分布式读&#x2F;写锁，支持 v2。</li><li><strong>etcd-console</strong> - 一个基于 PHP 的 etcd 网页键值编辑器。</li><li><strong>etcd-viewer</strong> - 用 Java 编写的 etcd 键值存储编辑&#x2F;查看器。</li><li><strong>etcdtool</strong> - 以 JSON&#x2F;YAML&#x2F;TOML 格式导出&#x2F;导入&#x2F;编辑 etcd 目录，并使用 JSON 模式验证目录。</li><li><strong>etcdloadtest</strong> - 一个用于 etcd 版本 3.0 及以上的命令行负载测试客户端。</li><li><strong>lucas</strong> - 一个用于 Kubernetes etcd3.0+ 集群的基于 Web 的键值查看器。</li><li><strong>etcd-manager</strong> - 一个现代、效率高、跨平台且免费的 etcd 3.x GUI 和客户端工具，适用于 Windows、Linux 和 Mac。</li><li><strong>etcd-backup-restore</strong> - 定期增量备份和恢复 etcd 的工具。</li><li><strong>etcd-druid</strong> - 用于部署 etcd 集群并管理日常运维操作的 Kubernetes 操作符。</li><li><strong>etcdadm</strong> - 用于操作 etcd 集群的命令行工具。</li><li><strong>etcd-defrag</strong> - 一个更易用且更智能的 etcd 碎片整理工具。</li><li><strong>etcdhelper</strong> - IntelliJ 平台的 etcd 插件。</li></ul><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>以下部分按语言列出了 etcd 客户端库。</p><h5 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h5><ul><li><strong>etcd&#x2F;client&#x2F;v3</strong> - 官方维护的 v3 Go 客户端。</li><li><strong>etcd&#x2F;client&#x2F;v2</strong> - 官方维护的 v2 Go 客户端。</li><li><strong>go-etcd</strong> - 已弃用的官方客户端，可能对旧版本（&lt;2.0.0）的 etcd 有用。</li><li><strong>encWrapper</strong> - etcd 客户端键 API&#x2F;KV 的加密包装器。</li></ul><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><ul><li><strong>coreos&#x2F;jetcd</strong> - 支持 v3。</li><li><strong>boonproject&#x2F;etcd</strong> - 支持 v2，异步&#x2F;同步和等待。</li><li><strong>justinsb&#x2F;jetcd</strong></li><li><strong>diwakergupta&#x2F;jetcd</strong> - 支持 v2。</li><li><strong>jurmous&#x2F;etcd4j</strong> - 支持 v2，异步&#x2F;同步、等待和 SSL。</li><li><strong>AdoHe&#x2F;etcd4j</strong> - 支持 v2（增强以适用于真实生产集群）。</li><li><strong>cdancy&#x2F;etcd-rest</strong> - 使用 jclouds 提供完整的 v2 API 实现。</li><li><strong>IBM&#x2F;etcd-java</strong></li></ul><h5 id="更多语言客户端库"><a href="#更多语言客户端库" class="headerlink" title="更多语言客户端库"></a>更多语言客户端库</h5><p>涉及 Scala、Perl、Python、Node.js、Ruby、C、C++、Clojure、Erlang、Elixir、.NET、PHP、Haskell、R、Nim、Tcl、Rust、Gradle、Lua 和部署工具等。</p><h3 id="使用-etcd-的项目"><a href="#使用-etcd-的项目" class="headerlink" title="使用 etcd 的项目"></a>使用 etcd 的项目</h3><ul><li><strong>etcd Raft users</strong> - 使用 etcd 的 Raft 库实现的项目。</li><li><strong>apache&#x2F;celix</strong> - 一种适用于 C 和 C++ 的 OSGi 规范实现。</li><li><strong>binocarlos&#x2F;yoda</strong> - etcd 加 ZeroMQ。</li><li><strong>blox&#x2F;blox</strong> - 为 AWS ECS 提供的开源容器管理和编排项目合集。</li><li><strong>calavera&#x2F;active-proxy</strong> - 使用 etcd 配置的 HTTP 代理。</li><li><strong>chain&#x2F;chain</strong> - 设计用于操作和连接高扩展性许可区块链网络的软件。</li><li>其他项目包括 Kubernetes、Vitess、Uber M3 和 Apache ArangoDB 等等。</li></ul><p>这些描述展示了 etcd 各种工具、库及其广泛应用，以满足不同的技术需求和项目需求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>etcd</tag>
      
      <tag>工具</tag>
      
      <tag>客户端库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcdctl命令整理</title>
    <link href="/2025/02/13/2025-02-13-etcdctl%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <url>/2025/02/13/2025-02-13-etcdctl%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><code>etcdctl</code> 是 <code>etcd</code> 的命令行客户端工具，用于与 <code>etcd</code> 集群进行交互。下面是 <code>etcdctl</code> 的一些常用选项和命令，帮助你进行数据存取和集群管理等操作。</p><h1 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h1><p>在执行任何 <code>etcdctl</code> 命令时，你通常需要指定以下选项来配置连接参数：</p><ul><li><code>--endpoints=[]</code>：指定 <code>etcd</code> 集群的一个或多个端点地址，通常是 <code>http://ip:port</code> 格式。</li><li><code>--cacert=&quot;&quot;</code>：指定根证书文件路径，用于 TLS 连接。</li><li><code>--cert=&quot;&quot;</code>：指定客户端证书文件路径，用于 TLS 连接。</li><li><code>--key=&quot;&quot;</code>：指定客户端私钥文件路径，用于 TLS 连接。</li><li><code>--user=&quot;&quot;</code>：指定用户名和密码，格式为 <code>username:password</code>，用于身份验证。</li><li><code>--dial-timeout=&quot;&quot;</code>：指定建立连接的超时时长。</li><li><code>--command-timeout=&quot;&quot;</code>：指定命令执行的超时时长。</li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="数据操作命令"><a href="#数据操作命令" class="headerlink" title="数据操作命令"></a>数据操作命令</h2><ul><li><p><code>put &lt;key&gt; &lt;value&gt;</code>：设置指定键的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl put mykey myvalue</span><br></pre></td></tr></table></figure></li><li><p><code>get &lt;key&gt;</code>：获取指定键的值，可以使用 <code>--prefix</code> 来获取具有相同前缀的键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">etcdctl get mykey</span><br><span class="line">etcdctl get my --prefix</span><br></pre></td></tr></table></figure></li><li><p><code>del &lt;key&gt;</code>：删除指定键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl del mykey</span><br></pre></td></tr></table></figure></li></ul><h2 id="集群操作命令"><a href="#集群操作命令" class="headerlink" title="集群操作命令"></a>集群操作命令</h2><ul><li><p><code>member list</code>：列出集群中所有成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl member list</span><br></pre></td></tr></table></figure></li><li><p><code>endpoint status</code>：获取指定端点的状态信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl endpoint status</span><br></pre></td></tr></table></figure></li><li><p><code>endpoint health</code>：检查集群中一个或多个端点的健康状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl endpoint health</span><br></pre></td></tr></table></figure></li></ul><h2 id="维护相关命令"><a href="#维护相关命令" class="headerlink" title="维护相关命令"></a>维护相关命令</h2><ul><li><p><code>snapshot save &lt;filename&gt;</code>：创建集群的快照备份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl snapshot save backup.db</span><br></pre></td></tr></table></figure></li><li><p><code>snapshot status &lt;filename&gt;</code>：查看快照状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl snapshot status backup.db</span><br></pre></td></tr></table></figure></li><li><p><code>defrag</code>：整理 <code>etcd</code> 数据库以释放空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl defrag</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul><li><code>version</code>：显示 <code>etcdctl</code> 工具和 <code>etcd</code> 服务器版本。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl version</span><br></pre></td></tr></table></figure></li></ul><p>这些命令和选项覆盖了 <code>etcdctl</code> 的大部分基本功能，但 <code>etcdctl</code> 是一个非常强大和灵活的工具，拥有更多的高级选项和命令。要获取更多详细信息，您可以使用该工具的帮助命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h1 id="扩展命令"><a href="#扩展命令" class="headerlink" title="扩展命令"></a>扩展命令</h1><h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><p><code>etcdctl txn</code> 是用于执行事务操作的一种功能，允许你在一个原子操作中执行多个条件（条件、操作）。这在需要多个操作保证一致性时非常有用。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>事务操作通过一个三元组的形式指定：<strong>比较 → 如果成立 → 如果不成立</strong>。可以串联多个条件，每个条件包含对应的操作分支。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这里是一个简单的示例，展示如何使用 <code>etcdctl txn</code> 命令进行事务操作：</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>假设有一个键 <code>foo</code>，我们希望：</p><ul><li>如果 <code>foo</code> 的值是 <code>bar</code>，则更新 <code>foo</code> 的值为 <code>baz</code>。</li><li>否则，设置一个键 <code>newkey</code>，其值为 <code>newvalue</code>。</li></ul><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">etcdctl txn &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">compares:</span></span><br><span class="line"><span class="string">  value(&quot;foo&quot;) = &quot;bar&quot;</span></span><br><span class="line"><span class="string">success:</span></span><br><span class="line"><span class="string">  put &quot;foo&quot; &quot;baz&quot;</span></span><br><span class="line"><span class="string">failure:</span></span><br><span class="line"><span class="string">  put &quot;newkey&quot; &quot;newvalue&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h3 id="操作解析"><a href="#操作解析" class="headerlink" title="操作解析"></a>操作解析</h3><ol><li><p><strong>比较条件</strong>：</p><ul><li><code>value(&quot;foo&quot;) = &quot;bar&quot;</code>：检查键 <code>foo</code> 当前的值是否为 <code>bar</code>。</li></ul></li><li><p><strong>成功操作</strong>：</p><ul><li>如果上述条件成立，则执行 <code>put &quot;foo&quot; &quot;baz&quot;</code>：将键 <code>foo</code> 的值设置为 <code>baz</code>。</li></ul></li><li><p><strong>失败操作</strong>：</p><ul><li>如果条件不成立，则执行 <code>put &quot;newkey&quot; &quot;newvalue&quot;</code>：将键 <code>newkey</code> 的值设置为 <code>newvalue</code>。</li></ul></li></ol><h3 id="更多比较类型"><a href="#更多比较类型" class="headerlink" title="更多比较类型"></a>更多比较类型</h3><p><code>etcdctl txn</code> 支持多种比较类型：</p><ul><li><code>value(&quot;key&quot;) &lt;op&gt; &quot;value&quot;</code>：比较给定键的值。</li><li><code>version(&quot;key&quot;) &lt;op&gt; &quot;version&quot;</code>：比较键的版本号。</li><li><code>createRevision(&quot;key&quot;) &lt;op&gt; &quot;revision&quot;</code>：比较键的创建修订。</li><li><code>modRevision(&quot;key&quot;) &lt;op&gt; &quot;revision&quot;</code>：比较键的修改修订。</li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符 <code>&lt;op&gt;</code> 可以为以下之一：</p><ul><li><code>=</code>：等于</li><li><code>!=</code>：不等于</li><li><code>&lt;</code>：小于</li><li><code>&lt;=</code>：小于等于</li><li><code>&gt;</code>：大于</li><li><code>&gt;=</code>：大于等于</li></ul><h3 id="结果判断"><a href="#结果判断" class="headerlink" title="结果判断"></a>结果判断</h3><p>事务执行后，<code>etcd</code> 将返回一个事务结果，其中包含哪些操作被成功执行的信息。使用返回的信息可以进一步决定应用程序逻辑。</p><p>通过事务操作，你可以确保在复杂条件下的多步骤状态变更的一致性，这在分布式系统中至关重要。使用 <code>etcdctl txn</code> 和其他 API 选项可以来实现更复杂的操作和控制流程。</p><p><code>etcdctl watch</code> 命令用于监视 <code>etcd</code> 中的键值变化。它可以实时监控键值的变化，并提供回调机制来处理变化事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> watch stock1</span><br></pre></td></tr></table></figure><p><code>etcdctl watch</code> 命令的常用选项：</p><ul><li><code>--endpoints</code>：指定 <code>etcd</code> 集群的端点地址。</li><li><code>--prefix</code>：监视具有相同前缀的键。</li><li><code>--recursive</code>：递归监视键值变化。</li></ul><h2 id="租约机制"><a href="#租约机制" class="headerlink" title="租约机制"></a>租约机制</h2><p>在 <code>etcd</code> 中，租约（Lease）是一种机制，用于管理键值的生存时间。通过使用租约，你可以为键值对设置一个TTL（生存时间），当租约到期时，绑定到该租约的键值对将自动删除。这在需要临时数据或心跳保持时非常有用。</p><h3 id="创建租约"><a href="#创建租约" class="headerlink" title="创建租约"></a>创建租约</h3><p>可以通过 <code>etcdctl lease grant</code> 命令来创建一个租约。以下是创建租约的步骤：</p><h4 id="步骤-1-创建租约"><a href="#步骤-1-创建租约" class="headerlink" title="步骤 1: 创建租约"></a>步骤 1: 创建租约</h4><p>使用 <code>lease grant</code> 命令创建一个租约，并指定其 TTL（以秒为单位）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lease grant &lt;ttl&gt;</span><br></pre></td></tr></table></figure><p>例如，要创建一个 10 秒的租约：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lease grant 10</span><br></pre></td></tr></table></figure><p>成功创建后，命令将返回租约 ID 和 TTL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lease 1234567890 granted with TTL(10s)</span><br></pre></td></tr></table></figure><h4 id="步骤-2-使用租约"><a href="#步骤-2-使用租约" class="headerlink" title="步骤 2: 使用租约"></a>步骤 2: 使用租约</h4><p>使用获得的租约 ID，你可以将其与一个或多个键值对绑定。这样做的操作是使用 <code>--lease</code> 选项来设置键：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl put mykey myvalue --lease=1234567890</span><br></pre></td></tr></table></figure><p>这意味着 <code>mykey</code> 的生存期受租约 <code>1234567890</code> 的控制。当租约到期时，<code>mykey</code> 将自动过期并被删除。</p><h3 id="查看租约"><a href="#查看租约" class="headerlink" title="查看租约"></a>查看租约</h3><p>可以使用 <code>etcdctl lease timetolive</code> 命令查看租约的剩余 TTL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lease timetolive 1234567890</span><br></pre></td></tr></table></figure><p>这将返回租约的剩余时间以及是否具有保持活性选项。</p><h3 id="刷新租约"><a href="#刷新租约" class="headerlink" title="刷新租约"></a>刷新租约</h3><p>如果想延长租约的生存时间，可以使用 <code>etcdctl lease keep-alive</code> 命令来刷新租约：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lease keep-alive 1234567890</span><br></pre></td></tr></table></figure><p>此命令将租约的 TTL 重新设置为其初始值。</p><h3 id="释放租约"><a href="#释放租约" class="headerlink" title="释放租约"></a>释放租约</h3><p>如果不再需要租约，可以使用 <code>etcdctl lease revoke</code> 命令来显式释放租约：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lease revoke 1234567890</span><br></pre></td></tr></table></figure><p>释放后，所有绑定到此租约的键将被立即删除。</p><p>利用租约机制，能够有效管理临时数据的生命期，并在分布式系统中实现心跳和故障检测等高级功能。请确保在生产环境中合理配置租约的 TTL 和续约策略，以确保数据和系统的稳定性。</p><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p><code>etcdctl lock</code> 命令用于在 <code>etcd</code> 中实现分布式锁。它允许你在多个节点之间协调对共享资源的访问，确保在分布式环境中只有一个节点能够访问和修改资源。</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>以下是 <code>etcdctl lock</code> 命令的基本用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lock &lt;key&gt;</span><br></pre></td></tr></table></figure><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p><code>etcdctl elect</code> 命令用于在 <code>etcd</code> 中实现分布式选举。它允许你在多个节点之间协调选举过程，确保在分布式环境中只有一个节点能够成为领导者。</p><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>以下是 <code>etcdctl elect</code> 命令的基本用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> elect &lt;election-name&gt; &lt;leader-name&gt;</span><br></pre></td></tr></table></figure><h1 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h1><h2 id="检查整体状态"><a href="#检查整体状态" class="headerlink" title="检查整体状态"></a>检查整体状态</h2><p>endpoint status 检查 –endpoints 标志中指定的每个端点的整体状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl endpoint status (--endpoints=<span class="variable">$ENDPOINTS</span>|--cluster)</span><br></pre></td></tr></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--cluster[=<span class="literal">false</span>]: use all endpoints from the cluster member list</span><br></pre></td></tr></table></figure><h2 id="检查健康"><a href="#检查健康" class="headerlink" title="检查健康"></a>检查健康</h2><p>endpoint health 检查 –endpoints 标记中指定的每个端点的健康状况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">etcdctl endpoint health (--endpoints=<span class="variable">$ENDPOINTS</span>|--cluster)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--cluster[=<span class="literal">false</span>]: use all endpoints from the cluster member list</span><br></pre></td></tr></table></figure><h2 id="检查KV-hash"><a href="#检查KV-hash" class="headerlink" title="检查KV hash"></a>检查KV hash</h2><p>endpoint hashkv 检查 –endpoints 标记中指定的每个端点的 KV 历史哈希值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl endpoint hashkv (--endpoints=<span class="variable">$ENDPOINTS</span>|--cluster) [rev=<span class="variable">$REV</span>]</span><br></pre></td></tr></table></figure><h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--cluster[=<span class="literal">false</span>]: use all endpoints from the cluster member list</span><br><span class="line">--rev=0: maximum revision to <span class="built_in">hash</span> (default: latest revision)</span><br></pre></td></tr></table></figure><h2 id="继承选项"><a href="#继承选项" class="headerlink" title="继承选项"></a>继承选项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--endpoints=<span class="string">&quot;127.0.0.1:2379&quot;</span>: gRPC endpoints</span><br><span class="line">-w, --write-out=<span class="string">&quot;simple&quot;</span>: <span class="built_in">set</span> the output format (fields, json, protobuf, simple, table)</span><br></pre></td></tr></table></figure><h2 id="快照机制"><a href="#快照机制" class="headerlink" title="快照机制"></a>快照机制</h2><p>snapshot save 创建集群的快照备份：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINT</span> snapshot save DB_NAME</span><br></pre></td></tr></table></figure><h3 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--endpoints=[127.0.0.1:2379], gRPC endpoints</span><br></pre></td></tr></table></figure><p>只能从一个 etcd 节点请求快照，因此 –endpoints 标志应只包含一个端点。</p><h2 id="API版本从v2切换到v3"><a href="#API版本从v2切换到v3" class="headerlink" title="API版本从v2切换到v3"></a>API版本从v2切换到v3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># write key in etcd version 2 store</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=2</span><br><span class="line">etcdctl --endpoints=http://<span class="variable">$ENDPOINT</span> <span class="built_in">set</span> foo bar</span><br><span class="line"></span><br><span class="line"><span class="comment"># read key in etcd v2</span></span><br><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> --output=<span class="string">&quot;json&quot;</span> get foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># stop etcd node to migrate, one by one</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># migrate v2 data</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINT</span> migrate --data-dir=<span class="string">&quot;default.etcd&quot;</span> --wal-dir=<span class="string">&quot;default.etcd/member/wal&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># restart etcd node after migrate, one by one</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># confirm that the key got migrated</span></span><br><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> get /foo</span><br></pre></td></tr></table></figure><h2 id="添加-删除etcd节点"><a href="#添加-删除etcd节点" class="headerlink" title="添加&#x2F;删除etcd节点"></a>添加&#x2F;删除etcd节点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For each machine</span></span><br><span class="line">TOKEN=my-etcd-token-1</span><br><span class="line">CLUSTER_STATE=new</span><br><span class="line">NAME_1=etcd-node-1</span><br><span class="line">NAME_2=etcd-node-2</span><br><span class="line">NAME_3=etcd-node-3</span><br><span class="line">HOST_1=10.240.0.13</span><br><span class="line">HOST_2=10.240.0.14</span><br><span class="line">HOST_3=10.240.0.15</span><br><span class="line">CLUSTER=<span class="variable">$&#123;NAME_1&#125;</span>=http://<span class="variable">$&#123;HOST_1&#125;</span>:2380,<span class="variable">$&#123;NAME_2&#125;</span>=http://<span class="variable">$&#123;HOST_2&#125;</span>:2380,<span class="variable">$&#123;NAME_3&#125;</span>=http://<span class="variable">$&#123;HOST_3&#125;</span>:2380</span><br><span class="line"></span><br><span class="line"><span class="comment"># For node 1</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_1&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_1&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> \</span><br><span class="line">--initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For node 2</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_2&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_2&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> \</span><br><span class="line">--initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For node 3</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_3&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_3&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> \</span><br><span class="line">--initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br></pre></td></tr></table></figure><p>然后用 member remove 和 member add 命令替换一个成员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get member ID</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">HOST_1=10.240.0.13</span><br><span class="line">HOST_2=10.240.0.14</span><br><span class="line">HOST_3=10.240.0.15</span><br><span class="line">etcdctl --endpoints=<span class="variable">$&#123;HOST_1&#125;</span>:2379,<span class="variable">$&#123;HOST_2&#125;</span>:2379,<span class="variable">$&#123;HOST_3&#125;</span>:2379 member list</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove the member</span></span><br><span class="line">MEMBER_ID=278c654c9a6dfd3b</span><br><span class="line">etcdctl --endpoints=<span class="variable">$&#123;HOST_1&#125;</span>:2379,<span class="variable">$&#123;HOST_2&#125;</span>:2379,<span class="variable">$&#123;HOST_3&#125;</span>:2379 \</span><br><span class="line">member remove <span class="variable">$&#123;MEMBER_ID&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add a new member (node 4)</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">NAME_1=etcd-node-1</span><br><span class="line">NAME_2=etcd-node-2</span><br><span class="line">NAME_4=etcd-node-4</span><br><span class="line">HOST_1=10.240.0.13</span><br><span class="line">HOST_2=10.240.0.14</span><br><span class="line">HOST_4=10.240.0.16 <span class="comment"># new member</span></span><br><span class="line">etcdctl --endpoints=<span class="variable">$&#123;HOST_1&#125;</span>:2379,<span class="variable">$&#123;HOST_2&#125;</span>:2379 \</span><br><span class="line">member add <span class="variable">$&#123;NAME_4&#125;</span> \</span><br><span class="line">--peer-urls=http://<span class="variable">$&#123;HOST_4&#125;</span>:2380</span><br></pre></td></tr></table></figure><p>接下来，使用 –initial-cluster-state existing 标志启动新成员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [WARNING] If the new member starts from the same disk space,</span></span><br><span class="line"><span class="comment"># make sure to remove the data directory of the old member</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># restart with &#x27;existing&#x27; flag</span></span><br><span class="line">TOKEN=my-etcd-token-1</span><br><span class="line">CLUSTER_STATE=existing</span><br><span class="line">NAME_1=etcd-node-1</span><br><span class="line">NAME_2=etcd-node-2</span><br><span class="line">NAME_4=etcd-node-4</span><br><span class="line">HOST_1=10.240.0.13</span><br><span class="line">HOST_2=10.240.0.14</span><br><span class="line">HOST_4=10.240.0.16 <span class="comment"># new member</span></span><br><span class="line">CLUSTER=<span class="variable">$&#123;NAME_1&#125;</span>=http://<span class="variable">$&#123;HOST_1&#125;</span>:2380,<span class="variable">$&#123;NAME_2&#125;</span>=http://<span class="variable">$&#123;HOST_2&#125;</span>:2380,<span class="variable">$&#123;NAME_4&#125;</span>=http://<span class="variable">$&#123;HOST_4&#125;</span>:2380</span><br><span class="line"></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_4&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_4&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> \</span><br><span class="line">--initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golanghttp库解析</title>
    <link href="/2025/02/13/2025-02-13-golanghttp%E5%BA%93%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/02/13/2025-02-13-golanghttp%E5%BA%93%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="1-整体框架"><a href="#1-整体框架" class="headerlink" title="1 整体框架"></a>1 整体框架</h1><h2 id="1-1-C-S架构"><a href="#1-1-C-S架构" class="headerlink" title="1.1 C-S架构"></a>1.1 C-S架构</h2><p>http 协议下，交互框架是由客户端（Client）和服务端（Server）两个模块组成的 C-S 架构，两个部分正好对应为本文研究的两条主线.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Client] --&gt;|HTTP Request| B[http.Client]</span><br><span class="line">    B --&gt;|Send Request| C[Transport]</span><br><span class="line">    C --&gt;|Dial| D[Network]</span><br><span class="line">    D --&gt;|Send to Server| E[Server]</span><br><span class="line">    E --&gt;|Handle Request| F[http.ServeMux]</span><br><span class="line">    F --&gt;|Call Handler| G[Handler Function]</span><br><span class="line">    G --&gt;|Generate Response| H[Response]</span><br><span class="line">    H --&gt;|Send Response| E</span><br><span class="line">    E --&gt;|Return Response| D</span><br><span class="line">    D --&gt;|Return to Client| C</span><br><span class="line">    C --&gt;|Return Response| B</span><br><span class="line">    B --&gt;|Receive Response| A</span><br><span class="line"></span><br><span class="line">    subgraph Server Flow</span><br><span class="line">        E --&gt;|Listen for Request| D</span><br><span class="line">        D --&gt;|Handle Incoming Connections| E</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph Client Flow</span><br><span class="line">        A --&gt;|Create Request| B</span><br><span class="line">        B --&gt;|Set Headers/Params| B</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h2 id="1-2-启动-http-服务"><a href="#1-2-启动-http-服务" class="headerlink" title="1.2 启动 http 服务"></a>1.2 启动 http 服务</h2><p>在 Golang 启动一个 http 服务只需寥寥数笔，非常方便，代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;pong&quot;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8091&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，完成了两件事：</p><ul><li> 调用 http.HandleFunc 方法，注册了对应于请求路径 &#x2F;ping 的 handler 函数</li><li> 调用 http.ListenAndServe，启动了一个端口为 8091 的 http 服务</li></ul><p>如此简洁轻便即实现了一个 http server 的启动，其背后究竟隐藏了哪些实施细节呢. 这个问题，就让我们在第 2 章的内容中，和大家一同展开探讨.</p><h2 id="1-3-发送-http-请求"><a href="#1-3-发送-http-请求" class="headerlink" title="1.3 发送 http 请求"></a>1.3 发送 http 请求</h2><p>在 Golang 中发送 http 请求的实现同样非常简单. 下面给出一例发送 JSON POST 请求的代码示例.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    reqBody, _ := json.Marshal(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;key1&quot;</span>: <span class="string">&quot;val1&quot;</span>, <span class="string">&quot;key2&quot;</span>: <span class="string">&quot;val2&quot;</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    resp, _ := http.Post(<span class="string">&quot;:8091&quot;</span>, <span class="string">&quot;application/json&quot;</span>, bytes.NewReader(reqBody))</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    </span><br><span class="line">    respBody, _ := io.ReadAll(resp.Body)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;resp: %s&quot;</span>, respBody)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分将作为本文的第二条线索，放在第 3 章中展开讨论.</p><h2 id="1-4-源码位置一览"><a href="#1-4-源码位置一览" class="headerlink" title="1.4 源码位置一览"></a>1.4 源码位置一览</h2><p>本文涉及内容的源码均位于 net&#x2F;http 库下，各模块的文件位置如下表所示：</p><table><thead><tr><th><strong>模块</strong></th><th><strong>文件</strong></th></tr></thead><tbody><tr><td>服务端</td><td>net&#x2F;http&#x2F;server.go</td></tr><tr><td>客户端——主流程</td><td>net&#x2F;http&#x2F;client.go</td></tr><tr><td>客户端——构造请求</td><td>net&#x2F;http&#x2F;request.go</td></tr><tr><td>客户端——网络交互</td><td>net&#x2F;http&#x2F;transport.go</td></tr></tbody></table><h1 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2 服务端"></a>2 服务端</h1><h2 id="2-1-核心数据结构"><a href="#2-1-核心数据结构" class="headerlink" title="2.1 核心数据结构"></a>2.1 核心数据结构</h2><p>首先对 http 服务端模块涉及的核心数据结构作简要介绍.</p><p>（1）Server</p><p>基于面向对象的思想，整个 http 服务端模块被封装在 Server 类当中.</p><p>Handler 是 Server 中最核心的成员字段，实现了从请求路径 path 到具体处理函数 handler 的注册和映射能力.</p><p>在用户构造 Server 对象时，倘若其中的 Handler 字段未显式声明，则会取 net&#x2F;http 包下的单例对象 DefaultServeMux（ServerMux 类型） 进行兜底.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// server 的地址</span></span><br><span class="line">    Addr <span class="type">string</span></span><br><span class="line">    <span class="comment">// 路由处理器.</span></span><br><span class="line">    Handler Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）Handler</p><p>Handler 是一个 interface，定义了方法： ServeHTTP.</p><p>该方法的作用是，根据 http 请求 Request 中的请求路径 path 映射到对应的 handler 处理函数，对请求进行处理和响应.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;    </span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）ServeMux</p><p>ServeMux 是对 Handler 的具体实现，内部通过一个 map 维护了从 path 到 handler 的映射关系.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]muxEntry</span><br><span class="line">    es []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">    hosts <span class="type">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）muxEntry</p><p>muxEntry 为一个 handler 单元，内部包含了请求路径 path + 处理函数 handler 两部分.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    h Handler</span><br><span class="line">    pattern <span class="type">string</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-注册-handler"><a href="#2-2-注册-handler" class="headerlink" title="2.2 注册 handler"></a>2.2 注册 handler</h2><p>首先给出服务端注册 handler 的主干链路，避免晕车.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Server] --&gt;|Create Mux| B[http.ServeMux]</span><br><span class="line">    B --&gt;|Register Route| C[HandleFunc]</span><br><span class="line">    C --&gt;|Set Handler| D[http.Handler]</span><br><span class="line">    D --&gt;|Invoke| E[Handler Function]</span><br><span class="line">    E --&gt;|Generate Response| F[Response]</span><br><span class="line">    F --&gt;|Return to Mux| B</span><br><span class="line">    B --&gt;|Send Response| G[Client]</span><br><span class="line">    </span><br><span class="line">    subgraph Handler Registration</span><br><span class="line">        A --&gt;|Listen on Port| H[http.ListenAndServe]</span><br><span class="line">        H --&gt;|Attach Mux| B</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>在 net&#x2F;http 包下声明了一个单例 ServeMux，当用户直接通过公开方法 http.HandleFunc 注册 handler 时，则会将其注册到 DefaultServeMux 当中.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123; </span><br><span class="line"></span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ServeMux.HandleFunc 内部会将处理函数 handler 转为实现了 ServeHTTP 方法的 HandlerFunc 类型，将其作为 Handler interface 的实现类注册到 ServeMux 的路由 map 当中.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).  实现Handler的interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> HandleFunc(pattern <span class="type">string</span>, handler <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现路由注册的核心逻辑位于 ServeMux.Handle 方法中，两个核心逻辑值得一提：</p><ul><li><p>将 path 和 handler 包装成一个 muxEntry，以 path 为 key 注册到路由 map ServeMux.m 中</p></li><li><p>响应模糊匹配机制. 对于以 ‘&#x2F;‘ 结尾的 path，根据 path 长度将 muxEntry 有序插入到数组 ServeMux.es 中.（模糊匹配机制的伏笔在 2.3 小节回收）</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> Handle(pattern <span class="type">string</span>, handler Handler) &#123;</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">    mux.m[pattern] = e</span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">        mux.es = appendSorted(mux.es, e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSorted</span><span class="params">(es []muxEntry, e muxEntry)</span></span> []muxEntry &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(es)</span><br><span class="line">    i := sort.Search(n, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(es[i].pattern) &lt; <span class="built_in">len</span>(e.pattern)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> i == n &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">append</span>(es, e)</span><br><span class="line">    &#125;</span><br><span class="line">    es = <span class="built_in">append</span>(es, muxEntry&#123;&#125;) <span class="comment">// try to grow the slice in place, any entry works.</span></span><br><span class="line">    <span class="built_in">copy</span>(es[i+<span class="number">1</span>:], es[i:])      <span class="comment">// Move shorter entries down</span></span><br><span class="line">    es[i] = e</span><br><span class="line">    <span class="keyword">return</span> es</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-启动-server"><a href="#2-3-启动-server" class="headerlink" title="2.3 启动 server"></a>2.3 启动 server</h2><p>调用 net&#x2F;http 包下的公开方法 ListenAndServe，可以实现对服务端的一键启动. 内部会声明一个新的 Server 对象，嵌套执行 Server.ListenAndServe 方法.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server.ListenAndServe 方法中，根据用户传入的端口，申请到一个监听器 listener，继而调用 Server.Serve 方法.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> ListenAndServe() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    addr := srv.Addr</span><br><span class="line">    <span class="keyword">if</span> addr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        addr = <span class="string">&quot;:http&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ln, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="keyword">return</span> srv.Serve(ln)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Server.Serve开始] --&gt;|创建Context| B[添加Server到Context]</span><br><span class="line">    B --&gt; C[进入For循环]</span><br><span class="line">    C --&gt;|阻塞等待| D[Listener.Accept]</span><br><span class="line">    D --&gt;|新连接到达| E[创建新的conn]</span><br><span class="line">    E --&gt;|异步处理| F[启动goroutine]</span><br><span class="line">    F --&gt; G[执行conn.serve]</span><br><span class="line">    G --&gt; H[处理请求]</span><br><span class="line">    H --&gt; I[返回响应]</span><br><span class="line">    I --&gt; J[关闭连接]</span><br><span class="line">    </span><br><span class="line">    C --&gt;|继续循环| D</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;每个连接的处理流程&quot;</span><br><span class="line">        F</span><br><span class="line">        G</span><br><span class="line">        H </span><br><span class="line">        I</span><br><span class="line">        J</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;主循环&quot;</span><br><span class="line">        C</span><br><span class="line">        D</span><br><span class="line">        E</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>Server.Serve 方法很核心，体现了 http 服务端的运行架构：for + listener.accept 模式.</p><ul><li>将 server 封装成一组 kv 对，添加到 context 当中</li><li>开启 for 循环，每轮循环调用 Listener.Accept 方法阻塞等待新连接到达</li><li>每有一个连接到达，创建一个 goroutine 异步执行 conn.serve 方法负责处理</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ServerContextKey = &amp;contextKey&#123;<span class="string">&quot;http-server&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> contextKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, err := l.Accept()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        connCtx := ctx</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(connCtx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>conn.serve 是响应客户端连接的核心方法：</p><ul><li>从 conn 中读取到封装到 response 结构体，以及请求参数 http.Request</li><li>调用 serveHandler.ServeHTTP 方法，根据请求的 path 为其分配 handler</li><li>通过特定 handler 处理并响应请求</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> serve(ctx context.Context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    c.r = &amp;connReader&#123;conn: c&#125;</span><br><span class="line">    c.bufr = newBufioReader(c.r)</span><br><span class="line">    c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        w, err := c.readRequest(ctx)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">        w.cancelCtx()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 serveHandler.ServeHTTP 方法中，会对 Handler 作判断，倘若其未声明，则取全局单例 DefaultServeMux 进行路由匹配，呼应了 http.HandleFunc 中的处理细节.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span></span> ServeHTTP(rw ResponseWriter, req *Request) &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![[..&#x2F;pictures&#x2F;servehttp.png]]</p><p>接下来，兜兜转转依次调用 ServeMux.ServeHTTP、ServeMux.Handler、ServeMux.handler 等方法，最终在 ServeMux.match 方法中，以 Request 中的 path 为 pattern，在路由字典 Server.m 中匹配 handler，最后调用 handler.ServeHTTP 方法进行请求的处理和响应.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> Handler(r *Request) (h Handler, pattern <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> handler(host, path <span class="type">string</span>) (h Handler, pattern <span class="type">string</span>) &#123;</span><br><span class="line">    mux.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    h, pattern = mux.match(path)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，当通过路由字典 Server.m 未命中 handler 时，此时会启动模糊匹配模式，两个核心规则如下：</p><ul><li>以 ‘&#x2F;‘ 结尾的 pattern 才能被添加到 Server.es 数组中，才有资格参与模糊匹配</li><li>模糊匹配时，会找到一个与请求路径 path 前缀完全匹配且长度最长的 pattern，其对应的handler 会作为本次请求的处理函数.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> match(path <span class="type">string</span>) (h Handler, pattern <span class="type">string</span>) &#123;</span><br><span class="line">    v, ok := mux.m[path]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServeMux.es 本身是按照 pattern 的长度由大到小排列的</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> mux.es &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.HasPrefix(path, e.pattern) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.h, e.pattern</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，2.2 小节中模糊匹配问题的伏笔回收.</p><h1 id="3-客户端"><a href="#3-客户端" class="headerlink" title="3 客户端"></a>3 客户端</h1><h2 id="3-1-核心数据结构"><a href="#3-1-核心数据结构" class="headerlink" title="3.1 核心数据结构"></a>3.1 核心数据结构</h2><p>（1）Client</p><p>与 Server 对仗，客户端模块也有一个 Client 类，实现对整个模块的封装：</p><ul><li>Transport：负责 http 通信的核心部分，也是接下来的讨论重点</li><li>Jar：cookie 管理</li><li>Timeout：超时设置</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Transport RoundTripper</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Jar CookieJar</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）RoundTripper</p><p>RoundTripper 是通信模块的 interface，需要实现方法 Roundtrip，即通过传入请求 Request，与服务端交互后获得响应 Response.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> &#123;    </span><br><span class="line">RoundTrip(*Request) (*Response, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）Transport</p><p>Tranport 是 RoundTripper 的实现类，核心字段包括：</p><ul><li>idleConn：空闲连接 map，实现复用</li><li>DialContext：新连接生成器</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> &#123;</span><br><span class="line">    idleConn     <span class="keyword">map</span>[connectMethodKey][]*persistConn <span class="comment">// most recently used at end</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    DialContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）Request</p><p>http 请求参数结构体.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    Method <span class="type">string</span></span><br><span class="line">    <span class="comment">// 请求路径</span></span><br><span class="line">    URL *url.URL</span><br><span class="line">    <span class="comment">// 请求头</span></span><br><span class="line">    Header Header</span><br><span class="line">    <span class="comment">// 请求参数内容</span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line">    <span class="comment">// 服务器主机</span></span><br><span class="line">    Host <span class="type">string</span></span><br><span class="line">    <span class="comment">// query 请求参数</span></span><br><span class="line">    Form url.Values</span><br><span class="line">    <span class="comment">// 响应参数 struct</span></span><br><span class="line">    Response *Response</span><br><span class="line">    <span class="comment">// 请求链路的上下文</span></span><br><span class="line">    ctx context.Context</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）Response</p><p>http 响应参数结构体.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 请求状态，200 为 请求成功</span></span><br><span class="line">    StatusCode <span class="type">int</span>    <span class="comment">// e.g. 200</span></span><br><span class="line">    <span class="comment">// http 协议，如：HTTP/1.0</span></span><br><span class="line">    Proto      <span class="type">string</span> <span class="comment">// e.g. &quot;HTTP/1.0&quot;</span></span><br><span class="line">    <span class="comment">// 请求头</span></span><br><span class="line">    Header Header</span><br><span class="line">    <span class="comment">// 响应参数内容  </span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line">    <span class="comment">// 指向请求参数</span></span><br><span class="line">    Request *Request</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-方法链路总览"><a href="#3-2-方法链路总览" class="headerlink" title="3.2 方法链路总览"></a>3.2 方法链路总览</h2><p>客户端发起一次 http 请求大致分为几个步骤：</p><ul><li>• 构造 http 请求参数</li><li>• 获取用于与服务端交互的 tcp 连接</li><li>• 通过 tcp 连接发送请求参数</li><li>• 通过 tcp 连接接收响应结果</li></ul><p>整体方法链路如下图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[客户端代码] --&gt;|NewRequest| B[http.NewRequest]</span><br><span class="line">    B --&gt;|Do| C[http.Client]</span><br><span class="line">    C --&gt;|Transport.RoundTrip| D[http.Transport]</span><br><span class="line">    D --&gt;|Dial| E[net.Dial]</span><br><span class="line">    E --&gt;|Establish TCP Connection| F[TCP 连接]</span><br><span class="line">    F --&gt;|Write| G[TCP Conn.Write]</span><br><span class="line">    G --&gt;|Send HTTP Request| H[HTTP 服务器]</span><br><span class="line">    H --&gt;|Process Request| I[HTTP 响应]</span><br><span class="line">    I --&gt;|Read| J[TCP Conn.Read]</span><br><span class="line">    J --&gt;|Return Response| D</span><br><span class="line">    D --&gt;|Return Response| C</span><br><span class="line">    C --&gt;|Handle Response| A</span><br><span class="line"></span><br><span class="line">    subgraph 客户端</span><br><span class="line">        A --&gt; B</span><br><span class="line">        B --&gt; C</span><br><span class="line">        C --&gt; D</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 网络层</span><br><span class="line">        D --&gt; E</span><br><span class="line">        E --&gt; F</span><br><span class="line">        F --&gt; G</span><br><span class="line">        G --&gt; J</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 服务器</span><br><span class="line">        H --&gt; I</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 客户端</span><br><span class="line">        D --&gt; C</span><br><span class="line">        C --&gt; A</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h2 id="3-3-Client-Post"><a href="#3-3-Client-Post" class="headerlink" title="3.3 Client.Post"></a>3.3 Client.Post</h2><p>调用 net&#x2F;http 包下的公开方法 Post 时，需要传入服务端地址 url，请求参数格式 contentType 以及请求参数的 io reader.</p><p>方法中会使用包下的单例客户端 DefaultClient 处理这次请求.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultClient = &amp;Client&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Post</span><span class="params">(url, contentType <span class="type">string</span>, body io.Reader)</span></span> (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultClient.Post(url, contentType, body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Client.Post 方法中，首先会结合用户的入参，构造出完整的请求参数 Request；继而通过 Client.Do 方法，处理这笔请求.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Post(url, contentType <span class="type">string</span>, body io.Reader) (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">    req, err := NewRequest(<span class="string">&quot;POST&quot;</span>, url, body)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, contentType)</span><br><span class="line">    <span class="keyword">return</span> c.Do(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-NewRequest"><a href="#3-4-NewRequest" class="headerlink" title="3.4 NewRequest"></a>3.4 NewRequest</h2><p>NewRequestWithContext 方法中，根据用户传入的 url、method等信息，构造了 Request 实例.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequestWithContext</span><span class="params">(ctx context.Context, method, url <span class="type">string</span>, body io.Reader)</span></span> (*Request, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    u, err := urlpkg.Parse(url)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    rc, ok := body.(io.ReadCloser)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    req := &amp;Request&#123;</span><br><span class="line">        ctx:        ctx,</span><br><span class="line">        Method:     method,</span><br><span class="line">        URL:        u,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Header:     <span class="built_in">make</span>(Header),</span><br><span class="line">        Body:       rc,</span><br><span class="line">        Host:       u.Host,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-Client-Do"><a href="#3-5-Client-Do" class="headerlink" title="3.5 Client.Do"></a>3.5 Client.Do</h2><p>发送请求方法时，经由 Client.Do、Client.do 辗转，继而步入到 Client.send 方法中.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Do(req *Request) (*Response, <span class="type">error</span>) &#123;     </span><br><span class="line"><span class="keyword">return</span> c.do(req) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> do(req *Request) (retres *Response, reterr <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        deadline      = c.deadline()</span><br><span class="line">        resp          *Response</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    )    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">var</span> err <span class="type">error</span>       </span><br><span class="line">        <span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Client.send 方法中，会在通过 send 方法发送请求之前和之后，分别对 cookie 进行更新.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> send(req *Request, deadline time.Time) (resp *Response, didTimeout <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置 cookie 到请求头中</span></span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">            req.AddCookie(cookie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 resp 的 cookie 到请求头中</span></span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 send 方法时，需要注入 RoundTripper 模块，默认会使用全局单例 DefaultTransport 进行注入，核心逻辑位于 Transport.RoundTrip 方法中，其中分为两个步骤：</p><ul><li>• 获取&#x2F;构造 tcp 连接</li><li>• 通过 tcp 连接完成与服务端的交互</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    DialContext: defaultTransportDialContext(&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">        KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> transport() RoundTripper &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Transport</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span> (resp *Response, didTimeout <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    resp, err = rt.RoundTrip(req)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> RoundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;    </span><br><span class="line"><span class="keyword">return</span> t.roundTrip(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> roundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> &#123;          </span><br><span class="line">        <span class="comment">// ...    </span></span><br><span class="line">        treq := &amp;transportRequest&#123;Request: req, trace: trace, cancelKey: cancelKey&#125;      </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pconn, err := t.getConn(treq, cm)        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        resp, err = pconn.roundTrip(treq)          </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-Transport-getConn"><a href="#3-6-Transport-getConn" class="headerlink" title="3.6 Transport.getConn"></a>3.6 Transport.getConn</h2><p>获取 tcp 连接的策略分为两步：</p><ul><li>• 通过 queueForIdleConn 方法，尝试复用采用相同协议、访问相同服务端的空闲连接</li><li>• 倘若无可用连接，则通过 queueForDial 方法，异步创建一个新的连接，并通过接收 ready channel 信号的方式，确认构造连接的工作已经完成.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取连接的请求参数体</span></span><br><span class="line">    w := &amp;wantConn&#123;</span><br><span class="line">        cm:         cm,</span><br><span class="line">        <span class="comment">// key 由 http 协议、服务端地址等信息组成</span></span><br><span class="line">        key:        cm.key(),</span><br><span class="line">        ctx:        ctx,</span><br><span class="line">        <span class="comment">// 标识连接构造成功的信号发射器</span></span><br><span class="line">        ready:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倘若连接获取失败，在 wantConn.cancel 方法中，会尝试将 tcp 连接放回队列中以供后续复用</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            w.cancel(t, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 尝试复用指向相同服务端地址的空闲连接</span></span><br><span class="line">    <span class="keyword">if</span> delivered := t.queueForIdleConn(w); delivered &#123;</span><br><span class="line">        pc := w.pc</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步构造新的连接</span></span><br><span class="line">    t.queueForDial(w)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 通过阻塞等待信号的方式，等待连接获取完成</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-w.ready:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> w.pc, w.err</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）复用连接</p><ul><li>• 尝试从 Transport.idleConn 中获取指向同一服务端的空闲连接 persisConn</li><li>• 获取到连接后会调用 wantConn.tryDeliver 方法将连接绑定到 wantConn 请求参数上</li><li>• 绑定成功后，会关闭 wantConn.ready channel，以唤醒阻塞读取该 channel 的 goroutine</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> queueForIdleConn(w *wantConn) (delivered <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> list, ok := t.idleConn[w.key]; ok &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(list) &gt; <span class="number">0</span> &amp;&amp; !stop &#123;</span><br><span class="line">            pconn := list[<span class="built_in">len</span>(list)<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            delivered = w.tryDeliver(pconn, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> delivered &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                list = list[:<span class="built_in">len</span>(list)<span class="number">-1</span>]               </span><br><span class="line">            &#125;</span><br><span class="line">            stop = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> stop &#123;</span><br><span class="line">            <span class="keyword">return</span> delivered</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wantConn)</span></span> tryDeliver(pc *persistConn, err <span class="type">error</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    w.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> w.mu.Unlock()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    w.pc = pc</span><br><span class="line">    w.err = err</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">close</span>(w.ready)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建连接</p><p>在 queueForDial 方法会异步调用 Transport.dialConnFor 方法，创建新的 tcp 连接. 由于是异步操作，所以在上游会通过读 channel 的方式，等待创建操作完成.</p><p>这里之所以采用异步操作进行连接创建，有两部分原因：</p><ul><li>• 一个 tcp 连接并不是一个静态的数据结构，它是有生命周期的，创建过程中会为其创建负责读写的两个守护协程，伴随而生</li><li>• 在上游 Transport.queueForIdleConn 方法中，当通过 select 多路复用的方式，接收到其他终止信号时，可以提前调用 wantConn.cancel 方法打断创建连接的 goroutine. 相比于串行化执行而言，这种异步交互的模式，具有更高的灵活度</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> queueForDial(w *wantConn) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">go</span> t.dialConnFor(w) </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transport.dialConnFor 方法中，首先调用 Transport.dialConn 创建 tcp 连接 persisConn，接着执行 wantConn.tryDeliver 方法，将连接绑定到 wantConn 上，然后通过关闭 ready channel 操作唤醒上游读 ready channel 的 goroutine.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dialConnFor(w *wantConn) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pc, err := t.dialConn(w.ctx, w.cm)</span><br><span class="line">    delivered := w.tryDeliver(pc, err)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transport.dialConn 方法包含了创建连接的核心逻辑：</p><ul><li>• 调用 Transport.dial 方法，最终通过 Tranport.DialContext 成员函数，创建好 tcp 连接，封装到 persistConn 当中</li><li>• 异步启动连接的伴生读写协程 readLoop 和 writeLoop 方法，组成提交请求、接收响应的循环</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">    pconn = &amp;persistConn&#123;</span><br><span class="line">        t:             t,</span><br><span class="line">        reqch:         <span class="built_in">make</span>(<span class="keyword">chan</span> requestAndChan, <span class="number">1</span>),</span><br><span class="line">        writech:       <span class="built_in">make</span>(<span class="keyword">chan</span> writeRequest, <span class="number">1</span>),</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conn, err := t.dial(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pconn.conn = conn      </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">    <span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">    <span class="keyword">return</span> pconn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dial(ctx context.Context, network, addr <span class="type">string</span>) (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> t.DialContext(ctx, network, addr)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在伴生读协程 persisConn.readLoop 方法中，会读取来自服务端的响应，并添加到 persistConn.reqCh 中，供上游 persistConn.roundTrip 方法接收.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> readLoop() &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    alive := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> alive &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        rc := &lt;-pc.reqch</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">var</span> resp *Response</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        resp, err = pc.readResponse(rc, trace)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">select</span>&#123;</span><br><span class="line">            rc.ch &lt;- responseAndError&#123;res: resp&#125;:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...        </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>    </p><p>（3）归还连接</p><p>有复用连接的能力，就必然存在归还连接的机制.</p><p>首先，在构造新连接中途，倘若被打断，则可能会将连接放回队列以供复用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 倘若连接获取失败，在 wantConn.cancel 方法中，会尝试将 tcp 连接放回队列中以供后续复用</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            w.cancel(t, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wantConn)</span></span> cancel(t *Transport, err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> pc != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.putOrCloseIdleConn(pc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> tryPutIdleConn(pconn *persistConn) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    key := pconn.cacheKey</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    t.idleConn[key] = <span class="built_in">append</span>(idles, pconn)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，倘若与服务端的一轮交互流程结束，也会将连接放回队列以供复用.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> readLoop() &#123;</span><br><span class="line">    tryPutIdleConn := <span class="function"><span class="keyword">func</span><span class="params">(trace *httptrace.ClientTrace)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := pc.t.tryPutIdleConn(pc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    alive := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> alive &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> bodyEOF := &lt;-waitForBodyRead:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            tryPutIdleConn(trace)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> putOrCloseIdleConn(pconn *persistConn) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := t.tryPutIdleConn(pconn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        pconn.<span class="built_in">close</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-persistConn-roundTrip"><a href="#3-7-persistConn-roundTrip" class="headerlink" title="3.7 persistConn.roundTrip"></a>3.7 persistConn.roundTrip</h2><p>3.6 小节中谈到，一个连接 persistConn 是一个具有生命特征的角色. 它本身伴有 readLoop 和 writeLoop 两个守护协程，与上游应用者之间通过 channel 进行读写交互.</p><p>而其中扮演应用者这一角色的，正式本小节谈到的主流程中的方法：persistConn.roundTrip：</p><ul><li>• 首先将 http 请求通过 persistConn.writech 发送给连接的守护协程 writeLoop，并进一步传送到服务端</li><li>• 其次通过读取 resc channel，接收由守护协程 readLoop 代理转发的客户端响应数据.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> roundTrip(req *transportRequest) (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pc.writech &lt;- writeRequest&#123;req, writeErrCh, continueCh&#125;</span><br><span class="line">    resc := <span class="built_in">make</span>(<span class="keyword">chan</span> responseAndError)</span><br><span class="line">    pc.reqch &lt;- requestAndChan&#123;</span><br><span class="line">        req:        req.Request,</span><br><span class="line">        cancelKey:  req.cancelKey,</span><br><span class="line">        ch:         resc,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> &#123;    </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> re := &lt;-resc:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> re.res, <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>graph TD<br>    A[Server.Serve开始] –&gt;|创建Context| B[添加Server到Context]<br>    B –&gt; C[进入For循环]<br>    C –&gt;|阻塞等待| D[Listener.Accept]<br>    D –&gt;|新连接到达| E[创建新的conn]<br>    E –&gt;|异步处理| F[启动goroutine]<br>    F –&gt; G[执行conn.serve]<br>    G –&gt; H[处理请求]<br>    H –&gt; I[返回响应]<br>    I –&gt; J[关闭连接]</p><pre><code>C --&gt;|继续循环| Dsubgraph &quot;每个连接的处理流程&quot;    F    G    H     I    Jendsubgraph &quot;主循环&quot;    C    D    Eend</code></pre>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day04</title>
    <link href="/2025/02/13/2025-02-13-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day04/"/>
    <url>/2025/02/13/2025-02-13-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day04/</url>
    
    <content type="html"><![CDATA[<h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个长度为3元素类型为int的数组a</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><h2 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> b [<span class="number">4</span>]<span class="type">int</span></span><br><span class="line">a = b <span class="comment">//不可以这样做，因为此时a和b是不同的类型</span></span><br></pre></td></tr></table></figure><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化也有很多方式。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span>                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"><span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                 <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"><span class="keyword">var</span> cityArray = [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">fmt.Println(testArray)                      <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                       <span class="comment">//[1 2 0]</span></span><br><span class="line">fmt.Println(cityArray)                      <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> numArray = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray = [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">fmt.Println(testArray)                          <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                           <span class="comment">//[1 2]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of numArray:%T\n&quot;</span>, numArray)   <span class="comment">//type of numArray:[2]int</span></span><br><span class="line">fmt.Println(cityArray)                          <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of cityArray:%T\n&quot;</span>, cityArray) <span class="comment">//type of cityArray:[3]string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [...]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(a)                  <span class="comment">// [0 1 0 5]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:[4]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>遍历数组a有以下两种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 方法1：for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：for range遍历</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v1 := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\t&quot;</span>, v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">北京上海</span><br><span class="line">广州深圳</span><br><span class="line">成都重庆</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h2><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(x [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray2</span><span class="params">(x [3][2]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">modifyArray(a) <span class="comment">//在modify中修改的是a的副本x</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[10 20 30]</span></span><br><span class="line">b := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">int</span>&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">modifyArray2(b) <span class="comment">//在modify中修改的是b的副本x</span></span><br><span class="line">fmt.Println(b)  <span class="comment">//[[1 1] [1 1] [1 1]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>数组支持 “&#x3D;&#x3D;”、”!&#x3D;” 操作符，因为内存总是被初始化过的。</li><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>求数组<code>[1, 3, 5, 7, 8]</code>所有元素的和</li><li>找出数组中和为指定值的两个元素的下标，比如从数组<code>[1, 3, 5, 7, 8]</code>中找出和为8的两个元素的下标分别为<code>(0,3)</code>和<code>(1,2)</code>。</li></ol><p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySum</span><span class="params">(x [3]<span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x&#123;</span><br><span class="line">        sum = sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p><h2 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h2><p>声明切片类型的基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明切片类型</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="type">string</span>              <span class="comment">//声明一个字符串切片</span></span><br><span class="line"><span class="keyword">var</span> b = []<span class="type">int</span>&#123;&#125;             <span class="comment">//声明一个整型切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> c = []<span class="type">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> d = []<span class="type">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line">fmt.Println(a)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(b)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(c)              <span class="comment">//[false true]</span></span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>)       <span class="comment">//true</span></span><br><span class="line">fmt.Println(b == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line">fmt.Println(c == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line"><span class="comment">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p><h3 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h3><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><h4 id="简单切片表达式"><a href="#简单切片表达式" class="headerlink" title="简单切片表达式"></a>简单切片表达式</h4><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;s:%v len(s):%v cap(s):%v\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:[2 3] len(s):2 <span class="built_in">cap</span>(s):4</span><br></pre></td></tr></table></figure><p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>:]  <span class="comment">// 等同于 a[2:len(a)]</span></span><br><span class="line">a[:<span class="number">3</span>]  <span class="comment">// 等同于 a[0:3]</span></span><br><span class="line">a[:]   <span class="comment">// 等同于 a[0:len(a)]</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p><p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;s:%v len(s):%v cap(s):%v\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">s2 := s[<span class="number">3</span>:<span class="number">4</span>]  <span class="comment">// 索引的上限是cap(s)而不是len(s)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;s2:%v len(s2):%v cap(s2):%v\n&quot;</span>, s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s:[2 3] len(s):2 <span class="built_in">cap</span>(s):4</span><br><span class="line">s2:[5] len(s2):1 <span class="built_in">cap</span>(s2):1</span><br></pre></td></tr></table></figure><h4 id="完整切片表达式"><a href="#完整切片表达式" class="headerlink" title="完整切片表达式"></a>完整切片表达式</h4><p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high : max]</span><br></pre></td></tr></table></figure><p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;t:%v len(t):%v cap(t):%v\n&quot;</span>, t, <span class="built_in">len</span>(t), <span class="built_in">cap</span>(t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t:[2 3] len(t):2 <span class="built_in">cap</span>(t):4</span><br></pre></td></tr></table></figure><p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p><h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make([]T, size, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(a)      <span class="comment">//[0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a)) <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a)) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p><h3 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h3><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p><p>举个例子，现在有一个数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<img src="https://www.liwenzhou.com/images/Go/slice/slice_01.png" alt="slice_01">切片<code>s2 := a[3:6]</code>，相应示意图如下：<img src="https://www.liwenzhou.com/images/Go/slice/slice_02.png" alt="slice_02"></p><h3 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h3><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]</span></span><br><span class="line">s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">fmt.Println(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">fmt.Println(i, s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意：**通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;&#125;  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="type">int</span>)  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//append()添加元素和切片扩容</span></span><br><span class="line"><span class="keyword">var</span> numSlice []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numSlice = <span class="built_in">append</span>(numSlice, i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;</span>, numSlice, <span class="built_in">len</span>(numSlice), <span class="built_in">cap</span>(numSlice), numSlice)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0]  len:1  <span class="built_in">cap</span>:1  ptr:0xc0000a8000</span><br><span class="line">[0 1]  len:2  <span class="built_in">cap</span>:2  ptr:0xc0000a8040</span><br><span class="line">[0 1 2]  len:3  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3]  len:4  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3 4]  len:5  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5]  len:6  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6]  len:7  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7]  len:8  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7 8]  len:9  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br><span class="line">[0 1 2 3 4 5 6 7 8 9]  len:10  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><p>append()函数还支持一次性追加多个元素。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> citySlice []<span class="type">string</span></span><br><span class="line"><span class="comment">// 追加一个元素</span></span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, <span class="string">&quot;北京&quot;</span>)</span><br><span class="line"><span class="comment">// 追加多个元素</span></span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>)</span><br><span class="line"><span class="comment">// 追加切片</span></span><br><span class="line">a := []<span class="type">string</span>&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;</span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, a...)</span><br><span class="line">fmt.Println(citySlice) <span class="comment">//[北京 上海 广州 深圳 成都 重庆]</span></span><br></pre></td></tr></table></figure><h2 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h2><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出以下内容：</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap&#x3D;doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1&#x2F;4，即（newcap&#x3D;old.cap,for {newcap +&#x3D; newcap&#x2F;4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;&#x3D; cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p><h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h2><p>首先我们来看一个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := a</span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// copy()复制切片</span></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">copy</span>(c, a)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片c</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p><h2 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h2><p>1.请写出下面代码的输出结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">a = <span class="built_in">append</span>(a, fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, i))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.请使用内置的<code>sort</code>包对数组<code>var a = [...]int&#123;3, 7, 8, 9, 1&#125;</code>进行排序（附加题，自行查资料解答）。</p>]]></content>
    
    
    <categories>
      
      <category>开发学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day05</title>
    <link href="/2025/02/13/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day05/"/>
    <url>/2025/02/13/Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day05/</url>
    
    <content type="html"><![CDATA[<p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p><h2 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h2><p>Go语言中 <code>map</code>的定义语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><h2 id="map基本使用"><a href="#map基本使用" class="headerlink" title="map基本使用"></a>map基本使用</h2><p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(scoreMap)</span><br><span class="line">fmt.Println(scoreMap[<span class="string">&quot;小明&quot;</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, scoreMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[小明:100 张三:90]</span><br><span class="line">100</span><br><span class="line"><span class="built_in">type</span> of a:map[string]int</span><br></pre></td></tr></table></figure><p>map也支持在声明的时候填充元素，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">userInfo := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;username&quot;</span>: <span class="string">&quot;沙河小王子&quot;</span>,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(userInfo) <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h2><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h2><p>Go语言中使用<code>for range</code>遍历map。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">&quot;娜扎&quot;</span>] = <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们只想遍历key的时候，可以按下面的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">&quot;娜扎&quot;</span>] = <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">fmt.Println(k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p><h2 id="使用delete-函数删除键值对"><a href="#使用delete-函数删除键值对" class="headerlink" title="使用delete()函数删除键值对"></a>使用delete()函数删除键值对</h2><p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>map:表示要删除键值对的map</li><li>key:表示要删除的键值对的键</li></ul><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">&quot;娜扎&quot;</span>] = <span class="number">60</span></span><br><span class="line"><span class="built_in">delete</span>(scoreMap, <span class="string">&quot;小明&quot;</span>)<span class="comment">//将小明:100从map中删除</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按照指定顺序遍历map"><a href="#按照指定顺序遍历map" class="headerlink" title="按照指定顺序遍历map"></a>按照指定顺序遍历map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano()) <span class="comment">//初始化随机数种子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scoreMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">key := fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i) <span class="comment">//生成stu开头的字符串</span></span><br><span class="line">value := rand.Intn(<span class="number">100</span>)          <span class="comment">//生成0~99的随机整数</span></span><br><span class="line">scoreMap[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出map中的所有key存入切片keys</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对切片进行排序</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"><span class="comment">//按照排序后的key遍历map</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">fmt.Println(key, scoreMap[key])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h2><p>下面的代码演示了切片中的元素为map类型时的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mapSlice = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line"><span class="comment">// 对切片中的map元素进行初始化</span></span><br><span class="line">mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">&quot;password&quot;</span>] = <span class="string">&quot;123456&quot;</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;沙河&quot;</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h2><p>下面的代码演示了map中值为切片类型的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sliceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">fmt.Println(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line">key := <span class="string">&quot;中国&quot;</span></span><br><span class="line">value, ok := sliceMap[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">value = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="built_in">append</span>(value, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>)</span><br><span class="line">sliceMap[key] = value</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>写一个程序，统计一个字符串中每个单词出现的次数。比如：“how do you do”中how&#x3D;1 do&#x3D;2 you&#x3D;1。</li><li>观察下面代码，写出最终的打印结果。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span></span><br><span class="line">m := <span class="built_in">make</span>(Map)</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)</span><br><span class="line">m[<span class="string">&quot;q1mi&quot;</span>] = s</span><br><span class="line">s = <span class="built_in">append</span>(s[:<span class="number">1</span>], s[<span class="number">2</span>:]...)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, m[<span class="string">&quot;q1mi&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos配置变更</title>
    <link href="/2025/02/13/nacos%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4/"/>
    <url>/2025/02/13/nacos%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="配置变更插件"><a href="#配置变更插件" class="headerlink" title="配置变更插件"></a>配置变更插件</h2><p>社区中一直以来都希望Nacos配置中心能在配置发生变更时，通知一些特定系统，用于发送记录、警告等审计功能。在2.3.0版本前，只能通过模拟Nacos客户端订阅配置的方式，对核心配置的变更操作进行订阅，在收到变更通知后，进行发送记录、警告等功能的执行。</p><p>这种实现方式有几个比较大的问题，第一是监听的配置需要逐个添加，难以对所有配置变更进行获取；第二是只能在配置变更后执行功能逻辑，无法做到前置的操作，如格式校验，白名单校验等。</p><p>因此Nacos在2.3.0版本后，支持通过<a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html">SPI</a>注入配置变更插件，允许用户通过自定义插件的方式，对配置变更前，和变更完成后分别执行一些自定义逻辑，如格式校验，白名单校验，webhook等。</p><h2 id="配置变更插件中的概念"><a href="#配置变更插件中的概念" class="headerlink" title="配置变更插件中的概念"></a>配置变更插件中的概念</h2><p>Nacos的配置变更插件，参考了面向切面编程AOP的设计思想，将配置的变更操作（如新增，更新，删除）作为<code>切点（PointCut)</code>，并在这些切点<code>前(Before)</code>和<code>后(After)</code>织入插件。</p><h3 id="配置变更切点-ConfigChangePointCutTypes"><a href="#配置变更切点-ConfigChangePointCutTypes" class="headerlink" title="配置变更切点(ConfigChangePointCutTypes)"></a>配置变更切点(ConfigChangePointCutTypes)</h3><p>Nacos根据配置变更的行为和来源，将配置变更操作在<code>com.alibaba.nacos.plugin.config.constants.ConfigChangePointCutTypes</code>中定位为了数个<code>配置变更切点(ConfigChangePointCutTypes)</code>，具体内容如下：</p><table><thead><tr><th>切点名称</th><th>描述</th><th>起始版本</th></tr></thead><tbody><tr><td>PUBLISH_BY_HTTP</td><td>配置通过HTTP接口进行发布，包含了创建配置及修改配置</td><td>2.3.0</td></tr><tr><td>PUBLISH_BY_RPC</td><td>配置通过GRPC接口进行发布，包含了创建配置及修改配置</td><td>2.3.0</td></tr><tr><td>REMOVE_BY_HTTP</td><td>配置通过HTTP接口进行删除</td><td>2.3.0</td></tr><tr><td>REMOVE_BY_RPC</td><td>配置通过GRPC接口进行删除</td><td>2.3.0</td></tr><tr><td>IMPORT_BY_HTTP</td><td>配置通过HTTP接口进行导入</td><td>2.3.0</td></tr><tr><td>REMOVE_BATCH_HTTP</td><td>配置通过HTTP接口进行批量删除</td><td>2.3.0</td></tr></tbody></table><h3 id="配置变更织入类型-ConfigChangeExecuteTypes"><a href="#配置变更织入类型-ConfigChangeExecuteTypes" class="headerlink" title="配置变更织入类型(ConfigChangeExecuteTypes)"></a>配置变更织入类型(ConfigChangeExecuteTypes)</h3><p>Nacos的配置变更插件需要在<code>配置变更切点</code>之前或之后进行执行，即需要选择<code>配置变更织入类型(ConfigChangeExecuteTypes)</code>，定义在<code>com.alibaba.nacos.plugin.config.constants.ConfigChangeExecuteTypes</code>中，具体内容如下：</p><table><thead><tr><th>织入类型</th><th>描述</th><th>起始版本</th></tr></thead><tbody><tr><td>EXECUTE_BEFORE_TYPE</td><td>插件实现在<code>配置变更切点</code>之<strong>前</strong>执行</td><td>2.3.0</td></tr><tr><td>EXECUTE_AFTER_TYPE</td><td>插件实现在<code>配置变更切点</code>之<strong>后</strong>执行</td><td>2.3.0</td></tr></tbody></table><h2 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h2><p>开发Nacos服务端配置变更插件，首先需要依赖配置变更插件的的相关API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;            &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;            &lt;artifactId&gt;nacos-config-plugin&lt;/artifactId&gt;            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><code>$&#123;project.version&#125;</code> 为您开发插件所对应的Nacos版本，<code>2.3.0</code>及以上。</p><p>随后实现<code>com.alibaba.nacos.plugin.config.spi.ConfigChangePluginService</code>接口，该接口需要实现的方法如下：</p><table><thead><tr><th>方法名</th><th>入参内容</th><th>返回内容</th><th>描述</th></tr></thead><tbody><tr><td>getServiceType</td><td>void</td><td>String</td><td>插件的名称，用于区分不同类型的插件实现</td></tr><tr><td>getOrder</td><td>void</td><td>int</td><td>插件的执行顺序，配置变更插件采用链式插件设计，多个插件实现时会按照顺序执行，getOrder越小，顺序越靠前</td></tr><tr><td>executeType</td><td>void</td><td>ConfigChangeExecuteTypes</td><td>插件实现的<code>配置变更织入类型</code></td></tr><tr><td>pointcutMethodNames</td><td>void</td><td>ConfigChangePointCutTypes[]</td><td>插件实现织入的<code>配置变更切点</code></td></tr><tr><td>execute</td><td>ConfigChangeRequest,ConfigChangeResponse</td><td>void</td><td>实际插件执行的逻辑</td></tr></tbody></table><p>其中<code>ConfigChangeRequest</code>和<code>ConfigChangeResponse</code>分别为执行逻辑时传入的内容及执行结果，</p><p><code>ConfigChangeRequest</code>的具体内容如下:</p><table><thead><tr><th>字段名</th><th>字段类型</th><th>描述</th></tr></thead><tbody><tr><td>requestType</td><td>ConfigChangePointCutTypes</td><td>本次配置变更的切点类型</td></tr><tr><td>requestArgs</td><td>HashMap&lt;String, Object&gt;</td><td>本次配置变更的实际参数，主要包含有<code>namespace</code>,<code>group</code>,<code>dataId</code>,<code>content</code>等内容，不同的切点类型参数存在不同</td></tr></tbody></table><p><code>ConfigChangeResponse</code> 的具体内容如下:</p><table><thead><tr><th>字段名</th><th>字段类型</th><th>描述</th></tr></thead><tbody><tr><td>responseType</td><td>ConfigChangePointCutTypes</td><td>本次配置变更的切点类型</td></tr><tr><td>isSuccess</td><td>boolean</td><td>执行是否成功，当返回值为<code>false</code>时，将会拦截本次配置变更，并直接返回失败的结果</td></tr><tr><td>retVal</td><td>Object</td><td>返回内容，预留字段，暂未启用</td></tr><tr><td>msg</td><td>String</td><td>执行结果信息，在<code>isSuccess</code>为<code>false</code>时获取，用于返回给客户端的信息</td></tr><tr><td>args</td><td>Object[]</td><td>配置变更操作的执行参数，在<code>EXECUTE_BEFORE_TYPE</code>的插件类型时生效，可用于修改实际执行的配置变更时的内容，如将content中的某些内容修改为其他值</td></tr></tbody></table><h3 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h3><p>插件开发完成后，需要打包成jar&#x2F;zip，放置到nacos服务端的classpath中，如果您不知道如何修改classpath，请直接放置到<code>$&#123;nacos-server.path&#125;/plugins</code>下</p><p>放置后，需要修改<code>$&#123;nacos-server.path&#125;/conf/application.properties</code>中的以下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 所启用的Nacos的配置变更插件的名称，与com.alibaba.nacos.plugin.config.spi.ConfigChangePluginService 的getServiceType 返回值对应nacos.core.config.plugin.$&#123;configChangePluginName&#125;.enabled=true</span><br></pre></td></tr></table></figure><p>随后重启nacos集群，启动完成后，可在<code>$&#123;nacos-server.path&#125;/logs/nacos.log</code>日志中看到如下日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ConfigChangePluginManager] Load $&#123;className&#125;($&#123;classFullName&#125;) ConfigChangeServiceName($&#123;configChangePluginName&#125;) successfully.</span><br></pre></td></tr></table></figure><h3 id="插件自定义参数传递"><a href="#插件自定义参数传递" class="headerlink" title="插件自定义参数传递"></a>插件自定义参数传递</h3><p>部分插件可能希望通过配置文件设置一些参数，自定义插件可以通过修改<code>$&#123;nacos-server.path&#125;/conf/application.properties</code>中的以下配置完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 所启用的Nacos的配置变更插件的名称，与com.alibaba.nacos.plugin.config.spi.ConfigChangePluginService 的getServiceType 返回值对应nacos.core.config.plugin.$&#123;configChangePluginName&#125;.$&#123;propertyKey&#125;=$&#123;propertyValue&#125;</span><br></pre></td></tr></table></figure><p>之后能在<code>ConfigChangeRequest</code>中，通过下述方法获取该参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Properties properties = (Properties) configChangeRequest.getArg(ConfigChangeConstants.PLUGIN_PROPERTIES);final String $&#123;propertyKey&#125; = properties.getProperty(&quot;$&#123;propertyKey&#125;&quot;);</span><br></pre></td></tr></table></figure><h2 id="插件DEMO实现"><a href="#插件DEMO实现" class="headerlink" title="插件DEMO实现"></a>插件DEMO实现</h2><p>在<a href="https://github.com/nacos-group/nacos-plugin">nacos-group&#x2F;nacos-plugin</a>中，有一个demo的配置变更插件的实现，该demo插件实现了对配置内容格式的校验、配置导入名称白名单的校验、以及变更后回调webhook。打包成jar&#x2F;zip，放置到nacos服务端的classpath中，在<code>$&#123;nacos-server.path&#125;/conf/application.properties</code>中的加入以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># webhook#nacos.core.config.plugin.webhook.enabled=true# It is recommended to use EB https://help.aliyun.com/document_detail/413974.html#nacos.core.config.plugin.webhook.url=http://$&#123;webhookIp&#125;:$&#123;webhookPort&#125;/$&#123;webhookUri&#125;?token=***# The content push max capacity ,byte#nacos.core.config.plugin.webhook.contentMaxCapacity=102400# whitelist#nacos.core.config.plugin.whitelist.enabled=true# The import file suffixs#nacos.core.config.plugin.whitelist.suffixs=xml,text,properties,yaml,html# fileformatcheck,which validate the import file of type and content#nacos.core.config.plugin.fileformatcheck.enabled=true</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos系统参数介绍</title>
    <link href="/2025/02/13/nacos/"/>
    <url>/2025/02/13/nacos/</url>
    
    <content type="html"><![CDATA[<h2 id="Nacos-系统参数介绍"><a href="#Nacos-系统参数介绍" class="headerlink" title="Nacos 系统参数介绍"></a>Nacos 系统参数介绍</h2><h2 id="1-Nacos-Server"><a href="#1-Nacos-Server" class="headerlink" title="1. Nacos Server"></a>1. Nacos Server</h2><p>对于Server端来说，一般是设置在<code>&#123;nacos.home&#125;/conf/application.properties</code>里，如果参数名后标注了(-D)的，则表示是 JVM 的参数，需要在<code>&#123;nacos.home&#125;/bin/startup.sh</code>里进行相应的设置。例如像设置 nacos.home 的值，可以在<code>&#123;nacos.home&#125;/bin/startup.sh</code>进行如下设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -Dnacos.home=$&#123;BASE_DIR&#125;&quot;</span><br></pre></td></tr></table></figure><p>若没有标注(-D)的参数，则同时可以在<code>&#123;nacos.home&#125;/conf/application.properties</code>里和JVM参数中配置，如果同时配置了JVM参数和<code>&#123;nacos.home&#125;/conf/application.properties</code>，那么JVM参数的优先级更高。</p><h3 id="1-1-全局参数"><a href="#1-1-全局参数" class="headerlink" title="1.1. 全局参数"></a>1.1. 全局参数</h3><h4 id="1-1-1-基础参数"><a href="#1-1-1-基础参数" class="headerlink" title="1.1.1. 基础参数"></a>1.1.1. 基础参数</h4><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.home(-D)</td><td>Nacos的根目录</td><td>目录路径</td><td>Nacos安装的目录</td></tr><tr><td>nacos.standalone(-D)</td><td>是否在单机模式</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>nacos.functionMode(-D)</td><td>启动模式，支持只启动某一个模块，不设置时所有模块都会启动</td><td>config&#x2F;naming&#x2F;空</td><td>空</td></tr><tr><td>nacos.server.ip(-D)</td><td>Nacos服务端的IP，优先级比<code>nacos.inetutils.ip-address</code>更高，如果配置了该参数，则<code>nacos.inetutils.ip-address</code>不再生效</td><td>本机IP</td><td>null</td></tr><tr><td>nacos.inetutils.prefer-hostname-over-ip</td><td>节点优先使用hostname作为本机ip，若为<code>true</code>时，<code>cluster.conf</code>里是否应该填<code>hostname</code></td><td>true&#x2F;false</td><td>false</td></tr><tr><td>nacos.inetutils.ip-address</td><td>本机IP，该参数设置后，将会使用这个IP去<code>cluster.conf</code>里进行匹配，请确保这个IP的值在<code>cluster.conf</code>里是存在的</td><td>本机IP</td><td>null</td></tr><tr><td>nacos.core.sys.basic.processors</td><td>指定服务端的处理器个数，用于部分虚拟化场景，防止读取CPU个数时读取到错误的值，导致线程数过多或过少</td><td>正整数</td><td>CPU个数</td></tr><tr><td>nacos.core.monitor.topn.enabled</td><td>Nacos Server topN 监控统计能力开关</td><td>true&#x2F;false</td><td>true</td></tr><tr><td>nacos.core.monitor.topn.count</td><td>Nacos Server topN 监控统计 top的个数，如如配置为10，表示top10的配置和服务</td><td>正整数</td><td>10</td></tr><tr><td>nacos.core.snowflake.worker-id</td><td>Nacos Server 的snowflake workerId</td><td>正整数</td><td>-1</td></tr><tr><td>nacos.core.param.check.enabled</td><td>Nacos Server 参数校验能力开关，开启后将会校验请求时的参数是否符合规范，不符合将被拦截，详情查看 <a href="https://nacos.io/docs/latest/manual/user/parameters-check/">参数校验</a></td><td>true&#x2F;false</td><td>true</td></tr><tr><td>server.port</td><td>Nacos Server 的端口</td><td>正整数</td><td>8848</td></tr><tr><td>server.servlet.context-path</td><td>Nacos Server 的Servlet上下文路径</td><td>正则表达式</td><td>&#x2F;nacos</td></tr><tr><td>spring.config.additional-location</td><td>Nacos Server 的额外配置文件路径，除<code>&#123;nacos.home&#125;/conf/application.properties</code>外，用户可以添加额外的配置文件</td><td>文件路径，多个文件路径用逗号分隔</td><td>null</td></tr></tbody></table><h4 id="1-1-2-数据库"><a href="#1-1-2-数据库" class="headerlink" title="1.1.2. 数据库"></a>1.1.2. 数据库</h4><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>spring.sql.init.platform</td><td>Nacos Server 使用的数据库类型</td><td>mysql&#x2F;空，指定为空时会根据<code>nacos.standalone</code>判断使用derby数据库还是mysql数据库；在使用<a href="https://nacos.io/docs/latest/plugin/datasource-plugin/">数据源插件</a>时，可以指定为插件对应的数据库值，比如oracle或postgresql</td><td>null</td></tr><tr><td>spring.datasource.platform</td><td>Nacos Server 使用的数据库类型，即将被废弃，请使用<code>spring.sql.init.platform</code>代替</td><td>mysql&#x2F;空</td><td>null</td></tr><tr><td>db.num</td><td>数据库数目</td><td>正整数</td><td>0</td></tr><tr><td>db.url.0</td><td>第一个数据库的URL</td><td>字符串</td><td>空</td></tr><tr><td>db.url.1</td><td>第二个数据库的URL，当db.num&#x3D;2时生效</td><td>字符串</td><td>空</td></tr><tr><td>db.user</td><td>数据库连接的用户名</td><td>字符串</td><td>空</td></tr><tr><td>db.password</td><td>数据库连接的密码</td><td>字符串</td><td>空</td></tr><tr><td>db.pool.config.xxx</td><td>数据库连接池参数，使用的是hikari连接池，参数与hikari连接池相同，如<code>db.pool.config.connectionTimeout</code>或<code>db.pool.config.maximumPoolSize</code></td><td>字符串</td><td>同hikariCp对应默认配置</td></tr></tbody></table><p>当前数据库配置支持多数据源。通过<code>db.num</code>来指定数据源个数，<code>db.url.index</code>为对应的数据库的链接。<code>db.user</code>以及<code>db.password</code>没有设置<code>index</code>时,所有的链接都以<code>db.user</code>和<code>db.password</code>用作认证。如果不同数据源的用户名称或者用户密码不一样时，可以通过符号<code>,</code>来进行切割，或者指定<code>db.user.index</code>,<code>db.user.password</code>来设置对应数据库链接的用户或者密码。需要注意的是，当<code>db.user</code>和<code>db.password</code>没有指定下标时，因为当前机制会根据<code>,</code>进行切割。所以当用户名或者密码存在<code>,</code>时，会把<code>,</code>切割后前面的值当成最后的值进行认证，会导致认证失败。</p><p>Nacos从1.3版本开始使用HikariCP连接池，但在1.4.1版本前，连接池配置由系统默认值定义，无法自定义配置。在1.4.1后，提供了一个方法能够配置HikariCP连接池。 <code>db.pool.config</code>为配置前缀，<code>xxx</code>为实际的hikariCP配置，如<code>db.pool.config.connectionTimeout</code>或<code>db.pool.config.maximumPoolSize</code>等。更多hikariCP的配置请查看<a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a> 需要注意的是，url,user,password会由<code>db.url.n</code>,<code>db.user</code>,<code>db.password</code>覆盖，driverClassName则是默认的MySQL8 driver（该版本mysql driver支持mysql5.x)</p><h4 id="1-1-2-Remoting"><a href="#1-1-2-Remoting" class="headerlink" title="1.1.2. Remoting"></a>1.1.2. Remoting</h4><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.remote.server.grpc.sdk.max-inbound-message-size</td><td>Nacos Server gRPC 能接收的单次最大客户端请求大小，单位byte</td><td>正整数</td><td>10 * 1024 * 1024</td></tr><tr><td>nacos.remote.server.grpc.cluster.max-inbound-message-size</td><td>Nacos Server gRPC 能接收的单次最大集群间请求大小，单位byte</td><td>正整数</td><td>10 * 1024 * 1024</td></tr><tr><td>nacos.metric.grpc.server.executor.enabled</td><td>Nacos Server gRPC线程池 监控能力开关</td><td>true&#x2F;false</td><td>true</td></tr><tr><td>nacos.metric.grpc.server.executor.interval</td><td>Nacos Server gRPC线程池的间隔时间，单位为毫秒</td><td>正整数</td><td>15000</td></tr><tr><td>nacos.metric.grpc.server.connection.enabled</td><td>Nacos Server gRPC长连接 监控能力开关</td><td>true&#x2F;false</td><td>true</td></tr><tr><td>nacos.metric.grpc.server.connection.interval</td><td>Nacos Server gRPC长连接的间隔时间，单位为<strong>秒</strong></td><td>正整数</td><td>15</td></tr><tr><td>remote.executor.times.of.processors(-D)</td><td>服务端，处理请求的线程池大小的倍数, 例如配置为2，表示线程池大小为2 * CPU</td><td>正整数</td><td>16</td></tr><tr><td>remote.executor.queue.size(-D)</td><td>服务端，处理请求的线程池队列大小</td><td>正整数</td><td>16384</td></tr></tbody></table><h4 id="1-1-3-集群列表"><a href="#1-1-3-集群列表" class="headerlink" title="1.1.3. 集群列表"></a>1.1.3. 集群列表</h4><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.member.list</td><td>Nacos Server 地址列表，在<code>cluster.conf</code>不存在时生效</td><td><code>ip1:port1,ip2:port2</code></td><td>null</td></tr><tr><td>nacos.member-change-event.queue.size</td><td>Nacos Server 集群节点变更事件队列的大小，当集群节点通过<code>cluster.conf</code>或地址服务器变更时，会将变更事件放入该队列，该队列会异步通知Server中的一些机制，比如Distro&#x2F;Raft协议。</td><td>正整数</td><td>128</td></tr><tr><td>nacos.core.member.lookup.type</td><td>Nacos Server 集群节点的发现方式，支持配置文件<code>cluster.conf</code>和地址服务器模式</td><td>file&#x2F;address-server</td><td>file</td></tr><tr><td>nacos.core.address-server.retry</td><td>当<code>nacos.core.member.lookup.type</code>指定为<code>address-server</code>时生效，请求地址服务器的重试次数，超过重试次数后不再尝试从地址服务器获取NacosServer的集群列表</td><td>正整数</td><td>5</td></tr><tr><td>address.server.domain</td><td>当<code>nacos.core.member.lookup.type</code>指定为<code>address-server</code>时生效，地址服务器的域名</td><td>域名</td><td>jmenv.tbsite.net</td></tr><tr><td>address.server.port</td><td>当<code>nacos.core.member.lookup.type</code>指定为<code>address-server</code>时生效，地址服务器的端口</td><td>0～65535</td><td>8080</td></tr><tr><td>address.server.url</td><td>当<code>nacos.core.member.lookup.type</code>指定为<code>address-server</code>时生效，地址服务器的url</td><td>字符串</td><td>&#x2F;serverlist</td></tr></tbody></table><h3 id="1-2-Distro-协议"><a href="#1-2-Distro-协议" class="headerlink" title="1.2. Distro 协议"></a>1.2. Distro 协议</h3><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.core.protocol.distro.data.sync.delayMs</td><td>Distro协议同步数据的延迟时间，同一份数据处于延迟时间内多次变更时，会被合并为一次同步，单位为毫秒</td><td>正整数</td><td>1000</td></tr><tr><td>nacos.core.protocol.distro.data.sync.timeoutMs</td><td>Distro协议同步数据的超时时间，同步到目标节点时超过该时间，则会认为同步失败，进行延迟后重试，单位为毫秒</td><td>正整数</td><td>3000</td></tr><tr><td>nacos.core.protocol.distro.data.sync.retryDelayMs</td><td>Distro协议同步数据的重试间隔，当数据同步到目标节点失败时，进行该值时间的延迟后再重试，避免同步重试风暴，单位为毫秒</td><td>正整数</td><td>3000</td></tr><tr><td>nacos.core.protocol.distro.data.verify.intervalMs</td><td>Distro协议数据验证的间隔，已经同步过的数据，会定期进行数据有效性验证，验证失败会重新发起该数据的同步，单位为毫秒</td><td>正整数</td><td>5000</td></tr><tr><td>nacos.core.protocol.distro.data.verify.timeoutMs</td><td>Distro协议数据验证的超时时间，单位为毫秒</td><td>正整数</td><td>3000</td></tr><tr><td>nacos.core.protocol.distro.data.load.retryDelayMs</td><td>Distro协议快照数据加载的重试间隔，在节点刚启动时生效，单位为毫秒</td><td>正整数</td><td>30000</td></tr><tr><td>nacos.core.protocol.distro.data.load.timeoutMs</td><td>Distro协议快照数据加载的超时时间，超过该时间未读取到其他节点的快照数据，则认为加载快照失败，单位为毫秒</td><td>正整数</td><td>30000</td></tr></tbody></table><h3 id="1-3-Raft-协议"><a href="#1-3-Raft-协议" class="headerlink" title="1.3 Raft 协议"></a>1.3 Raft 协议</h3><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.core.protocol.raft.election_timeout_ms</td><td>Raft协议选举超时时间，单位ms</td><td>正整数</td><td>5000</td></tr><tr><td>nacos.core.protocol.raft.snapshot_interval_secs</td><td>Raft协议快照写入间隔时间，单位s</td><td>正整数</td><td>3600</td></tr><tr><td>nacos.core.protocol.raft.core_thread_num</td><td>Raft协议的核心线程数，用于处理Raft同步的请求线程数</td><td>正整数</td><td>8</td></tr><tr><td>nacos.core.protocol.raft.cli_service_thread_num</td><td>Raft协议的核心线程数，用于发起Raft同步数据的请求线程数</td><td>正整数</td><td>4</td></tr><tr><td>nacos.core.protocol.raft.rpc_request_timeout_ms</td><td>Raft协议请求的超时时间，单位ms</td><td>正整数</td><td>5000</td></tr><tr><td>nacos.core.protocol.raft.max_byte_count_per_rpc</td><td>Raft协议单次请求最大字节数</td><td>正整数</td><td>128 * 1024</td></tr><tr><td>nacos.core.protocol.raft.max_entries_size</td><td>Raft协议单个日志的最大个数</td><td>正整数</td><td>1024</td></tr><tr><td>nacos.core.protocol.raft.max_body_size</td><td>Raft协议发送日志的最大 body 大小</td><td>正整数</td><td>512 * 1024</td></tr><tr><td>nacos.core.protocol.raft.max_append_buffer_size</td><td>Raft协议日志存储缓冲区最大大小</td><td>正整数</td><td>256 * 1024</td></tr><tr><td>nacos.core.protocol.raft.max_election_delay_ms</td><td>Raft协议选举的最大随机间隔，选举定时器间隔会在指定时间之外随机的最大范围</td><td>正整数</td><td>1000</td></tr><tr><td>nacos.core.protocol.raft.strict_mode</td><td>从<code>2.4.2</code>版本开始支持，Raft的启动校验是否采用严格模式，开启后，当raft无法选举时，引擎的readiness接口将返回500</td><td>true&#x2F;false</td><td>false</td></tr></tbody></table><h3 id="1-4-Naming模块"><a href="#1-4-Naming模块" class="headerlink" title="1.4. Naming模块"></a>1.4. Naming模块</h3><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.naming.expireInstance</td><td>是否自动摘除临时实例</td><td>true&#x2F;false</td><td>true</td></tr><tr><td>nacos.naming.data.warmup</td><td>从<code>2.4.2</code>版本开始支持，是否在启动时校验数据是否预热，开启可能造成Server的readiness接口返回500，需要等待预热完成，启动时间变长</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>nacos.naming.clean.empty-service.interval</td><td>Naming模块的空服务清理间隔，单位毫秒</td><td>正整数</td><td>60 * 1000</td></tr><tr><td>nacos.naming.clean.empty-service.expired-time</td><td>Naming模块的空服务过期时间，过期的空服务会被清理，单位毫秒</td><td>正整数</td><td>60 * 1000</td></tr><tr><td>nacos.naming.clean.expired-metadata.interval</td><td>Naming模块的元数据清理间隔，单位毫秒</td><td>正整数</td><td>5000</td></tr><tr><td>nacos.naming.clean.expired-metadata.expired-time</td><td>Naming模块的元数据过期时间，过期的元数据会被清理，单位毫秒</td><td>正整数</td><td>60 * 1000</td></tr><tr><td>nacos.naming.client.expired.time</td><td>临时Client对应数据的过期时间，当Distro协议停止对该Client的数据进行续约且时间超过该值时，该Client数据将被删除，主要应对Nacos Server之间断网的场景，单位毫秒</td><td>正整数</td><td>3 * 60 * 1000</td></tr><tr><td>nacos.naming.push.pushTaskDelay</td><td>服务数据推送的延迟时间，同一个人服务处于延迟时间内多次变更时，会被合并为一次推送，单位为毫秒</td><td>正整数</td><td>500</td></tr><tr><td>nacos.naming.push.pushTaskTimeout</td><td>服务数据推送的超时时间，超过该时间未收到客户端的确认，将延迟后重试，单位为毫秒</td><td>正整数</td><td>5000</td></tr><tr><td>nacos.naming.push.pushTaskRetryDelay</td><td>服务数据推送失败后的重试间隔时间，单位为毫秒</td><td>正整数</td><td>1000</td></tr></tbody></table><h3 id="1-5-Config模块"><a href="#1-5-Config模块" class="headerlink" title="1.5. Config模块"></a>1.5. Config模块</h3><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.config.push.maxRetryTime</td><td>配置变更数据推送的延迟时间，同一个人配置处于延迟时间内多次变更时，会被合并为一次推送，单位为毫秒</td><td>正整数</td><td>50</td></tr><tr><td>nacos.config.retention.days</td><td>Nacos配置中心配置变更历史保留天数，超过该时间的配置变更历史会被删除</td><td>正整数</td><td>30</td></tr><tr><td>nacos.config.search.max_capacity</td><td>Nacos配置中心，根据配置内容查找配置功能的最大队列个数，由于基于内容的检索十分消耗性能，因此对该功能的并发进行限制，最大不可超过32</td><td>0～32</td><td>4</td></tr><tr><td>nacos.config.search.max_thread</td><td>根据配置内容查找配置功能的最大线程数，最大并发数，最大不可超过16</td><td>0～16</td><td>2</td></tr><tr><td>nacos.config.search.wait_timeout</td><td>根据配置内容查找配置功能的等待超时时间，超过等待时间的查找任务会直接失败丢弃，单位毫秒</td><td>正整数</td><td>8000</td></tr><tr><td>nacos.config.derby.ops.enabled</td><td>当使用derby数据库作为存储时，是否开启derby的相关运维接口</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>nacos.persistence.sql.derby.limit.enabled</td><td>当使用derby数据库作为存储时,限制derby数据库可执行的SQL范围为DML和部分DDL，从<code>2.4.1</code>版本开始支持</td><td>true&#x2F;false</td><td>true</td></tr></tbody></table><h3 id="1-6-CMDB模块"><a href="#1-6-CMDB模块" class="headerlink" title="1.6. CMDB模块"></a>1.6. CMDB模块</h3><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.cmdb.loadDataAtStart</td><td>是否打开CMDB</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>nacos.cmdb.dumpTaskInterval</td><td>全量dump的间隔，单位为秒</td><td>正整数</td><td>3600</td></tr><tr><td>nacos.cmdb.eventTaskInterval</td><td>变更事件的拉取间隔，单位为秒</td><td>正整数</td><td>10</td></tr><tr><td>nacos.cmdb.labelTaskInterval</td><td>标签集合的拉取间隔，单位为秒</td><td>正整数</td><td>300</td></tr></tbody></table><h3 id="1-7-Istio模块"><a href="#1-7-Istio模块" class="headerlink" title="1.7. Istio模块"></a>1.7. Istio模块</h3><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.extension.naming.istio.enabled</td><td>是否加载istio模块</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>nacos.istio.mcp.server.enabled</td><td>是否开启Istio MCP协议</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>nacos.istio.mcp.server.port</td><td>Istio MCP协议监听端口</td><td>正整数</td><td>18848</td></tr></tbody></table><h3 id="1-8-插件"><a href="#1-8-插件" class="headerlink" title="1.8. 插件"></a>1.8. 插件</h3><h4 id="1-8-1-鉴权插件"><a href="#1-8-1-鉴权插件" class="headerlink" title="1.8.1. 鉴权插件"></a>1.8.1. 鉴权插件</h4><p>关于如何开发鉴权插件，请参考<a href="https://nacos.io/docs/latest/plugin/auth-plugin/">鉴权插件</a></p><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.core.auth.enabled</td><td>Nacos是否开启鉴权</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>nacos.core.auth.system.type</td><td>Nacos鉴权插件的类型</td><td>nacos&#x2F;ldap&#x2F;自定义插件类型</td><td>nacos</td></tr><tr><td>nacos.core.auth.server.identity.key</td><td>Nacos Server节点身份信息的key，用户Server节点之间通信的识别，当开启鉴权时为必填项</td><td>字符串</td><td>null</td></tr><tr><td>nacos.core.auth.server.identity.value</td><td>Nacos Server节点身份信息的value，用户Server节点之间通信的识别，当开启鉴权时为必填项</td><td>字符串</td><td>null</td></tr><tr><td>nacos.core.auth.enable.userAgentAuthWhite</td><td>Nacos Server使用UserAgent来进行Server节点之间通信的识别，在1.4.1版本后仅作为升级时的兼容，开启后会存在安全问题，后续版本将移除该参数</td><td>true&#x2F;false</td><td>false</td></tr></tbody></table><p>同时对于Nacos默认鉴权插件的使用及更多默认鉴权插件的配置项，请参考<a href="https://nacos.io/docs/latest/guide/user/auth/#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0">权限校验</a></p><h4 id="1-8-2-数据源插件"><a href="#1-8-2-数据源插件" class="headerlink" title="1.8.2. 数据源插件"></a>1.8.2. 数据源插件</h4><p>其他和数据库相关的开发，请参考<a href="#112-%E6%95%B0%E6%8D%AE%E5%BA%93">全局参数-数据库</a></p><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>spring.sql.init.platform</td><td>Nacos Server 使用的数据库类型</td><td>mysql&#x2F;空，指定为空时会根据<code>nacos.standalone</code>判断使用derby数据库还是mysql数据库；在使用<a href="https://nacos.io/docs/latest/plugin/datasource-plugin/">数据源插件</a>时，可以指定为插件对应的数据库值，比如oracle或postgresql</td><td>null</td></tr><tr><td>nacos.plugin.datasource.log.enabled｜Nacos Server 是否开启SQL日志打印，开启后会打印每一次执行的SQL，方便进行插件开发时的问题排查，但是较为损耗性能，日常状态建议关闭</td><td>true&#x2F;false</td><td>false</td><td></td></tr></tbody></table><h4 id="1-8-3-环境变量插件"><a href="#1-8-3-环境变量插件" class="headerlink" title="1.8.3. 环境变量插件"></a>1.8.3. 环境变量插件</h4><p>关于如何开发环境变量插件，请参考<a href="https://nacos.io/docs/latest/plugin/custom-environment-plugin/">环境变量插件</a></p><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.custom.environment.enabled</td><td>Nacos Server 是否开启环境变量插件</td><td>true&#x2F;false</td><td>false</td></tr></tbody></table><h4 id="1-8-4-反脆弱插件"><a href="#1-8-4-反脆弱插件" class="headerlink" title="1.8.4. 反脆弱插件"></a>1.8.4. 反脆弱插件</h4><p>反脆弱插件的开发，请参考<a href="https://nacos.io/docs/latest/plugin/control-plugin/">反脆弱插件</a></p><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.plugin.control.manager.type</td><td>Nacos反脆弱插件的类型</td><td>nacos&#x2F;其他自定义插件类型</td><td>null</td></tr><tr><td>nacos.plugin.control.rule.external.storage</td><td>Nacos反脆弱插件，反脆弱规则外部存储类型，需要自行实现</td><td>字符串</td><td>null</td></tr><tr><td>nacos.plugin.control.rule.local.basedir</td><td>Nacos反脆弱插件，反脆弱规则本地存储目录</td><td>文件路径</td><td>${nacos.home}&#x2F;data&#x2F;</td></tr></tbody></table><h4 id="1-8-5-配置变更插件"><a href="#1-8-5-配置变更插件" class="headerlink" title="1.8.5. 配置变更插件"></a>1.8.5. 配置变更插件</h4><p>反脆弱插件的开发，请参考<a href="https://nacos.io/docs/latest/plugin/config-change-plugin/">配置变更插件</a></p><table><thead><tr><th>参数名</th><th>含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>nacos.core.config.plugin.${configChangePluginName}.enabled&#x3D;true</td><td>Nacos Server 是否开启配置变更插件</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>nacos.core.config.plugin.${configChangePluginName}.${propertyKey}&#x3D;${propertyValue}</td><td>配置变更插件的配置项</td><td>插件自定义</td><td>插件自定义</td></tr></tbody></table><h2 id="2-镜像环境变量"><a href="#2-镜像环境变量" class="headerlink" title="2. 镜像环境变量"></a>2. 镜像环境变量</h2><p>属性配置列表</p><table><thead><tr><th>属性名称</th><th>描述</th><th>选项</th></tr></thead><tbody><tr><td>MODE</td><td>系统启动方式: 集群&#x2F;单机，对应<code>nacos.standalone</code></td><td>cluster&#x2F;standalone 默认 <strong>cluster</strong></td></tr><tr><td>NACOS_SERVERS</td><td>集群地址，对应<code>nacos.member.list</code></td><td>p1空格ip2 空格ip3</td></tr><tr><td>PREFER_HOST_MODE</td><td>支持IP还是域名模式，对应<code>nacos.inetutils.prefer-hostname-over-ip</code></td><td>hostname&#x2F;ip 默认<strong>IP</strong></td></tr><tr><td>NACOS_SERVER_PORT</td><td>Nacos 运行端口，对应<code>server.port</code></td><td>默认<strong>8848</strong></td></tr><tr><td>NACOS_SERVER_IP</td><td>多网卡模式下可以指定IP，对应<code>nacos.server.ip</code></td><td></td></tr><tr><td>SPRING_DATASOURCE_PLATFORM</td><td>单机模式下支持MYSQL数据库，对应<code>spring.sql.init.platform</code></td><td>mysql &#x2F; 空 默认:空</td></tr><tr><td>MYSQL_SERVICE_HOST</td><td>数据库 连接地址</td><td></td></tr><tr><td>MYSQL_SERVICE_PORT</td><td>数据库端口</td><td>默认 : <strong>3306</strong></td></tr><tr><td>MYSQL_SERVICE_DB_NAME</td><td>数据库库名</td><td></td></tr><tr><td>MYSQL_SERVICE_USER</td><td>数据库用户名</td><td></td></tr><tr><td>MYSQL_SERVICE_PASSWORD</td><td>数据库用户密码</td><td></td></tr><tr><td>MYSQL_SERVICE_DB_PARAM</td><td>数据库连接参数</td><td>默认:<strong>characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;useSSL&#x3D;false</strong></td></tr><tr><td>MYSQL_DATABASE_NUM</td><td>数据库个数</td><td>默认:<strong>1</strong></td></tr><tr><td>JVM_XMS</td><td>-Xms</td><td>默认 :1g</td></tr><tr><td>JVM_XMX</td><td>-Xmx</td><td>默认 :1g</td></tr><tr><td>JVM_XMN</td><td>-Xmn</td><td>512m</td></tr><tr><td>JVM_MS</td><td>- XX</td><td>默认 :128m</td></tr><tr><td>JVM_MMS</td><td>-XX</td><td>默认 :320m</td></tr><tr><td>NACOS_DEBUG</td><td>是否开启远程DEBUG</td><td>y&#x2F;n 默认</td></tr><tr><td>TOMCAT_ACCESSLOG_ENABLED</td><td><code>server.tomcat.accesslog.enabled</code></td><td>默认</td></tr><tr><td>NACOS_AUTH_SYSTEM_TYPE</td><td>权限系统类型选择,目前只支持nacos类型</td><td>默认</td></tr><tr><td>NACOS_AUTH_ENABLE</td><td>是否开启权限系统，对应<code>nacos.core.auth.enabled</code></td><td>默认</td></tr><tr><td>NACOS_AUTH_TOKEN_EXPIRE_SECONDS</td><td>token 失效时间</td><td>默认 :18000</td></tr><tr><td>NACOS_AUTH_TOKEN</td><td>token</td><td><code>注意：该环境变量的默认值在Nacos 2.2.1版本中已移除，开启鉴权时需要指定</code></td></tr><tr><td>NACOS_AUTH_CACHE_ENABLE</td><td>权限缓存开关 ,开启后权限缓存的更新默认有15秒的延迟</td><td>默认 : false</td></tr><tr><td>MEMBER_LIST</td><td>通过环境变量的方式设置集群地址</td><td>例子:192.168.16.101:8847?raft_port&#x3D;8807,192.168.16.101?raft_port&#x3D;8808,192.168.16.101:8849?raft_port&#x3D;8809</td></tr><tr><td>EMBEDDED_STORAGE</td><td>是否开启集群嵌入式存储模式</td><td><code>embedded</code> 默认 : none</td></tr><tr><td>NACOS_AUTH_CACHE_ENABLE</td><td>nacos.core.auth.caching.enabled</td><td>default : false</td></tr><tr><td>NACOS_AUTH_USER_AGENT_AUTH_WHITE_ENABLE</td><td>nacos.core.auth.enable.userAgentAuthWhite</td><td>default : false</td></tr><tr><td>NACOS_AUTH_IDENTITY_KEY</td><td>nacos.core.auth.server.identity.key</td><td><code>注意：该环境变量的默认值在Nacos 2.2.1版本中已移除，开启鉴权时需要指定</code></td></tr><tr><td>NACOS_AUTH_IDENTITY_VALUE</td><td>nacos.core.auth.server.identity.value</td><td><code>注意：该环境变量的默认值在Nacos 2.2.1版本中已移除，开启鉴权时需要指定</code></td></tr><tr><td>NACOS_SECURITY_IGNORE_URLS</td><td>nacos.security.ignore.urls</td><td>default : <code>/,/error,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/**,/v1/console/health/**,/actuator/**,/v1/console/server/**</code></td></tr><tr><td>DB_POOL_CONNECTION_TIMEOUT</td><td>数据库连接池超时时间，单位为毫秒</td><td>默认 : <strong>30000</strong></td></tr><tr><td>NACOS_CONSOLE_UI_ENABLED</td><td>nacos.console.ui.enabled</td><td>default : <code>true</code></td></tr><tr><td>NACOS_CORE_PARAM_CHECK_ENABLED</td><td>nacos.core.param.check.enabled</td><td>default : <code>true</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>知识梳理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos运维API</title>
    <link href="/2025/02/13/nacos%E8%BF%90%E7%BB%B4api/"/>
    <url>/2025/02/13/nacos%E8%BF%90%E7%BB%B4api/</url>
    
    <content type="html"><![CDATA[<p>Nacos默认搭载了一整套专为管理控制台和运维人员设计的运维API，赋予运维专家更多的配置权限、更广阔的数据检索能力等。这些API为Nacos的运维团队提供了方便，使他们能够高效地处理故障、排查问题，以确保系统的稳定运行。</p><h2 id="1-Nacos-Core-运维-API"><a href="#1-Nacos-Core-运维-API" class="headerlink" title="1 . Nacos Core 运维 API"></a>1 . Nacos Core 运维 API</h2><h3 id="1-1-获取当前节点连接"><a href="#1-1-获取当前节点连接" class="headerlink" title="1.1. 获取当前节点连接"></a>1.1. 获取当前节点连接</h3><h4 id="接口描述"><a href="#接口描述" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以获取连接到当前Nacos Server节点中的gRPC连接详情。</p><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>GET</code></p><h4 id="请求URL"><a href="#请求URL" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/core/loader/current</code></p><h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>无</p><h4 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h4><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td>${connectionId}</td><td><code>jsonString</code></td><td>每条gRPC连接的连接id</td></tr><tr><td>${connectionId}.abilityTable</td><td><code>jsonString</code></td><td>该gRPC连接（即客户端）支持的能力列表</td></tr><tr><td>${connectionId}.metaInfo.clientIp</td><td><code>String</code></td><td>该gRPC连接的来源IP</td></tr><tr><td>${connectionId}.metaInfo.localPort</td><td><code>int</code></td><td>该Nacos Server的gRPC端口</td></tr><tr><td>${connectionId}.metaInfo.version</td><td><code>String</code></td><td>该gRPC连接（即客户端）的版本</td></tr><tr><td>${connectionId}.metaInfo.createTime</td><td><code>String</code></td><td>该gRPC连接的连接时间</td></tr><tr><td>${connectionId}.metaInfo.lastActiveTime</td><td><code>timestamp</code></td><td>该gRPC连接的最后一次的心跳时间</td></tr><tr><td>${connectionId}.metaInfo.labels.source</td><td><code>String</code></td><td>该gRPC连接的模块，可选值为<code>naming</code>,<code>config</code>和<code>cluster</code>分别代表注册中心、配置中心以及集群间的连接</td></tr><tr><td>${connectionId}.metaInfo.clusterSource</td><td><code>boolean</code></td><td>该gRPC连接的是否为集群间连接，为<code>true</code>时，<code>$&#123;connectionId&#125;.metaInfo.labels.source</code>为 <code>cluster</code></td></tr><tr><td>${connectionId}.metaInfo.sdkSource</td><td><code>boolean</code></td><td>该gRPC连接的是否为客户端来源连接，为<code>true</code>时，<code>$&#123;connectionId&#125;.metaInfo.labels.source</code>为 <code>naming</code>或<code>config</code></td></tr></tbody></table><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://127.0.0.1:8848/nacos/v2/core/loader/current&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;1709273546779_127.0.0.1_35042&quot;: &#123;    &quot;traced&quot;: false,    &quot;abilityTable&quot;: &#123;&#125;,    &quot;metaInfo&quot;: &#123;      &quot;connectType&quot;: &quot;GRPC&quot;,      &quot;clientIp&quot;: &quot;127.0.0.1&quot;,      &quot;localPort&quot;: 9849,      &quot;version&quot;: &quot;Nacos-Java-Client:v2.4.2&quot;,      &quot;connectionId&quot;: &quot;1709273546779_127.0.0.1_35042&quot;,      &quot;createTime&quot;: &quot;2024-03-01T14:12:26.800+08:00&quot;,      &quot;lastActiveTime&quot;: 1710754816373,      &quot;appName&quot;: &quot;-&quot;,      &quot;tenant&quot;: null,      &quot;labels&quot;: &#123;        &quot;source&quot;: &quot;naming&quot;,        &quot;tls.enable&quot;: &quot;false&quot;      &#125;,      &quot;tag&quot;: null,      &quot;clusterSource&quot;: false,      &quot;sdkSource&quot;: true    &#125;,    &quot;connected&quot;: true,    &quot;labels&quot;: &#123;      &quot;source&quot;: &quot;naming&quot;,      &quot;tls.enable&quot;: &quot;false&quot;    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-均衡指定数量的连接"><a href="#1-2-均衡指定数量的连接" class="headerlink" title="1.2. 均衡指定数量的连接"></a>1.2. 均衡指定数量的连接</h3><h4 id="接口描述-1"><a href="#接口描述-1" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以指定一定数量的连接到当前Nacos Server节点中的gRPC连接，将这部分连接断开后迁移到其他Nacos Server节点中。</p><h4 id="请求方式-1"><a href="#请求方式-1" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>GET</code></p><h4 id="请求URL-1"><a href="#请求URL-1" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/core/loader/reloadCurrent</code></p><h4 id="请求参数-1"><a href="#请求参数-1" class="headerlink" title="请求参数"></a>请求参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>参数描述</th></tr></thead><tbody><tr><td><code>count</code></td><td><code>Integer</code></td><td><strong>是</strong></td><td>需要均衡的连接个数</td></tr><tr><td><code>redirectAddress</code></td><td><code>String</code></td><td>否</td><td>预期均衡的Nacos Server目标，仅提供给客户端参考。</td></tr></tbody></table><h4 id="返回数据-1"><a href="#返回数据-1" class="headerlink" title="返回数据"></a>返回数据</h4><p>成功则返回<code>success</code>，失败则返回<a href="https://nacos.io/docs/latest/manual/user/open-api/#11-api-%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BD%93%E6%A0%BC%E5%BC%8F">Nacos open API 统一返回体格式</a></p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://127.0.0.1:8848/nacos/v2/core/loader/reloadCurrent?count=100&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><h3 id="1-3-均衡指定的单个连接"><a href="#1-3-均衡指定的单个连接" class="headerlink" title="1.3. 均衡指定的单个连接"></a>1.3. 均衡指定的单个连接</h3><h4 id="接口描述-2"><a href="#接口描述-2" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以指定某一条的连接到当前Nacos Server节点中的gRPC连接，将该连接断开后迁移到其他Nacos Server节点中。</p><h4 id="请求方式-2"><a href="#请求方式-2" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>GET</code></p><h4 id="请求URL-2"><a href="#请求URL-2" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/core/loader/reloadClient</code></p><h4 id="请求参数-2"><a href="#请求参数-2" class="headerlink" title="请求参数"></a>请求参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>参数描述</th></tr></thead><tbody><tr><td><code>connectionId</code></td><td><code>String</code></td><td><strong>是</strong></td><td>需要均衡的连接Id</td></tr><tr><td><code>redirectAddress</code></td><td><code>String</code></td><td>否</td><td>预期均衡的Nacos Server目标，仅提供给客户端参考。</td></tr></tbody></table><h4 id="返回数据-2"><a href="#返回数据-2" class="headerlink" title="返回数据"></a>返回数据</h4><p>成功则返回<code>success</code>，失败则返回<a href="https://nacos.io/docs/latest/manual/user/open-api/#11-api-%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BD%93%E6%A0%BC%E5%BC%8F">Nacos open API 统一返回体格式</a></p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://127.0.0.1:8848/nacos/v2/core/loader/reloadClient?connectionId=1709273546779_127.0.0.1_35042&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><h3 id="1-4-获取集群连接概览信息"><a href="#1-4-获取集群连接概览信息" class="headerlink" title="1.4. 获取集群连接概览信息"></a>1.4. 获取集群连接概览信息</h3><h4 id="接口描述-3"><a href="#接口描述-3" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，查看Nacos Server集群中各节点的连接数概览。</p><h4 id="请求方式-3"><a href="#请求方式-3" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>GET</code></p><h4 id="请求URL-3"><a href="#请求URL-3" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/core/loader/cluster</code></p><h4 id="请求参数-3"><a href="#请求参数-3" class="headerlink" title="请求参数"></a>请求参数</h4><p>无</p><h4 id="返回数据-3"><a href="#返回数据-3" class="headerlink" title="返回数据"></a>返回数据</h4><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td><code>total</code></td><td><code>Integer</code></td><td>该集群中所有节点的连接数总和</td></tr><tr><td><code>min</code></td><td><code>Integer</code></td><td>该集群中所有节点的最小连接数</td></tr><tr><td><code>avg</code></td><td><code>Integer</code></td><td>该集群中所有节点的平均连接数</td></tr><tr><td><code>max</code></td><td><code>Integer</code></td><td>该集群中所有节点的最大连接数</td></tr><tr><td><code>memberCount</code></td><td><code>Integer</code></td><td>该集群中所有节点的个数</td></tr><tr><td><code>metricsCount</code></td><td><code>Integer</code></td><td>该集群中已统计到概览信息的节点个数</td></tr><tr><td><code>detail</code></td><td><code>jsonArray</code></td><td>该集群中所有节点的概览信息，格式见下表</td></tr><tr><td><code>detail[].address</code></td><td><code>String</code></td><td>节点地址</td></tr><tr><td><code>detail[].metric.load</code></td><td><code>Double</code></td><td>节点的负载率，主要对应节点的Load指标，参考值</td></tr><tr><td><code>detail[].metric.sdkConCount</code></td><td><code>Integer</code></td><td>连接到该节点的SDK连接数，主要对应客户端连接数</td></tr><tr><td><code>detail[].metric.conCount</code></td><td><code>Integer</code></td><td>连接到该节点的总连接数，包含了SDK和集群间的连接</td></tr><tr><td><code>detail[].metric.cpu</code></td><td><code>Double</code></td><td>节点的CPU使用率，参考值</td></tr></tbody></table><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://127.0.0.1:8848/nacos/v2/core/loader/cluster&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;total&quot;: 0,  &quot;min&quot;: 0,  &quot;avg&quot;: 0,  &quot;max&quot;: 0,  &quot;memberCount&quot;: 3,  &quot;metricsCount&quot;: 3,  &quot;threshold&quot;: 0.0,  &quot;detail&quot;: [&#123;    &quot;address&quot;: &quot;nacos-node1:8848&quot;,    &quot;metric&quot;: &#123;      &quot;load&quot;: &quot;0.0&quot;,      &quot;sdkConCount&quot;: &quot;0&quot;,      &quot;cpu&quot;: &quot;0.0&quot;,      &quot;conCount&quot;: &quot;2&quot;    &#125;  &#125;, &#123;    &quot;address&quot;: &quot;nacos-node2:8848&quot;,    &quot;metric&quot;: &#123;      &quot;load&quot;: &quot;0.03&quot;,      &quot;sdkConCount&quot;: &quot;0&quot;,      &quot;cpu&quot;: &quot;-1.0&quot;,      &quot;conCount&quot;: &quot;2&quot;    &#125;  &#125;, &#123;    &quot;address&quot;: &quot;nacos-node3:8848&quot;,    &quot;metric&quot;: &#123;      &quot;load&quot;: &quot;0.0&quot;,      &quot;sdkConCount&quot;: &quot;0&quot;,      &quot;cpu&quot;: &quot;-1.0&quot;,      &quot;conCount&quot;: &quot;2&quot;    &#125;  &#125;],  &quot;completed&quot;: true&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-获取本节点信息"><a href="#1-5-获取本节点信息" class="headerlink" title="1.5. 获取本节点信息"></a>1.5. 获取本节点信息</h3><h4 id="接口描述-4"><a href="#接口描述-4" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以获取Nacos Server集群当前节点的详细信息。</p><h4 id="请求方式-4"><a href="#请求方式-4" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>GET</code></p><h4 id="请求URL-4"><a href="#请求URL-4" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/core/cluster/node/self</code></p><h4 id="请求参数-4"><a href="#请求参数-4" class="headerlink" title="请求参数"></a>请求参数</h4><p>无</p><h4 id="返回数据-4"><a href="#返回数据-4" class="headerlink" title="返回数据"></a>返回数据</h4><p>返回体遵循<a href="https://nacos.io/docs/latest/manual/user/open-api/#11-api-%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BD%93%E6%A0%BC%E5%BC%8F">Nacos open API 统一返回体格式</a>，下表只阐述<code>data</code>字段中的返回参数。</p><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td><code>ip</code></td><td><code>String</code></td><td>节点IP</td></tr><tr><td><code>port</code></td><td><code>Integer</code></td><td>节点端口</td></tr><tr><td><code>state</code></td><td><code>String</code></td><td>节点状态，可选值为<code>UP</code>、<code>DOWN</code>、<code>SUSPICIOUS</code></td></tr><tr><td><code>extendInfo</code></td><td><code>jsonObject</code></td><td>节点扩展信息，具体字段见下表</td></tr><tr><td><code>extendInfo.lastRefreshTime</code></td><td><code>Long</code></td><td>节点上一次更新时间戳，单位毫秒</td></tr><tr><td><code>extendInfo.raftMetaData</code></td><td><code>jsonObject</code></td><td>节点的Raft元数据， 包含每个Raft Group的 <code>leader</code>， <code>term</code>等字段</td></tr><tr><td><code>extendInfo.raftPort</code></td><td><code>Integer</code></td><td>节点的Raft端口</td></tr><tr><td><code>extendInfo.version</code></td><td><code>String</code></td><td>节点的版本</td></tr><tr><td><code>address</code></td><td><code>String</code></td><td>节点地址，格式为<code>ip:port</code></td></tr><tr><td><code>abilities</code></td><td><code>jsonObject</code></td><td>该节点所支持的能力</td></tr><tr><td>extendInfo.readyToUpgrade</td><td><code>Boolean</code></td><td>是否ready升级到Nacos2.0，于2.2版本后废弃，即将移除</td></tr></tbody></table><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://127.0.0.1:8848/nacos/v2/core/cluster/node/self&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;code&quot;: 0,  &quot;message&quot;: &quot;success&quot;,  &quot;data&quot;: &#123;    &quot;ip&quot;: &quot;nacos-node-0&quot;,    &quot;port&quot;: 8848,    &quot;state&quot;: &quot;UP&quot;,    &quot;extendInfo&quot;: &#123;      &quot;lastRefreshTime&quot;: 1709273550501,      &quot;raftMetaData&quot;: &#123;        &quot;metaDataMap&quot;: &#123;          &quot;naming_instance_metadata&quot;: &#123;            &quot;leader&quot;: &quot;nacos-node-2:7848&quot;,            &quot;raftGroupMember&quot;: [&quot;nacos-node-2:7848&quot;, &quot;nacos-node-1:7848&quot;, &quot;nacos-node-0:7848&quot;],            &quot;term&quot;: 3          &#125;,          &quot;naming_persistent_service&quot;: &#123;            &quot;leader&quot;: &quot;nacos-node-1:7848&quot;,            &quot;raftGroupMember&quot;: [&quot;nacos-node-2:7848&quot;, &quot;nacos-node-1:7848&quot;, &quot;nacos-node-0:7848&quot;],            &quot;term&quot;: 3          &#125;,          &quot;naming_persistent_service_v2&quot;: &#123;            &quot;leader&quot;: &quot;nacos-node-2:7848&quot;,            &quot;raftGroupMember&quot;: [&quot;nacos-node-2:7848&quot;, &quot;nacos-node-1:7848&quot;, &quot;nacos-node-0:7848&quot;],            &quot;term&quot;: 2          &#125;,          &quot;naming_service_metadata&quot;: &#123;            &quot;leader&quot;: &quot;nacos-node-2:7848&quot;,            &quot;raftGroupMember&quot;: [&quot;nacos-node-2:7848&quot;, &quot;nacos-node-1:7848&quot;, &quot;nacos-node-0:7848&quot;],            &quot;term&quot;: 3          &#125;        &#125;      &#125;,      &quot;raftPort&quot;: &quot;7848&quot;,      &quot;readyToUpgrade&quot;: true,      &quot;version&quot;: &quot;2.4.2&quot;    &#125;,    &quot;address&quot;: &quot;nacos-node-0:8848&quot;,    &quot;failAccessCnt&quot;: 0,    &quot;abilities&quot;: &#123;      &quot;remoteAbility&quot;: &#123;        &quot;supportRemoteConnection&quot;: true,        &quot;grpcReportEnabled&quot;: true      &#125;,      &quot;configAbility&quot;: &#123;        &quot;supportRemoteMetrics&quot;: false      &#125;,      &quot;namingAbility&quot;: &#123;        &quot;supportJraft&quot;: true      &#125;    &#125;,    &quot;grpcReportEnabled&quot;: true  &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-获取集群所有节点信息"><a href="#1-6-获取集群所有节点信息" class="headerlink" title="1.6. 获取集群所有节点信息"></a>1.6. 获取集群所有节点信息</h3><h4 id="接口描述-5"><a href="#接口描述-5" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以获取Nacos Server集群中所有节点的详细信息。</p><h4 id="请求方式-5"><a href="#请求方式-5" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>GET</code></p><h4 id="请求URL-5"><a href="#请求URL-5" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/core/cluster/node/list</code></p><h4 id="请求参数-5"><a href="#请求参数-5" class="headerlink" title="请求参数"></a>请求参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>参数描述</th></tr></thead><tbody><tr><td><code>address</code></td><td><code>String</code></td><td>否</td><td>过滤的节点地址，支持前缀匹配，不输入时返回所有节点信息</td></tr><tr><td><code>nodeState</code></td><td><code>String</code></td><td>否</td><td>返回的节点状态，可选值为<code>UP</code>、<code>DOWN</code>、<code>SUSPICIOUS</code>，不输入时返回所有节点信息</td></tr></tbody></table><h4 id="返回数据-5"><a href="#返回数据-5" class="headerlink" title="返回数据"></a>返回数据</h4><p>返回体遵循<a href="https://nacos.io/docs/latest/manual/user/open-api/#11-api-%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BD%93%E6%A0%BC%E5%BC%8F">Nacos open API 统一返回体格式</a>，<code>data</code>字段为<a href="#%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE-4">获取本节点信息</a>的返回数据的列表。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://127.0.0.1:8848/nacos/v2/core/cluster/node/list&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;code&quot;: 0,  &quot;message&quot;: &quot;success&quot;,  &quot;data&quot;: [&#123;    &quot;ip&quot;: &quot;nacos-node-0&quot;,    &quot;port&quot;: 8848,    &quot;state&quot;: &quot;UP&quot;,    &quot;extendInfo&quot;: &#123;      &quot;lastRefreshTime&quot;: 1709273550501,      &quot;raftMetaData&quot;: &#123;        &quot;metaDataMap&quot;: &#123;          &quot;naming_instance_metadata&quot;: &#123;            &quot;leader&quot;: &quot;nacos-node-2:7848&quot;,            &quot;raftGroupMember&quot;: [&quot;nacos-node-2:7848&quot;, &quot;nacos-node-1:7848&quot;, &quot;nacos-node-0:7848&quot;],            &quot;term&quot;: 3          &#125;,          &quot;naming_persistent_service&quot;: &#123;            &quot;leader&quot;: &quot;nacos-node-1:7848&quot;,            &quot;raftGroupMember&quot;: [&quot;nacos-node-2:7848&quot;, &quot;nacos-node-1:7848&quot;, &quot;nacos-node-0:7848&quot;],            &quot;term&quot;: 3          &#125;,          &quot;naming_persistent_service_v2&quot;: &#123;            &quot;leader&quot;: &quot;nacos-node-2:7848&quot;,            &quot;raftGroupMember&quot;: [&quot;nacos-node-2:7848&quot;, &quot;nacos-node-1:7848&quot;, &quot;nacos-node-0:7848&quot;],            &quot;term&quot;: 2          &#125;,          &quot;naming_service_metadata&quot;: &#123;            &quot;leader&quot;: &quot;nacos-node-2:7848&quot;,            &quot;raftGroupMember&quot;: [&quot;nacos-node-2:7848&quot;, &quot;nacos-node-1:7848&quot;, &quot;nacos-node-0:7848&quot;],            &quot;term&quot;: 3          &#125;        &#125;      &#125;,      &quot;raftPort&quot;: &quot;7848&quot;,      &quot;readyToUpgrade&quot;: true,      &quot;version&quot;: &quot;2.4.2&quot;    &#125;,    &quot;address&quot;: &quot;nacos-node-0:8848&quot;,    &quot;failAccessCnt&quot;: 0,    &quot;abilities&quot;: &#123;      &quot;remoteAbility&quot;: &#123;        &quot;supportRemoteConnection&quot;: true,        &quot;grpcReportEnabled&quot;: true      &#125;,      &quot;configAbility&quot;: &#123;        &quot;supportRemoteMetrics&quot;: false      &#125;,      &quot;namingAbility&quot;: &#123;        &quot;supportJraft&quot;: true      &#125;    &#125;,    &quot;grpcReportEnabled&quot;: true  &#125;, &#123;    &quot;ip&quot;: &quot;nacos-node-2&quot;,    &quot;port&quot;: 8848,    &quot;state&quot;: &quot;UP&quot;,    &quot;extendInfo&quot;: &#123;      &quot;lastRefreshTime&quot;: 1710813796567,      &quot;raftMetaData&quot;: &#123;        ....      &#125;,      ....    &#125;,    ....  &#125;, &#123;    &quot;ip&quot;: &quot;nacos-node-1&quot;,    &quot;port&quot;: 8848,    &quot;state&quot;: &quot;UP&quot;,    &quot;extendInfo&quot;: &#123;      &quot;lastRefreshTime&quot;: 1710813796567,      &quot;raftMetaData&quot;: &#123;        ....      &#125;,      ....    &#125;,    ....  &#125;]&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-快速查询本节点健康状态"><a href="#1-7-快速查询本节点健康状态" class="headerlink" title="1.7. 快速查询本节点健康状态"></a>1.7. 快速查询本节点健康状态</h3><h4 id="接口描述-6"><a href="#接口描述-6" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以快速查询本节点健康状态。</p><h4 id="请求方式-6"><a href="#请求方式-6" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>GET</code></p><h4 id="请求URL-6"><a href="#请求URL-6" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/core/cluster/node/self/health</code></p><h4 id="请求参数-6"><a href="#请求参数-6" class="headerlink" title="请求参数"></a>请求参数</h4><p>无</p><h4 id="返回数据-6"><a href="#返回数据-6" class="headerlink" title="返回数据"></a>返回数据</h4><p>返回体遵循<a href="https://nacos.io/docs/latest/manual/user/open-api/#11-api-%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BD%93%E6%A0%BC%E5%BC%8F">Nacos open API 统一返回体格式</a>。</p><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td><code>data</code></td><td><code>String</code></td><td><code>UP</code>表示节点健康，<code>DOWN</code>表示节点不健康，<code>SUSPICIOUS</code>表示节点疑似不健康</td></tr></tbody></table><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://127.0.0.1:8848/nacos/v2/core/cluster/node/list&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;code&quot;: 0,  &quot;message&quot;: &quot;success&quot;,  &quot;data&quot;: &quot;UP&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-动态修改Server集群地址发现方式"><a href="#1-8-动态修改Server集群地址发现方式" class="headerlink" title="1.8. 动态修改Server集群地址发现方式"></a>1.8. 动态修改Server集群地址发现方式</h3><h4 id="接口描述-7"><a href="#接口描述-7" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以在不重启Nacos Server的情况下，动态切换Nacos Server集群地址发现的方式，目前支持两种方式：<code>file</code>和<code>address-server</code>。</p><h4 id="请求方式-7"><a href="#请求方式-7" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>PUT</code></p><h4 id="请求URL-7"><a href="#请求URL-7" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/core/cluster/lookup</code></p><h4 id="请求参数-7"><a href="#请求参数-7" class="headerlink" title="请求参数"></a>请求参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>参数描述</th></tr></thead><tbody><tr><td><code>type</code></td><td><code>String</code></td><td>是</td><td>切换到的地址发现方式，可选值为<code>file</code>和<code>address-server</code></td></tr></tbody></table><h4 id="返回数据-7"><a href="#返回数据-7" class="headerlink" title="返回数据"></a>返回数据</h4><p>返回体遵循<a href="https://nacos.io/docs/latest/manual/user/open-api/#11-api-%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BD%93%E6%A0%BC%E5%BC%8F">Nacos open API 统一返回体格式</a>。</p><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td><code>data</code></td><td><code>Boolean</code></td><td><code>true</code>表示更新成功，<code>false</code>表示更新失败。</td></tr></tbody></table><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT &#x27;http://127.0.0.1:8848/nacos/v2/core/cluster/lookup?type=file&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;code&quot;: 0,  &quot;message&quot;: &quot;success&quot;,  &quot;data&quot;: true&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-Raft-相关操作"><a href="#1-9-Raft-相关操作" class="headerlink" title="1.9. Raft 相关操作"></a>1.9. Raft 相关操作</h3><h4 id="接口描述-8"><a href="#接口描述-8" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以对Nacos Server集群中的Raft协议进行部分运维操作，如执行快照，主动选主等。</p><h4 id="请求方式-8"><a href="#请求方式-8" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>POST</code></p><h4 id="请求URL-8"><a href="#请求URL-8" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/core/ops/raft</code></p><h4 id="请求参数-8"><a href="#请求参数-8" class="headerlink" title="请求参数"></a>请求参数</h4><p>该API需要以Json的方式，将请求参数放在请求体中，请求体格式如下：</p><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>参数描述</th></tr></thead><tbody><tr><td><code>command</code></td><td><code>String</code></td><td><strong>是</strong></td><td>Raft运维操作指令，具体的命令请参考下表。</td></tr><tr><td><code>value</code></td><td><code>String</code></td><td><strong>是</strong></td><td>命令的参数，具体的命令内容请参考下表。</td></tr><tr><td><code>groupId</code></td><td><code>String</code></td><td>否</td><td>Raft集群的groupId，如果不输入则对所有Raft Group生效</td></tr></tbody></table><table><thead><tr><th>command</th><th>value</th><th>说明</th></tr></thead><tbody><tr><td><code>doSnapshot</code></td><td><code>$&#123;nacos-server-address&#125;:$&#123;raft-port&#125;</code></td><td>执行快照，参数为要执行快照的节点地址。</td></tr><tr><td><code>transferLeader</code></td><td><code>$&#123;nacos-server-address&#125;:$&#123;raft-port&#125;</code></td><td>主动选主，参数为要期望的Leader的节点地址。</td></tr><tr><td><code>restRaftCluster</code></td><td><code>$&#123;nacos-server-address&#125;:$&#123;raft-port&#125;[,$&#123;nacos-server-address&#125;:$&#123;raft-port&#125;]</code></td><td>重置集群状态，参数为要重置节点地址列表，’,‘分割。</td></tr><tr><td><code>removePeer</code></td><td><code>$&#123;nacos-server-address&#125;:$&#123;raft-port&#125;</code></td><td>移除Raft Member节点，参数为要移除的节点地址。</td></tr><tr><td><code>removePeers</code></td><td><code>$&#123;nacos-server-address&#125;:$&#123;raft-port&#125;[,$&#123;nacos-server-address&#125;:$&#123;raft-port&#125;]</code></td><td>批量移除Raft Member节点，参数为要批量移除的节点地址列表，’,‘分割。</td></tr><tr><td><code>changePeers</code></td><td><code>$&#123;nacos-server-address&#125;:$&#123;raft-port&#125;[,$&#123;nacos-server-address&#125;:$&#123;raft-port&#125;]</code></td><td>修改Raft Member节点，参数为要修改后的节点地址列表，’,‘分割。</td></tr></tbody></table><h4 id="返回数据-8"><a href="#返回数据-8" class="headerlink" title="返回数据"></a>返回数据</h4><p>返回体遵循<a href="https://nacos.io/docs/latest/manual/user/open-api/#11-api-%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BD%93%E6%A0%BC%E5%BC%8F">Nacos open API 统一返回体格式</a>。</p><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td><code>data</code></td><td><code>String</code></td><td>固定为<code>null</code>。</td></tr></tbody></table><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H &#x27;Content-Type:application/json&#x27; &#x27;http://127.0.0.1:8848/nacos/v2/core/ops/raft&#x27; -d &#x27;&#123;&quot;command&quot;:&quot;doSnapshot&quot;,&quot;value&quot;:&quot;nacos-node-0:7848&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;code&quot;: 200,  &quot;message&quot;: null,  &quot;data&quot;: null&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-动态修改Nacos-Core相关日志级别"><a href="#1-10-动态修改Nacos-Core相关日志级别" class="headerlink" title="1.10. 动态修改Nacos Core相关日志级别"></a>1.10. 动态修改Nacos Core相关日志级别</h3><h4 id="接口描述-9"><a href="#接口描述-9" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以在不重启Nacos Server的情况下，动态修改Nacos Core相关日志级别的配置。</p><h4 id="请求方式-9"><a href="#请求方式-9" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>PUT</code></p><h4 id="请求URL-9"><a href="#请求URL-9" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/core/ops/log</code></p><h4 id="请求参数-9"><a href="#请求参数-9" class="headerlink" title="请求参数"></a>请求参数</h4><p>该API需要以Json的方式，将请求参数放在请求体中，请求体格式如下：</p><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>参数描述</th></tr></thead><tbody><tr><td><code>logName</code></td><td><code>String</code></td><td><strong>是</strong></td><td>具体的日志文件的名称，具体支持的日志名称见下表。</td></tr><tr><td><code>logLevel</code></td><td><code>String</code></td><td><strong>是</strong></td><td>日志的级别，可选值为<code>ALL</code>、<code>TRACE</code>、<code>DEBUG</code>、<code>INFO</code>、<code>WARN</code>、<code>ERROR</code>、<code>OFF</code>。</td></tr></tbody></table><table><thead><tr><th>logName</th><th>对应的具体日志文件</th></tr></thead><tbody><tr><td><code>core-auth</code></td><td><code>core-auth.log</code></td></tr><tr><td><code>core-raft</code></td><td><code>protocol-raft.log</code></td></tr><tr><td><code>core-distro</code></td><td><code>protocol-distro.log</code></td></tr><tr><td><code>core-cluster</code></td><td><code>nacos-cluster.log</code></td></tr></tbody></table><h4 id="返回数据-9"><a href="#返回数据-9" class="headerlink" title="返回数据"></a>返回数据</h4><p>返回体遵循<a href="https://nacos.io/docs/latest/manual/user/open-api/#11-api-%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BD%93%E6%A0%BC%E5%BC%8F">Nacos open API 统一返回体格式</a>。</p><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td><code>data</code></td><td><code>String</code></td><td>固定为<code>null</code>。</td></tr></tbody></table><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -H &#x27;Content-Type:application/json&#x27; &#x27;http://127.0.0.1:8848/nacos/v2/core/ops/log&#x27; -d &#x27;&#123;&quot;logName&quot;:&quot;core-distro&quot;,&quot;logLevel&quot;:&quot;DEBUG&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;code&quot;: 200,  &quot;message&quot;: null,  &quot;data&quot;: null&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Nacos-Naming-运维-API"><a href="#2-Nacos-Naming-运维-API" class="headerlink" title="2. Nacos Naming 运维 API"></a>2. Nacos Naming 运维 API</h2><h3 id="2-1-查看Naming模块的相关开关"><a href="#2-1-查看Naming模块的相关开关" class="headerlink" title="2.1. 查看Naming模块的相关开关"></a>2.1. 查看Naming模块的相关开关</h3><h4 id="接口描述-10"><a href="#接口描述-10" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以查看Nacos Naming模块的相关开关。</p><h4 id="请求方式-10"><a href="#请求方式-10" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>GET</code></p><h4 id="请求URL-10"><a href="#请求URL-10" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/ns/operator/switches</code> 或 <code>/nacos/v2/ns/ops/switches</code></p><h4 id="请求参数-10"><a href="#请求参数-10" class="headerlink" title="请求参数"></a>请求参数</h4><p>无</p><h4 id="返回数据-10"><a href="#返回数据-10" class="headerlink" title="返回数据"></a>返回数据</h4><p>返回体遵循<a href="https://nacos.io/docs/latest/manual/user/open-api/#11-api-%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BD%93%E6%A0%BC%E5%BC%8F">Nacos open API 统一返回体格式</a>，返回数据<code>data</code>字段为json格式，展示各个开关的和配置的具体内容：</p><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td><code>clientBeatInterval</code></td><td><code>int</code></td><td>Nacos1.X客户端的默认心跳间隔</td></tr><tr><td><code>defaultCacheMillis</code></td><td><code>int</code></td><td>客户端订阅的服务列表的默认缓存时间</td></tr><tr><td><code>defaultPushCacheMillis</code></td><td><code>int</code></td><td>推送的服务列表的默认缓存时间，优先级高于<code>defaultCacheMillis</code></td></tr><tr><td><code>distroEnabled</code></td><td><code>boolean</code></td><td>是否开启<code>Distro</code>协议同步，仅当集群压力过大，影响到集群稳定性时，临时修改为<code>false</code>缓解，改为<code>false</code>后可能导致部分数据不一致，需要尽快恢复</td></tr><tr><td><code>healthCheckEnabled</code></td><td><code>boolean</code></td><td>是否开启健康检查，仅当集群压力过大，影响到集群稳定性时，临时修改为<code>false</code>缓解，改为<code>false</code>后不会因为心跳过期，tcp&#x2F;http探测超时而修改实例的健康状态，以及不会因过期删除实例，需要尽快恢复</td></tr><tr><td><code>lightBeatEnabled</code></td><td><code>boolean</code></td><td>是否开启轻量心跳，针对Nacos<code>1.2.X~1.4.X版本</code>客户端生效，修改为<code>false</code>后，<code>Nacos1.2.X~1.4.X</code>版本客户端将使用全量心跳进行续约</td></tr><tr><td><code>pushEnabled</code></td><td><code>boolean</code></td><td>是否开启推送功能，仅当集群压力过大，影响到集群稳定性时，临时修改为<code>false</code>，改为<code>false</code>后，Nacos客户端将不再收到服务端的主动推送</td></tr><tr><td><code>push$&#123;Language&#125;Version</code></td><td><code>String</code></td><td>可支持推送的最小客户端版本，当不希望针对小于某些版本进行数据推送时，可以修改该值，比如修改pushJavaVersion为<code>2.0.0</code>，则小于2.0.0的Java客户端将不会收到推送数据</td></tr><tr><td><code>$&#123;type&#125;HealthParams</code></td><td><code>json</code></td><td>健康检查参数，设置健康检查的最大&#x2F;最小间隔，随机间隔系数等，健康检查时将根据这几个值进行下一次健康检查流量的打散。</td></tr></tbody></table><blockquote><p>注意： 其余未列出的参数，均为Nacos旧版本的开关或配置内容，已废弃或即将废弃，请谨慎使用。</p></blockquote><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://127.0.0.1:8848/nacos/v2/ns/ops/switches&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;    &quot;code&quot;: 0,    &quot;data&quot;: &#123;        &quot;adWeightMap&quot;: &#123;&#125;,        &quot;autoChangeHealthCheckEnabled&quot;: true,        &quot;checkTimes&quot;: 3,        &quot;checksum&quot;: null,        &quot;clientBeatInterval&quot;: 5000,        &quot;defaultCacheMillis&quot;: 3000,        &quot;defaultInstanceEphemeral&quot;: true,        &quot;defaultPushCacheMillis&quot;: 10000,        &quot;disableAddIP&quot;: false,        &quot;distroEnabled&quot;: true,        &quot;distroServerExpiredMillis&quot;: 10000,        &quot;distroThreshold&quot;: 0.7,        &quot;enableAuthentication&quot;: false,        &quot;enableStandalone&quot;: true,        &quot;healthCheckEnabled&quot;: true,        &quot;healthCheckWhiteList&quot;: [],        &quot;httpHealthParams&quot;: &#123;            &quot;factor&quot;: 0.85,            &quot;max&quot;: 5000,            &quot;min&quot;: 500        &#125;,        &quot;incrementalList&quot;: [],        &quot;lightBeatEnabled&quot;: true,        &quot;limitedUrlMap&quot;: &#123;&#125;,        &quot;masters&quot;: null,        &quot;mysqlHealthParams&quot;: &#123;            &quot;factor&quot;: 0.65,            &quot;max&quot;: 3000,            &quot;min&quot;: 2000        &#125;,        &quot;name&quot;: &quot;00-00---000-NACOS_SWITCH_DOMAIN-000---00-00&quot;,        &quot;overriddenServerStatus&quot;: null,        &quot;pushCSharpVersion&quot;: &quot;0.9.0&quot;,        &quot;pushCVersion&quot;: &quot;1.0.12&quot;,        &quot;pushEnabled&quot;: true,        &quot;pushGoVersion&quot;: &quot;0.1.0&quot;,        &quot;pushJavaVersion&quot;: &quot;0.1.0&quot;,        &quot;pushPythonVersion&quot;: &quot;0.4.3&quot;,        &quot;sendBeatOnly&quot;: false,        &quot;serverStatusSynchronizationPeriodMillis&quot;: 2000,        &quot;serviceStatusSynchronizationPeriodMillis&quot;: 5000,        &quot;tcpHealthParams&quot;: &#123;            &quot;factor&quot;: 0.75,            &quot;max&quot;: 5000,            &quot;min&quot;: 1000        &#125;    &#125;,    &quot;message&quot;: &quot;success&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-修改Naming模块的相关开关"><a href="#2-2-修改Naming模块的相关开关" class="headerlink" title="2.2. 修改Naming模块的相关开关"></a>2.2. 修改Naming模块的相关开关</h3><h4 id="接口描述-11"><a href="#接口描述-11" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以修改Nacos Naming模块的相关开关。</p><h4 id="请求方式-11"><a href="#请求方式-11" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>PUT</code></p><h4 id="请求URL-11"><a href="#请求URL-11" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/ns/operator/switches</code> 或 <code>/nacos/v2/ns/ops/switches</code></p><h4 id="请求参数-11"><a href="#请求参数-11" class="headerlink" title="请求参数"></a>请求参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>参数描述</th></tr></thead><tbody><tr><td><code>entry</code></td><td><code>String</code></td><td><strong>是</strong></td><td>修改的开关或配置名称</td></tr><tr><td><code>value</code></td><td><code>Object</code></td><td><strong>是</strong></td><td>开关或配置的新值，不同的开关或配置的类型不同，具体请参考<a href="#%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE-10">开关和配置参数</a></td></tr><tr><td><code>debug</code></td><td><code>boolean</code></td><td>否</td><td>是否开启调试模式，开启后，修改的配置不会同步到集群其他节点中，仅在本节点生效，默认为<code>false</code></td></tr></tbody></table><h4 id="返回数据-11"><a href="#返回数据-11" class="headerlink" title="返回数据"></a>返回数据</h4><p>返回体遵循<a href="https://nacos.io/docs/latest/manual/user/open-api/#11-api-%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BD%93%E6%A0%BC%E5%BC%8F">Nacos open API 统一返回体格式</a>:</p><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td><code>data</code></td><td><code>String</code></td><td>成功为<code>ok</code>,否则为<code>null</code></td></tr></tbody></table><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT &#x27;http://127.0.0.1:8848/nacos/v2/ns/ops/switches?entry=pushEnabled&amp;value=false&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;code&quot;: 0,  &quot;message&quot;: &quot;success&quot;,  &quot;data&quot;: &quot;ok&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-查询系统当前数据指标"><a href="#2-3-查询系统当前数据指标" class="headerlink" title="2.3. 查询系统当前数据指标"></a>2.3. 查询系统当前数据指标</h3><h4 id="接口描述-12"><a href="#接口描述-12" class="headerlink" title="接口描述"></a>接口描述</h4><p>通过该接口，可以查询系统当前数据指标</p><h4 id="请求方式-12"><a href="#请求方式-12" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>GET</code></p><h4 id="请求URL-12"><a href="#请求URL-12" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/ns/operator/metrics</code> 或 <code>/nacos/v2/ns/ops/metrics</code></p><h4 id="请求参数-12"><a href="#请求参数-12" class="headerlink" title="请求参数"></a>请求参数</h4><table><thead><tr><th>参数名</th><th>参数类型</th><th>是否必填</th><th>描述说明</th></tr></thead><tbody><tr><td><code>onlyStatus</code></td><td><code>boolean</code></td><td>否</td><td>只显示状态，默认为<code>true</code></td></tr></tbody></table><blockquote><p>当<code>onlyStatus</code>设置为<code>true</code>时，只返回表示系统状态的字符串</p></blockquote><h4 id="返回数据-12"><a href="#返回数据-12" class="headerlink" title="返回数据"></a>返回数据</h4><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述说明</th></tr></thead><tbody><tr><td><code>data</code></td><td><code>Object</code></td><td>系统当前数据指标</td></tr><tr><td><code>data.status</code></td><td><code>String</code></td><td>系统状态</td></tr><tr><td><code>data.serviceCount</code></td><td><code>int</code></td><td>服务数量</td></tr><tr><td><code>data.instanceCount</code></td><td><code>int</code></td><td>实例数量</td></tr><tr><td><code>data.subscribeCount</code></td><td><code>int</code></td><td>订阅数量</td></tr><tr><td><code>data.raftNotifyTaskCount</code></td><td><code>int</code></td><td><code>Raft</code>通知任务数量</td></tr><tr><td><code>data.responsibleServiceCount</code></td><td><code>int</code></td><td></td></tr><tr><td><code>data.responsibleInstanceCount</code></td><td><code>int</code></td><td></td></tr><tr><td><code>data.clientCount</code></td><td><code>int</code></td><td>客户端数量</td></tr><tr><td><code>data.connectionBasedClientCount</code></td><td><code>int</code></td><td>连接数量</td></tr><tr><td><code>data.ephemeralIpPortClientCount</code></td><td><code>int</code></td><td>临时客户端数量</td></tr><tr><td><code>data.persistentIpPortClientCount</code></td><td><code>int</code></td><td>持久客户端数量</td></tr><tr><td><code>data.responsibleClientCount</code></td><td><code>int</code></td><td></td></tr><tr><td><code>data.cpu</code></td><td><code>float</code></td><td><code>cpu</code>使用率</td></tr><tr><td><code>data.load</code></td><td><code>float</code></td><td>负载</td></tr><tr><td><code>data.mem</code></td><td><code>float</code></td><td>内存使用率</td></tr></tbody></table><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><ul><li>请求示例</li></ul><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://127.0.0.1:8848/nacos/v2/ns/operator/metrics&#x27;</span><br></pre></td></tr></table></figure><ul><li>返回示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;    &quot;code&quot;: 0,    &quot;message&quot;: &quot;success&quot;,    &quot;data&quot;: &#123;        &quot;status&quot;: &quot;UP&quot;,        &quot;serviceCount&quot;: 2,        &quot;instanceCount&quot;: 2,        &quot;subscribeCount&quot;: 2,        &quot;raftNotifyTaskCount&quot;: 0,        &quot;responsibleServiceCount&quot;: 0,        &quot;responsibleInstanceCount&quot;: 0,        &quot;clientCount&quot;: 2,        &quot;connectionBasedClientCount&quot;: 2,        &quot;ephemeralIpPortClientCount&quot;: 0,        &quot;persistentIpPortClientCount&quot;: 0,        &quot;responsibleClientCount&quot;: 2,        &quot;cpu&quot;: 0,        &quot;load&quot;: -1,        &quot;mem&quot;: 1    &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Nacos-Config-运维-API"><a href="#3-Nacos-Config-运维-API" class="headerlink" title="3. Nacos Config 运维 API"></a>3. Nacos Config 运维 API</h2><h3 id="3-1-查询指定命名空间下的配置列表"><a href="#3-1-查询指定命名空间下的配置列表" class="headerlink" title="3.1. 查询指定命名空间下的配置列表"></a>3.1. 查询指定命名空间下的配置列表</h3><h4 id="接口描述-13"><a href="#接口描述-13" class="headerlink" title="接口描述"></a>接口描述</h4><p>获取指定命名空间下的配置信息列表</p><h4 id="请求方式-13"><a href="#请求方式-13" class="headerlink" title="请求方式"></a>请求方式</h4><p><code>GET</code></p><h4 id="请求URL-13"><a href="#请求URL-13" class="headerlink" title="请求URL"></a>请求URL</h4><p><code>/nacos/v2/cs/history/configs</code></p><h4 id="请求参数-13"><a href="#请求参数-13" class="headerlink" title="请求参数"></a>请求参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>参数描述</th></tr></thead><tbody><tr><td><code>namespaceId</code></td><td><code>String</code></td><td><strong>是</strong></td><td>命名空间</td></tr></tbody></table><h4 id="返回数据-13"><a href="#返回数据-13" class="headerlink" title="返回数据"></a>返回数据</h4><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述说明</th></tr></thead><tbody><tr><td><code>data</code></td><td><code>Object[]</code></td><td>配置信息列表</td></tr><tr><td><code>data.id</code></td><td><code>String</code></td><td>配置<code>id</code></td></tr><tr><td><code>data.dataId</code></td><td><code>String</code></td><td>配置名</td></tr><tr><td><code>data.group</code></td><td><code>String</code></td><td>配置分组</td></tr><tr><td><code>data.content</code></td><td><code>String</code></td><td>配置内容</td></tr><tr><td><code>data.md5</code></td><td><code>String</code></td><td>配置内容的md5值</td></tr><tr><td><code>data.encryptedDataKey</code></td><td><code>String</code></td><td></td></tr><tr><td><code>data.tenant</code></td><td><code>String</code></td><td>租户信息（命名空间）</td></tr><tr><td><code>data.appName</code></td><td><code>String</code></td><td>应用名</td></tr><tr><td><code>data.type</code></td><td><code>String</code></td><td>配置文件类型</td></tr><tr><td><code>data.lastModified</code></td><td><code>long</code></td><td>上次修改时间</td></tr></tbody></table><blockquote><p>返回数据中的配置信息只有<code>dataId</code>, <code>group</code>, <code>tenant</code>, <code>appName</code>, <code>type</code>字段有效，其他字段为默认值</p></blockquote><h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><ul><li><p>请求示例</p><p>Terminal window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://127.0.0.1:8848/nacos/v2/cs/history/configs?namespaceId=&#x27;</span><br></pre></td></tr></table></figure></li><li><p>返回示例</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;    &quot;code&quot;: 0,    &quot;message&quot;: &quot;success&quot;,    &quot;data&quot;: [        &#123;            &quot;id&quot;: &quot;0&quot;,            &quot;dataId&quot;: &quot;nacos.example&quot;,            &quot;group&quot;: &quot;com.alibaba.nacos&quot;,            &quot;content&quot;: null,            &quot;md5&quot;: null,            &quot;encryptedDataKey&quot;: null,            &quot;tenant&quot;: &quot;&quot;,            &quot;appName&quot;: &quot;&quot;,            &quot;type&quot;: &quot;yaml&quot;,            &quot;lastModified&quot;: 0        &#125;    ]&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Nacos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nacos</tag>
      
      <tag>运维</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day03</title>
    <link href="/2025/02/12/2025-02-12-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day03/"/>
    <url>/2025/02/12/2025-02-12-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day03/</url>
    
    <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else(分支结构)"></a>if else(分支结构)</h2><h3 id="if条件判断基本写法"><a href="#if条件判断基本写法" class="headerlink" title="if条件判断基本写法"></a>if条件判断基本写法</h3><p>Go语言中<code>if</code>条件判断的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</p><p>Go语言规定与<code>if</code>匹配的左括号<code>&#123;</code>必须与<code>if和表达式</code>放在同一行，<code>&#123;</code>放在其他位置会触发编译错误。 同理，与<code>else</code>匹配的<code>&#123;</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">score := <span class="number">65</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a>if条件判断特殊写法</h3><p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> score := <span class="number">65</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考题：</strong> 上下两种写法的区别在哪里？</p><h2 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for(循环结构)"></a>for(循环结构)</h2><p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p><p>for循环的基本格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。</p><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range(键值循环)"></a>for range(键值循环)</h2><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p><ol><li>数组、切片、字符串返回索引和值。</li><li>map返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ol><p>Go1.22版本开始支持 for range 整数。👉 <a href="https://go.dev/doc/go1.22">Go 1.22 Release Notes</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">5</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> <span class="number">2</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;《Go语言之路》上市啦！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">《Go语言之路》上市啦！</span><br><span class="line">《Go语言之路》上市啦！</span><br></pre></td></tr></table></figure><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">finger := <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> finger &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;大拇指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;食指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;中指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;无名指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;小拇指&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;无效的输入！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSwitch3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n := <span class="number">7</span>; n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;奇数&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;偶数&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">age := <span class="number">30</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> age &lt; <span class="number">25</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;好好学习吧&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">25</span> &amp;&amp; age &lt; <span class="number">35</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;好好工作吧&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">60</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;好好享受吧&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;活着真好&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;c&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h2 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto(跳转到指定标签)"></a>goto(跳转到指定标签)</h2><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> breakFlag <span class="type">bool</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line">breakFlag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外层for循环判断</span></span><br><span class="line"><span class="keyword">if</span> breakFlag &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>goto</code>语句能简化代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line"><span class="keyword">goto</span> breakTag</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">// 标签</span></span><br><span class="line">breakTag:</span><br><span class="line">fmt.Println(<span class="string">&quot;结束for循环&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break(跳出循环)"></a>break(跳出循环)</h2><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p><p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breakDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">BREAKDEMO1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">break</span> BREAKDEMO1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue(继续下次循环)"></a>continue(继续下次循环)</h2><p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p><p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">continueDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">forloop1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// forloop2:</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> forloop1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写代码打印9*9乘法表。</li></ol>]]></content>
    
    
    <categories>
      
      <category>开发学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day02</title>
    <link href="/2025/02/12/2025-02-12-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day02/"/>
    <url>/2025/02/12/2025-02-12-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day02/</url>
    
    <content type="html"><![CDATA[<h1 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p><p>Go语言中有25个关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure><p>此外，Go语言中还有37个保留字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    Types:    <span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span>  </span><br><span class="line">              <span class="type">uint</span>  <span class="type">uint8</span>  <span class="type">uint16</span>  <span class="type">uint32</span>  <span class="type">uint64</span>  <span class="type">uintptr</span></span><br><span class="line">              <span class="type">float32</span>  <span class="type">float64</span>  <span class="type">complex128</span>  <span class="type">complex64</span></span><br><span class="line">              <span class="type">bool</span>  <span class="type">byte</span>  <span class="type">rune</span>  <span class="type">string</span>  <span class="type">error</span></span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">             <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">             <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h2><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p><p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p><h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="type">bool</span></span><br></pre></td></tr></table></figure><h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="type">string</span></span><br><span class="line">    b <span class="type">int</span></span><br><span class="line">    c <span class="type">bool</span></span><br><span class="line">    d <span class="type">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为<code>空字符串</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p><p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>或者一次初始化多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, age = <span class="string">&quot;Q1mi&quot;</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">10</span></span><br><span class="line">m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x, _ := foo()</span><br><span class="line">_, y := foo()</span><br><span class="line">fmt.Println(<span class="string">&quot;x=&quot;</span>, x)</span><br><span class="line">fmt.Println(<span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p><p>注意事项：</p><ol><li>函数外的每个语句都必须以关键字开始（var、const、func等）</li><li><code>:=</code>不能使用在函数外。</li><li><code>_</code>多用于占位，表示忽略值。</li></ol><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure><p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p><p>多个常量也可以一起声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p><p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1</span></span><br><span class="line">n3        <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="几个常见的iota示例"><a href="#几个常见的iota示例" class="headerlink" title="几个常见的iota示例:"></a>几个常见的<code>iota</code>示例:</h3><p>使用<code>_</code>跳过某些值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1</span></span><br><span class="line">_</span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>iota</code>声明中间插队</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">_  = <span class="literal">iota</span></span><br><span class="line">KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>多个<code>iota</code>定义在一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2</span></span><br><span class="line">c, d                      <span class="comment">//2,3</span></span><br><span class="line">e, f                      <span class="comment">//3,4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint8</td><td>无符号 8位整型 (0 到 255)</td></tr><tr><td>uint16</td><td>无符号 16位整型 (0 到 65535)</td></tr><tr><td>uint32</td><td>无符号 32位整型 (0 到 4294967295)</td></tr><tr><td>uint64</td><td>无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td>int8</td><td>有符号 8位整型 (-128 到 127)</td></tr><tr><td>int16</td><td>有符号 16位整型 (-32768 到 32767)</td></tr><tr><td>int32</td><td>有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td>int64</td><td>有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint</td><td>32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td></tr><tr><td>int</td><td>32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td></tr><tr><td>uintptr</td><td>无符号整型，用于存放一个指针</td></tr></tbody></table><p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p><p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p><h3 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h3><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p><p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。 <code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。 <code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p><p>而且还允许我们用 <code>_</code> 来分隔数字，比如说： <code>v := 123_456</code> 表示 v 的值等于 123456。</p><p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d \n&quot;</span>, a)  <span class="comment">// 10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b \n&quot;</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 八进制  以0开头</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">077</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%o \n&quot;</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十六进制  以0x开头</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">int</span> = <span class="number">0xff</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x \n&quot;</span>, c)  <span class="comment">// ff</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X \n&quot;</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code> 标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex64和complex128</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="type">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="type">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure><p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p><p><strong>注意：</strong></p><ol><li>布尔类型变量的默认值为<code>false</code>。</li><li>Go 语言中不允许将整型强制转换为布尔型.</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;你好&quot;</span></span><br></pre></td></tr></table></figure><h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h3><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td><code>\r</code></td><td>回车符（返回行首）</td></tr><tr><td><code>\n</code></td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\\</code></td><td>反斜杠</td></tr><tr><td>举个例子，我们要打印一个Windows平台下的一个文件路径：</td><td></td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;str := \&quot;c:\\Code\\lesson1\\go.exe\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>+或fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix,strings.HasSuffix</td><td>前缀&#x2F;后缀判断</td></tr><tr><td>strings.Index(),strings.LastIndex()</td><td>子串出现的位置</td></tr><tr><td>strings.Join(a[]string, sep string)</td><td>join操作</td></tr></tbody></table><h2 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h2><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;中&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p>Go 语言的字符有以下两种：</p><ol><li><code>uint8</code>类型，或者叫 byte 型，代表一个<code>ASCII码</code>字符。</li><li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li></ol><p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p><p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;hello沙河&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, s[i], s[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, r, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) </span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) </span><br></pre></td></tr></table></figure><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p><p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p><h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line">byteS1 := []<span class="type">byte</span>(s1)</span><br><span class="line">byteS1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line">runeS2 := []<span class="type">rune</span>(s2)</span><br><span class="line">runeS2[<span class="number">0</span>] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p><p>强制类型转换的基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p><p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line"><span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">c = <span class="type">int</span>(math.Sqrt(<span class="type">float64</span>(a*a + b*b)))</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写代码分别定义一个整型、浮点型、布尔型、字符串型变量，使用<code>fmt.Printf()</code>搭配<code>%T</code>分别打印出上述变量的值和类型。</li><li>编写代码统计出字符串<code>&quot;hello沙河小王子&quot;</code>中汉字的数量。</li></ol><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>Go 语言内置的运算符有：</p><ol><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li></ol><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>&#x2F;</td><td>相除</td></tr><tr><td>%</td><td>求余</td></tr></tbody></table><p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td>!&#x3D;</td><td>检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td>&gt;</td><td>检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&gt;&#x3D;</td><td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;&#x3D;</td><td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td>|</td><td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td>!</td><td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>参与运算的两数各对应的二进位相与。  <br>（两位均为1才为1）</td></tr><tr><td>|</td><td>参与运算的两数各对应的二进位相或。  <br>（两位有一个为1就为1）</td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。  <br>（两位不一样则为1）</td></tr><tr><td>«</td><td>左移n位就是乘以2的n次方。  <br>“a«b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td>»</td><td>右移n位就是除以2的n次方。  <br>“a»b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+&#x3D;</td><td>相加后再赋值</td></tr><tr><td>-&#x3D;</td><td>相减后再赋值</td></tr><tr><td>*&#x3D;</td><td>相乘后再赋值</td></tr><tr><td>&#x2F;&#x3D;</td><td>相除后再赋值</td></tr><tr><td>%&#x3D;</td><td>求余后再赋值</td></tr><tr><td>«&#x3D;</td><td>左移后赋值</td></tr><tr><td>»&#x3D;</td><td>右移后赋值</td></tr><tr><td>&amp;&#x3D;</td><td>按位与后赋值</td></tr><tr><td>|&#x3D;</td><td>按位或后赋值</td></tr><tr><td>^&#x3D;</td><td>按位异或后赋值</td></tr></tbody></table><h1 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h1><p>有一堆数字，如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？</p>]]></content>
    
    
    <categories>
      
      <category>开发学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cloudfare重定向问题处理</title>
    <link href="/2025/02/11/2025-02-11-cloudfare%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
    <url>/2025/02/11/2025-02-11-cloudfare%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天给GitHub Page套了层Cloudflare，结果访问时浏览器报“重定向次数过多”错误。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>通过百度查询，发现是HTTPS的问题。GitHub Page中打开了“Enforce HTTPS ”，这会让所有HTTP的链接重定向到HTTPS中。而Cloudflare回源使用的是HTTP链接，于是就出现了一遍遍的重定向，最终次数过多浏览器报错。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将Cloudflare中的SSL&#x2F;TLS 加密模式由“关闭”或“灵活”改为“完全”即可。</p>]]></content>
    
    
    <categories>
      
      <category>Deploy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day01</title>
    <link href="/2025/02/11/2025-02-11-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day01/"/>
    <url>/2025/02/11/2025-02-11-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day01/</url>
    
    <content type="html"><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>由于笔者工作与开发关系不大，因此已有许久没有复习过golang的语法和用例，最近在对运维平台的梳理过程中，想要用golang来做一下后端的实现，奈何基础知识基本上忘光了，连ai写都写不下去，故此开始复习一下相关内容，顺便整理一下之前杂乱的笔记。  </p><h1 id="0-从零开始搭建Go环境"><a href="#0-从零开始搭建Go环境" class="headerlink" title="0.从零开始搭建Go环境"></a>0.从零开始搭建Go环境</h1><h2 id="0-1-安装Go"><a href="#0-1-安装Go" class="headerlink" title="0.1 安装Go"></a>0.1 安装Go</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p>Go官网下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></p><p>Go官方镜像站（推荐）：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p><h4 id="版本的选择"><a href="#版本的选择" class="headerlink" title="版本的选择"></a>版本的选择</h4><p>Windows平台和Mac平台推荐下载可执行文件版，Linux平台下载压缩文件版。</p><p>笔者使用的是macos平台，因此下载的是go1.23.6.darwin-amd64.pkg这个版本。</p><p><img src="/../pictures/golang.png" alt="go下载页面"></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>双击下载的pkg文件，按照提示安装即可。</p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>笔者使用的是macos平台，因此需要配置环境变量。</p><p>在终端输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$PATH:/usr/local/go/bin&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>配置完成后，可以在终端输入go version查看是否安装成功。</p><p><img src="/../pictures/goversion.png" alt="go版本"></p><h4 id="运行第一个go程序"><a href="#运行第一个go程序" class="headerlink" title="运行第一个go程序"></a>运行第一个go程序</h4><p>这里可以参考<a href="https://tour.golang.org/welcome/1">Go官方教程</a></p><p>笔者这里选择的是<a href="https://tour.golang.org/welcome/1">Hello, World!</a></p><p>在ide中新建一个go文件，文件名可以为hello.go，文件内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run hello.go</span><br></pre></td></tr></table></figure><p>这样就能看到类似如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>至此，Go环境就配置完成了。</p><h1 id="1-依赖管理"><a href="#1-依赖管理" class="headerlink" title="1.依赖管理"></a>1.依赖管理</h1><h2 id="为什么需要依赖管理"><a href="#为什么需要依赖管理" class="headerlink" title="为什么需要依赖管理"></a>为什么需要依赖管理</h2><p>最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？</p><h2 id="godep"><a href="#godep" class="headerlink" title="godep"></a>godep</h2><p>Go语言从v1.5开始开始引入<code>vendor</code>模式，如果项目目录下有vendor目录，那么go工具链会优先使用<code>vendor</code>内的包进行编译、测试等。</p><p><code>godep</code>是一个通过vender模式实现的Go语言的第三方依赖管理工具，类似的还有由社区维护准官方包管理工具<code>dep</code>。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>执行以下命令安装<code>godep</code>工具。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/tools/godep</span><br></pre></td></tr></table></figure><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>安装好godep之后，在终端输入<code>godep</code>查看支持的所有命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">godep save     将依赖项输出并复制到Godeps.json文件中</span><br><span class="line">godep go       使用保存的依赖项运行go工具</span><br><span class="line">godep get      下载并安装具有指定依赖项的包</span><br><span class="line">godep path     打印依赖的GOPATH路径</span><br><span class="line">godep restore  在GOPATH中拉取依赖的版本</span><br><span class="line">godep update   更新选定的包或go版本</span><br><span class="line">godep diff     显示当前和以前保存的依赖项集之间的差异</span><br><span class="line">godep version  查看版本信息</span><br></pre></td></tr></table></figure><p>使用<code>godep help [command]</code>可以看看具体命令的帮助信息。</p><h3 id="使用godep"><a href="#使用godep" class="headerlink" title="使用godep"></a>使用godep</h3><p>在项目目录下执行<code>godep save</code>命令，会在当前项目中创建<code>Godeps</code>和<code>vender</code>两个文件夹。</p><p>其中<code>Godeps</code>文件夹下有一个<code>Godeps.json</code>的文件，里面记录了项目所依赖的包信息。 <code>vender</code>文件夹下是项目依赖的包的源代码文件。</p><h3 id="vender机制"><a href="#vender机制" class="headerlink" title="vender机制"></a>vender机制</h3><p>Go1.5版本之后开始支持，能够控制Go语言程序编译时依赖包搜索路径的优先级。</p><p>例如查找项目的某个依赖包，首先会在项目根目录下的<code>vender</code>文件夹中查找，如果没有找到就会去<code>$GOAPTH/src</code>目录下查找。</p><h3 id="godep开发流程"><a href="#godep开发流程" class="headerlink" title="godep开发流程"></a>godep开发流程</h3><ol><li>保证程序能够正常编译</li><li>执行<code>godep save</code>保存当前项目的所有第三方依赖的版本信息和代码</li><li>提交Godeps目录和vender目录到代码库。</li><li>如果要更新依赖的版本，可以直接修改<code>Godeps.json</code>文件中的对应项</li></ol><h2 id="go-module"><a href="#go-module" class="headerlink" title="go module"></a>go module</h2><p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。</p><h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><p>要启用<code>go module</code>支持首先要设置环境变量<code>GO111MODULE</code>，通过它可以开启或关闭模块支持，它有三个可选值：<code>off</code>、<code>on</code>、<code>auto</code>，默认值是<code>auto</code>。</p><ol><li><code>GO111MODULE=off</code>禁用模块支持，编译时会从<code>GOPATH</code>和<code>vendor</code>文件夹中查找包。</li><li><code>GO111MODULE=on</code>启用模块支持，编译时会忽略<code>GOPATH</code>和<code>vendor</code>文件夹，只根据 <code>go.mod</code>下载依赖。</li><li><code>GO111MODULE=auto</code>，当项目在<code>$GOPATH/src</code>外且项目根目录有<code>go.mod</code>文件时，开启模块支持。</li></ol><p>简单来说，设置<code>GO111MODULE=on</code>之后就可以使用<code>go module</code>了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p><p>使用 go module 管理依赖后会在项目根目录下生成两个文件<code>go.mod</code>和<code>go.sum</code>。</p><h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>Go1.11之后设置GOPROXY命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><p>Go1.13之后<code>GOPROXY</code>默认值为<code>https://proxy.golang.org</code>，在国内是无法访问的，所以十分建议大家设置GOPROXY，这里我推荐使用<a href="https://studygolang.com/topics/10014">goproxy.cn</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><h3 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h3><p>常用的<code>go mod</code>命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go mod download    下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录）</span><br><span class="line">go mod edit        编辑go.mod文件</span><br><span class="line">go mod graph       打印模块依赖图</span><br><span class="line">go mod init        初始化当前文件夹, 创建go.mod文件</span><br><span class="line">go mod tidy        增加缺少的module，删除无用的module</span><br><span class="line">go mod vendor      将依赖复制到vendor下</span><br><span class="line">go mod verify      校验依赖</span><br><span class="line">go mod why         解释为什么需要依赖</span><br></pre></td></tr></table></figure><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p>go.mod文件记录了项目所有的依赖信息，其结构大致如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module github.com/Q1mi/studygo/blogger</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586</span><br><span class="line">github.com/gin-gonic/gin v1.4.0</span><br><span class="line">github.com/go-sql-driver/mysql v1.4.1</span><br><span class="line">github.com/jmoiron/sqlx v1.2.0</span><br><span class="line">github.com/satori/go.uuid v1.2.0</span><br><span class="line">google.golang.org/appengine v1.6.1 // indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>module</code>用来定义包名</li><li><code>require</code>用来定义依赖包及版本</li><li><code>indirect</code>表示间接引用</li></ul><h4 id="依赖的版本"><a href="#依赖的版本" class="headerlink" title="依赖的版本"></a>依赖的版本</h4><p>go mod支持语义化版本号，比如<code>go get foo@v1.2.3</code>，也可以跟git的分支或tag，比如<code>go get foo@master</code>，当然也可以跟git提交哈希，比如<code>go get foo@e3702bed2</code>。关于依赖的版本支持以下几种格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gopkg.in/tomb.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20141024135613</span>-dd632973f1e7</span><br><span class="line">gopkg.in/vmihailenco/msgpack.v2 v2<span class="number">.9</span><span class="number">.1</span></span><br><span class="line">gopkg.in/yaml.v2 &lt;=v2<span class="number">.2</span><span class="number">.1</span></span><br><span class="line">github.com/tatsushid/<span class="keyword">go</span>-fastping v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20160109021039</span>-d7bb493dee3e</span><br><span class="line">latest</span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>在国内访问golang.org&#x2F;x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replace (</span><br><span class="line">golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614</span>d502a4dac =&gt; github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614</span>d502a4dac</span><br><span class="line">golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180821023952</span><span class="number">-922</span>f4815f713 =&gt; github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180826012351</span><span class="number">-8</span>a410e7b638d</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.0</span> =&gt; github.com/golang/text v0<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><p>在项目中执行<code>go get</code>命令可以下载依赖包，并且还可以指定下载的版本。</p><ol><li>运行<code>go get -u</code>将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li><li>运行<code>go get -u=patch</code>将会升级到最新的修订版本</li><li>运行<code>go get package@version</code>将会升级到指定的版本号version</li></ol><p>如果下载所有依赖可以使用<code>go mod download</code> 命令。</p><h3 id="整理依赖"><a href="#整理依赖" class="headerlink" title="整理依赖"></a>整理依赖</h3><p>我们在代码中删除依赖代码后，相关的依赖库并不会在<code>go.mod</code>文件中自动移除。这种情况下我们可以使用<code>go mod tidy</code>命令更新<code>go.mod</code>中的依赖关系。</p><h3 id="go-mod-edit"><a href="#go-mod-edit" class="headerlink" title="go mod edit"></a>go mod edit</h3><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>因为我们可以手动修改go.mod文件，所以有些时候需要格式化该文件。Go提供了一下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -<span class="built_in">fmt</span></span><br></pre></td></tr></table></figure><h4 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -require=golang.org/x/text</span><br></pre></td></tr></table></figure><h4 id="移除依赖项"><a href="#移除依赖项" class="headerlink" title="移除依赖项"></a>移除依赖项</h4><p>如果只是想修改<code>go.mod</code>文件中的内容，那么可以运行<code>go mod edit -droprequire=package path</code>，比如要在<code>go.mod</code>中移除<code>golang.org/x/text</code>包，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -droprequire=golang.org/x/text</span><br></pre></td></tr></table></figure><p>关于<code>go mod edit</code>的更多用法可以通过<code>go help mod edit</code>查看。</p><h2 id="在项目中使用go-module"><a href="#在项目中使用go-module" class="headerlink" title="在项目中使用go module"></a>在项目中使用go module</h2><h3 id="既有项目"><a href="#既有项目" class="headerlink" title="既有项目"></a>既有项目</h3><p>如果需要对一个已经存在的项目启用<code>go module</code>，可以按照以下步骤操作：</p><ol><li>在项目目录下执行<code>go mod init</code>，生成一个<code>go.mod</code>文件。</li><li>执行<code>go get</code>，查找并记录当前项目的依赖，同时生成一个<code>go.sum</code>记录每个依赖库的版本和哈希值。</li></ol><h3 id="新项目"><a href="#新项目" class="headerlink" title="新项目"></a>新项目</h3><p>对于一个新创建的项目，我们可以在项目文件夹下按照以下步骤操作：</p><ol><li>执行<code>go mod init 项目名</code>命令，在当前项目文件夹下创建一个<code>go.mod</code>文件。</li><li>手动编辑<code>go.mod</code>中的require依赖项或执行<code>go get</code>自动发现、维护依赖。</li></ol><h3 id="使用go-mod导入本地项目"><a href="#使用go-mod导入本地项目" class="headerlink" title="使用go mod导入本地项目"></a>使用go mod导入本地项目</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>假设我们现在有<code>moduledemo</code>和<code>mypackage</code>两个包，其中<code>moduledemo</code>包中会导入<code>mypackage</code>包并使用它的<code>New</code>方法。</p><p><code>mypackage/mypackage.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypackage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;mypackage.New&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在分两种情况讨论：</p><h4 id="在同一个项目下"><a href="#在同一个项目下" class="headerlink" title="在同一个项目下"></a>在同一个项目下</h4><p><strong>注意</strong>：在一个项目（project）下我们是可以定义多个包（package）的。</p><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p>现在的情况是，我们在<code>moduledemo/main.go</code>中调用了<code>mypackage</code>这个包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">moduledemo</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── mypackage</span><br><span class="line">    └── mypackage.go</span><br></pre></td></tr></table></figure><h5 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h5><p>这个时候，我们需要在<code>moduledemo/go.mod</code>中按如下定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module moduledemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>然后在<code>moduledemo/main.go</code>中按如下方式导入<code>mypackage</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;moduledemo/mypackage&quot;</span>  <span class="comment">// 导入同一项目下的mypackage包</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mypackage.New()</span><br><span class="line">fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h5><p>举一反三，假设我们现在有文件目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── bubble</span><br><span class="line">    ├── dao</span><br><span class="line">    │   └── mysql.go</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── main.go</span><br></pre></td></tr></table></figure><p>其中<code>bubble/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module github.com/q1mi/bubble</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p><code>bubble/dao/mysql.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;mypackage.New&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bubble/main.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/q1mi/bubble/dao&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dao.New()</span><br><span class="line">fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不在同一个项目下"><a href="#不在同一个项目下" class="headerlink" title="不在同一个项目下"></a>不在同一个项目下</h4><h5 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── moduledemo</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   └── main.go</span><br><span class="line">└── mypackage</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── mypackage.go</span><br></pre></td></tr></table></figure><h5 id="导入包-1"><a href="#导入包-1" class="headerlink" title="导入包"></a>导入包</h5><p>这个时候，<code>mypackage</code>也需要进行module初始化，即拥有一个属于自己的<code>go.mod</code>文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module mypackage</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>然后我们在<code>moduledemo/main.go</code>中按如下方式导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;mypackage&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mypackage.New()</span><br><span class="line">fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这两个包不在同一个项目路径下，你想要导入本地包，并且这些包也没有发布到远程的github或其他代码仓库地址。这个时候我们就需要在<code>go.mod</code>文件中使用<code>replace</code>指令。</p><p>在调用方也就是<code>moduledemo/go.mod</code>中按如下方式指定使用相对路径来寻找<code>mypackage</code>这个包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module moduledemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">require <span class="string">&quot;mypackage&quot;</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">replace <span class="string">&quot;mypackage&quot;</span> =&gt; <span class="string">&quot;../mypackage&quot;</span></span><br></pre></td></tr></table></figure><h5 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h5><p>最后我们再举个例子巩固下上面的内容。</p><p>我们现在有文件目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── p1</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   └── main.go</span><br><span class="line">└── p2</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── p2.go</span><br></pre></td></tr></table></figure><p><code>p1/main.go</code>中想要导入<code>p2.go</code>中定义的函数。</p><p><code>p2/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module liwenzhou.com/q1mi/p2</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p><code>p1/main.go</code>中按如下方式导入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;liwenzhou.com/q1mi/p2&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p2.New()</span><br><span class="line">fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我并没有把<code>liwenzhou.com/q1mi/p2</code>这个包上传到<code>liwenzhou.com</code>这个网站，我们只是想导入本地的包，这个时候就需要用到<code>replace</code>这个指令了。</p><p><code>p1/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module github.com/q1mi/p1</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">require <span class="string">&quot;liwenzhou.com/q1mi/p2&quot;</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">replace <span class="string">&quot;liwenzhou.com/q1mi/p2&quot;</span> =&gt; <span class="string">&quot;../p2&quot;</span></span><br></pre></td></tr></table></figure><p>此时，我们就可以正常编译<code>p1</code>这个项目了。</p>]]></content>
    
    
    <categories>
      
      <category>开发学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运维平台功能梳理</title>
    <link href="/2025/02/10/2025-02-10-%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0%E5%8A%9F%E8%83%BD%E6%A2%B3%E7%90%86/"/>
    <url>/2025/02/10/2025-02-10-%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0%E5%8A%9F%E8%83%BD%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>要构建一个运维平台，接入阿里云平台并实现资产管理、用户管理、告警管理、日志管理、数据库监控等功能，需要从需求分析、架构设计和技术栈选择三个方面进行梳理。以下是详细的整理。</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="1-资产管理"><a href="#1-资产管理" class="headerlink" title="1.资产管理"></a>1.资产管理</h2><ul><li>功能需求：<ul><li>自动同步阿里云资源（如ECS、RDS、SLB等）到运维平台数据库；</li><li>资源分类和标签管理（主要是针对不同业务的不同需求进行命名以及标签管理）</li><li>资源生命周期管理（创建资源、修改资源配置、删除资源）</li><li>资源使用情况和报表（形成大盘）</li></ul></li><li>非功能需求<ul><li>数据实时性：资源状态需要实时更新；</li><li>可扩展性：支持未来接入其他云平台（如AWS、腾讯云等）</li></ul></li></ul><h2 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2.用户管理"></a>2.用户管理</h2><ul><li>功能需求：<ul><li>用户角色和权限管理（包括管理员、运维人员、普通用户）</li><li>基于角色的访问控制</li><li>用户操作日志审计</li></ul></li><li>非功能需求：<ul><li>安全性：支持多因素认证（MFA）和密码策略。</li><li>可扩展性：支持 LDAP 或 OAuth 集成。</li></ul></li></ul><h2 id="3-告警管理"><a href="#3-告警管理" class="headerlink" title="3. 告警管理"></a>3. 告警管理</h2><ul><li>功能需求：<ul><li>对接阿里云监控服务（如 CloudMonitor）。</li><li>自定义告警规则和阈值。</li><li>告警通知（邮件、短信、钉钉、Webhook）。</li><li>告警历史记录和统计分析。</li></ul></li><li>非功能需求：<ul><li>实时性：告警需要及时触发和通知。</li><li>灵活性：支持多种通知渠道和自定义模板。</li></ul></li></ul><h2 id="4-日志管理"><a href="#4-日志管理" class="headerlink" title="4. 日志管理"></a>4. 日志管理</h2><ul><li>功能需求：<ul><li>收集阿里云服务日志（如 SLB 访问日志、RDS 慢查询日志）。</li><li>日志存储和检索（支持全文搜索和过滤）。</li><li>日志分析和可视化（如异常检测、趋势分析）。</li></ul></li><li>非功能需求：<ul><li>高性能：支持大规模日志数据的实时处理。</li><li>可扩展性：支持未来接入其他日志源。</li></ul></li></ul><h2 id="5-数据库监控"><a href="#5-数据库监控" class="headerlink" title="5. 数据库监控"></a>5. 数据库监控</h2><ul><li>功能需求：<ul><li>监控阿里云 RDS 实例的性能指标（如 CPU、内存、连接数）。</li><li>慢查询分析和优化建议。</li><li>数据库健康状态告警。</li></ul></li><li>非功能需求：<ul><li>实时性：监控数据需要实时更新。</li><li>可视化：提供直观的图表和报表。</li></ul></li></ul><hr><h1 id="二、架构设计"><a href="#二、架构设计" class="headerlink" title="二、架构设计"></a>二、架构设计</h1><h2 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h2><ul><li>前端：用户交互界面，提供资产管理、告警管理、日志查询等功能。</li><li>后端：核心业务逻辑，处理数据同步、告警规则、日志分析等。</li><li>数据库：存储用户数据、资源信息、告警记录、日志数据等。</li><li>消息队列：用于异步处理告警通知、日志收集等任务。</li><li>缓存：提高数据访问性能，如 Redis。</li><li>监控与告警：对接阿里云监控服务，实现实时告警。</li><li>日志收集与分析：使用 ELK（Elasticsearch、Logstash、Kibana）或 Loki 实现日志管理。</li></ul><h2 id="2-模块划分"><a href="#2-模块划分" class="headerlink" title="2. 模块划分"></a>2. 模块划分</h2><ul><li>资产管理模块：<ul><li>同步阿里云资源信息。</li><li>提供资源查询和操作接口。</li></ul></li><li>用户管理模块：<ul><li>用户认证和授权。</li><li>操作日志记录。</li></ul></li><li>告警管理模块：<ul><li>对接阿里云监控。</li><li>告警规则管理和通知。</li></ul></li><li>日志管理模块：<ul><li>日志收集、存储和检索。</li><li>日志分析和可视化。</li></ul></li><li>数据库监控模块：<ul><li>监控 RDS 实例性能。</li><li>提供慢查询分析和优化建议。</li></ul></li></ul><h2 id="3-数据流设计"><a href="#3-数据流设计" class="headerlink" title="3. 数据流设计"></a>3. 数据流设计</h2><ul><li>资源同步：定期调用阿里云 API 获取资源信息，存储到数据库。</li><li>告警处理：阿里云监控触发告警后，通过消息队列异步处理通知。</li><li>日志收集：通过 Logstash 或 Fluentd 收集日志，存储到 Elasticsearch。</li><li>监控数据：通过阿里云 SDK 获取 RDS 监控数据，存储到数据库并提供可视化。</li></ul><hr><h1 id="三、技术栈选择"><a href="#三、技术栈选择" class="headerlink" title="三、技术栈选择"></a>三、技术栈选择</h1><h2 id="1-前端"><a href="#1-前端" class="headerlink" title="1. 前端"></a>1. 前端</h2><ul><li>框架：React 或 Vue.js。</li><li>UI 库：Ant Design 或 Element UI。</li><li>图表库：ECharts 或 Chart.js。</li></ul><h2 id="2-后端"><a href="#2-后端" class="headerlink" title="2. 后端"></a>2. 后端</h2><ul><li>语言：Python（Django&#x2F;Flask）或 Go（Gin）。</li><li>API 框架：RESTful API 或 GraphQL。</li><li>阿里云 SDK：使用阿里云官方 SDK 进行资源管理和监控。</li></ul><h2 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h2><ul><li>关系型数据库：MySQL 或 PostgreSQL（存储用户、资源、告警等数据）。</li><li>日志存储：Elasticsearch。</li><li>缓存：Redis。</li></ul><h2 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4. 消息队列"></a>4. 消息队列</h2><ul><li>工具：RabbitMQ 或 Kafka（用于异步处理告警通知和日志收集）。</li></ul><h3 id="5-日志管理"><a href="#5-日志管理" class="headerlink" title="5. 日志管理"></a>5. 日志管理</h3><ul><li>收集：Logstash 或 Fluentd。</li><li>存储与检索：Elasticsearch。</li><li>可视化：Kibana 或 Grafana。</li></ul><h2 id="6-监控与告警"><a href="#6-监控与告警" class="headerlink" title="6. 监控与告警"></a>6. 监控与告警</h2><ul><li>阿里云监控：通过 CloudMonitor 获取监控数据。</li><li>告警通知：集成钉钉、邮件、短信等通知渠道。</li></ul><h2 id="7-部署与运维"><a href="#7-部署与运维" class="headerlink" title="7. 部署与运维"></a>7. 部署与运维</h2><ul><li>容器化：Docker + Kubernetes。</li><li>CI&#x2F;CD：Jenkins 或 GitLab CI。</li><li>监控：Prometheus + Grafana。</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KubernetesChangelogs</title>
    <link href="/2025/02/05/2025-02-05-KubernetesChangeLog%E6%B1%87%E6%80%BB/"/>
    <url>/2025/02/05/2025-02-05-KubernetesChangeLog%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="Kubernetes-1-24"><a href="#Kubernetes-1-24" class="headerlink" title="Kubernetes 1.24"></a><strong>Kubernetes 1.24</strong></h3><p><strong>发布日期：</strong> 2022年5月3日<br><strong>主要更新：</strong></p><ul><li><strong>移除 Dockershim：</strong>  v1.20 中被弃用的 Dockershim 组件已从 kubelet 中移除。用户需迁移至其他受支持的容器运行时，如 containerd 或 CRI-O。</li><li><strong>默认关闭 Beta API：</strong> 的 Beta API 默认不再启用，现有的 Beta API 及其更新版本仍保持启用。</li><li><strong>签署发布工件：</strong> 入了使用 cosign 对发布工件进行签名的机制，增强了软件供应链的安全性。</li><li><strong>OpenAPI v3 支持：</strong> 供了以 OpenAPI v3 格式发布 API 的 Beta 支持。</li><li><strong>存储容量跟踪和卷扩展：</strong> 储容量跟踪和卷扩展功能已达到稳定版，改进了存储管理能力。</li><li><strong>非抢占优先级：</strong>  PriorityClasses 添加了非抢占选项，提供了更灵活的调度策略。</li><li><strong>存储插件迁移：</strong> zure Disk 和 OpenStack Cinder 插件已迁移至 CSI 驱动程序。</li><li><strong>gRPC 探针：</strong> RPC 探测功能升级至 Beta，允许为 gRPC 应用程序配置启动、存活和就绪性探测。</li><li><strong>Kubelet 凭证提供者：</strong> ubelet 对镜像凭证提供者的支持已升级到 Beta，允许动态检索容器镜像仓库的凭据。</li><li><strong>上下文日志记录：</strong> 入了上下文日志记录功能，使函数调用者能够控制日志记录的各个方面。</li><li><strong>避免服务 IP 分配冲突：</strong> 入了新的功能，允许为服务的静态 IP 地址分配软保留范围，降低冲突风险。</li><li><strong>移除动态 Kubelet 配置：</strong> 态 Kubelet 配置已从 kubelet 中移除，并计划在 Kubernetes 1.26 中从 API 服务器中移除。<br>多详细信息，请参阅官方发布公告。citeturn0search10</li></ul><hr><h3 id="Kubernetes-1-25"><a href="#Kubernetes-1-25" class="headerlink" title="Kubernetes 1.25"></a><strong>Kubernetes 1.25</strong></h3><p><strong>发布日期：</strong> 2022年8月23日<br><strong>主要更新：</strong></p><ul><li><strong>Pod 安全性准入：</strong> odSecurity 准入控制器已达到稳定版，提供了基于命名空间标签的安全策略。</li><li><strong>容器运行时接口（CRI）增强：</strong>  CRI 进行了改进，增强了对多种容器运行时的兼容性。</li><li><strong>存储功能增强：</strong> SI 插件支持更多的存储后端，并增强了与动态卷供给的兼容性。</li><li><strong>资源请求和限制优化：</strong> 进了资源请求与限制的计算和调度，提升了调度器的资源分配能力。</li><li><strong>弃用 PodSecurityPolicy（PSP）：</strong> SP 功能被正式弃用，用户应迁移到新的 PodSecurity 策略。</li><li><strong>移除 <code>--cloud-provider</code> 标志：</strong> –cloud-provider&#96; 标志被移除，用户需迁移到新的云提供商接口。</li><li><strong>服务账户权限策略调整：</strong> 服务账户的权限策略进行了改进，部分权限不再默认开放。</li><li><strong>API 版本更新：</strong> 些旧的 API 版本被废弃，用户需迁移到更稳定的版本。<br>多详细信息，请参阅官方发布公告。</li></ul><hr><h3 id="Kubernetes-1-26"><a href="#Kubernetes-1-26" class="headerlink" title="Kubernetes 1.26"></a><strong>Kubernetes 1.26</strong></h3><p><strong>发布日期：</strong> 2022年12月8日<br><strong>主要更新：</strong></p><ul><li><strong>原生边车容器支持：</strong> 入了原生的边车容器支持，简化了边车容器的管理。</li><li><strong>Job 控制器增强：</strong>  Job 控制器进行了增强，支持更多的调度和重试策略。</li><li><strong>存储功能增强：</strong> 入了对新的存储卷模式和快照功能的支持。</li><li><strong>弃用旧版 API：</strong> 一步弃用了旧的 API 版本，用户需尽快迁移到新的 API。</li><li><strong>安全性增强：</strong> 强了对证书和密钥管理的控制，提升了集群的安全性。<br>多详细信息，请参阅官方发布公告。</li></ul><hr><h3 id="Kubernetes-1-27"><a href="#Kubernetes-1-27" class="headerlink" title="Kubernetes 1.27"></a><strong>Kubernetes 1.27</strong></h3><p><strong>发布日期：</strong> 2023年4月11日<br><strong>主要更新：</strong></p><ul><li><strong>控制器管理器的领导者迁移：</strong> ube-controller-manager 和 cloud-controller-manager 可以在高可用控制平面中重新分配新的控制器，无需停机。</li><li><strong>Pod 亲和性 NamespaceSelector：</strong>  Pod 亲和性&#x2F;反亲和性规则添加了 <code>namespaceSelector</code> 字段。</li><li><strong>弃用旧版 API：</strong> 续弃用旧的 API 版本，用户需迁移到新的 API。</li><li><strong>安全性增强：</strong> 进了对服务账户和 RBAC 的支持，增强了权限管理。<br>多详细信息，请参阅官方发布公告。</li></ul><hr><h3 id="Kubernetes-1-28"><a href="#Kubernetes-1-28" class="headerlink" title="Kubernetes 1.28"></a><strong>Kubernetes 1.28</strong></h3><p><strong>发布日期：</strong> 2023年8月16日<br><strong>主要更新：</strong></p><ol><li><strong>节点非体面关闭功能进入 GA（正式发布）阶段：</strong><ul><li>特性允许在节点意外关闭或不可恢复时，有状态工作负载能够在其他节点上重新启动，确保应用的高可用性。citeturn0search0</li></ul></li><li><strong>对 Linux 上交换内存的 Beta 支持：</strong><ul><li>入了对 Linux 节点上交换内存的支持，提升了节点的内存管理能力，增强了系统的稳定性。citeturn0search2</li></ul></li><li><strong>Job 失效处理的改进：</strong><ul><li>入了 Pod 更换策略和基于索引的回退限制，改进了对批处理作业中 Pod 失效的处理，提高了批处理任务的可靠性。citeturn0search6</li></ul></li><li><strong>节点 podresources API 正式发布：</strong><ul><li>API 允许用户查询节点上分配给容器的资源信息，增强了对资源分配的可观测性。citeturn0search14</li></ul></li><li><strong>用于改进集群安全升级的新机制（Alpha）：</strong><ul><li>入了混合版本代理特性，允许在集群升级期间，不同版本的 API 服务器之间正确处理资源请求，确保升级过程的平滑和安全。citeturn0search13</li></ul></li></ol><hr><h3 id="Kubernetes-1-29"><a href="#Kubernetes-1-29" class="headerlink" title="Kubernetes 1.29"></a><strong>Kubernetes 1.29</strong></h3><p><strong>发布日期：</strong> 2023年12月13日<br><strong>主要更新：</strong></p><ol><li><strong>引入 nftables 作为 kube-proxy 的新后端（Alpha）：</strong><ul><li>kube-proxy 添加了基于 nftables 的后端，以替代传统的 iptables，提供更好的性能和可扩展性。citeturn0search4</li></ul></li><li><strong>Sidecar 容器功能进入 Beta 阶段并默认启用：</strong><ul><li>idecar 容器运行模式进入了 Beta 阶段，允许用户明确定义 Sidecar 容器的启动顺序和生命周期管理，增强了对应用程序的支持。citeturn0search11</li></ul></li><li><strong>KMS v2 静态加密功能正式发布：</strong><ul><li>MS v2 提供了性能提升、密钥轮换和可观测性方面的改进，为集群中的数据加密提供了更可靠的解决方案。citeturn0search7</li></ul></li><li><strong>ReadWriteOncePod 持久卷访问模式达到稳定版：</strong><ul><li>入了新的持久卷访问模式，确保在整个集群中，只有一个 Pod 可以读写特定的 PVC，增强了数据的安全性和一致性。citeturn0search10</li></ul></li><li><strong>上下文日志记录功能的增强：</strong><ul><li>进了日志记录机制，引入了上下文日志记录功能，提供了更好的故障排除能力和增强的日志记录。citeturn0search3</li></ul></li><li><strong>Service 负载均衡器 IP 模式（Alpha）：</strong><ul><li>入了新的 Alpha 特性，允许用户配置 Service 的负载均衡器 IP 模式，提供了更灵活的流量管理方式。citeturn0search4</li></ul></li></ol><hr><p>抱歉之前的总结遗漏了 Kubernetes 1.30 和 1.31 版本的更新日志。以下是对这两个版本的中文总结：</p><hr><h3 id="Kubernetes-1-30"><a href="#Kubernetes-1-30" class="headerlink" title="Kubernetes 1.30"></a><strong>Kubernetes 1.30</strong></h3><p><strong>发布日期：</strong> 2024年3月12日<br><strong>主要更新：</strong></p><ol><li><strong>动态资源分配（DRA）结构化参数：</strong><ul><li>DRA 进行了扩展，引入了结构化参数支持，增强了资源请求的透明性和可管理性。</li></ul></li><li><strong>节点交换内存（Swap）支持：</strong><ul><li>进了 Linux 节点的交换内存支持，默认启用了 <code>NodeSwap</code> 特性门控，并将默认行为设置为 <code>NoSwap</code> 模式，提升了系统稳定性。</li></ul></li><li><strong>用户命名空间支持：</strong><ul><li>用户命名空间的支持升级至 Beta，允许在容器内以非特权用户运行进程，增强了安全性。</li></ul></li><li><strong>结构化身份认证配置：</strong><ul><li>入了基于文件的身份认证配置，支持配置多个 JWT 认证组件，提供了更灵活的认证机制。</li></ul></li><li><strong>基于容器资源指标的 Pod 自动扩缩容：</strong><ul><li>许根据各个容器的资源使用情况配置自动扩缩容策略，提升了资源利用效率。</li></ul></li><li><strong>在准入控制中使用 CEL：</strong><ul><li>成了通用表达式语言（CEL）用于准入控制，提供了更动态和细粒度的策略控制能力。<br>多详细信息，请参阅官方发布公告。</li></ul></li></ol><hr><h3 id="Kubernetes-1-31"><a href="#Kubernetes-1-31" class="headerlink" title="Kubernetes 1.31"></a><strong>Kubernetes 1.31</strong></h3><p><strong>发布日期：</strong> 2024年8月13日<br><strong>主要更新：</strong></p><ol><li><strong>AppArmor 支持：</strong><ul><li>ubernetes 对 AppArmor 的支持已达到稳定版，用户可以通过在容器的 <code>securityContext</code> 中设置 <code>appArmorProfile.type</code> 字段来启用 AppArmor。</li></ul></li><li><strong>改进的入站连接可靠性：</strong><ul><li>ube-proxy 增强了对 <code>type: LoadBalancer</code> 和 <code>externalTrafficPolicy: Cluster</code> 服务的入站连接可靠性，减少了节点终止时的流量丢失。</li></ul></li><li><strong>持久卷阶段转换时间：</strong><ul><li>入了 <code>PersistentVolumeStatus</code> 的 <code>lastTransitionTime</code> 字段，记录持久卷状态转换的时间戳，便于监控和调试。</li></ul></li><li><strong>对 OCI 镜像卷的支持：</strong><ul><li>入了 Alpha 特性，允许在 Pod 中直接使用 OCI 镜像作为只读卷，简化了 AI&#x2F;ML 工作流中的数据访问。</li></ul></li><li><strong>nftables 后端：</strong><ul><li>ube-proxy 的 nftables 后端晋级为 Beta，提供了比 iptables 更好的性能和可扩展性。</li></ul></li><li><strong>弃用和移除：</strong><ul><li>cgroup v1 的支持转为维护模式，建议用户迁移到 cgroup v2。   - 除了 CephFS 和 Ceph RBD 树内卷插件，用户应迁移到相应的 CSI 驱动程序。   - 用了节点的 <code>status.nodeInfo.kubeProxyVersion</code> 字段，并将在未来版本中移除。<br>多详细信息，请参阅官方发布公告。</li></ul></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KubernetesChangelog-1.32</title>
    <link href="/2025/02/05/2025-02-05-KubernetesChangelog-1.32/"/>
    <url>/2025/02/05/2025-02-05-KubernetesChangelog-1.32/</url>
    
    <content type="html"><![CDATA[<p>好的，我将根据 Kubernetes 1.32 版本更新日志提供更具体的总结，涵盖功能增强、重要修复、废弃和移除的功能等内容。</p><h3 id="Kubernetes-1-32-版本更新日志总结"><a href="#Kubernetes-1-32-版本更新日志总结" class="headerlink" title="Kubernetes 1.32 版本更新日志总结"></a><strong>Kubernetes 1.32 版本更新日志总结</strong></h3><h4 id="1-新特性与增强"><a href="#1-新特性与增强" class="headerlink" title="1. 新特性与增强"></a><strong>1. 新特性与增强</strong></h4><ul><li><p><strong>API Aggregation（API 聚合层）</strong>：</p><ul><li>对 API 聚合层进行了改进，以支持更多的扩展功能和插件，提升了集群的可扩展性。</li></ul></li><li><p><strong>资源请求与限制</strong>：</p><ul><li><strong><code>kube-scheduler</code></strong> 进行了性能优化，改善了资源请求和限制的计算，提升了调度器在大规模集群中的效率。</li><li>新增了对 <code>resourceRequests</code> 和 <code>resourceLimits</code> 的细粒度控制，尤其在多租户环境中提高了调度的灵活性和公平性。</li></ul></li><li><p><strong>调度器（Scheduler）</strong>：</p><ul><li>对调度算法进行了优化，尤其是在多租户环境中提高了调度公平性。调度器现在可以更智能地处理具有不同资源需求的 Pod，避免资源分配不均的情况。</li><li>增强了调度器的调度策略，能够更好地适应集群的负载和资源限制。</li></ul></li><li><p><strong>Windows 容器支持</strong>：</p><ul><li>增强了 Kubernetes 对 <strong>Windows 容器</strong> 的支持，改进了在 Windows 环境下运行容器的稳定性和兼容性。尤其是对于不同 Windows 版本的支持更加完善。</li></ul></li><li><p><strong>持久存储</strong>：</p><ul><li>持久存储方面，支持对 <code>StatefulSet</code> 中卷的自动扩展，简化了存储管理。</li><li>对 <strong>CSI（容器存储接口）</strong> 的支持进行了增强，使其更加可靠，特别是在跨多个集群和多云环境中的表现。</li></ul></li></ul><h4 id="2-重要修复"><a href="#2-重要修复" class="headerlink" title="2. 重要修复"></a><strong>2. 重要修复</strong></h4><ul><li><p><strong>API Server</strong>：</p><ul><li>修复了与 API Server 性能相关的问题，尤其是在集群规模较大时，API 请求的响应速度和稳定性有所提升。</li><li>解决了部分情况下 API Server 由于负载过高而导致的崩溃问题。</li></ul></li><li><p><strong>调度与资源管理</strong>：</p><ul><li>解决了调度器在资源分配时可能出现的不公平情况，优化了资源优先级的分配算法，确保不同优先级的 Pod 能够得到合理调度。</li></ul></li><li><p><strong>网络与服务发现</strong>：</p><ul><li>修复了在使用 <strong>DNS 解析服务</strong>时出现的问题，尤其是在多网络环境下，服务发现功能更加稳定。</li><li>修复了 <code>kubectl</code> 在查询服务状态时可能出现的不一致性问题。</li></ul></li><li><p><strong>Etcd 存储</strong>：</p><ul><li>优化了与 <strong>etcd</strong> 之间的连接，改进了数据同步和存储性能，确保高并发读写操作时不会引发延迟问题。</li></ul></li></ul><h4 id="3-已废弃与移除的功能"><a href="#3-已废弃与移除的功能" class="headerlink" title="3. 已废弃与移除的功能"></a><strong>3. 已废弃与移除的功能</strong></h4><ul><li><p><strong>移除 <code>--cloud-provider</code> 标志</strong>：</p><ul><li>Kubernetes 1.32 开始废弃并移除了 <code>--cloud-provider</code> 相关的标志，推荐用户使用更加现代化和可扩展的配置方式来替代。</li><li>用户需要迁移到新的云平台接口，不再使用该标志来指定云服务提供商。</li></ul></li><li><p><strong>废弃的 API 版本</strong>：</p><ul><li><code>v1beta1</code> 版本的部分 Kubernetes API 已经被废弃，用户应迁移到稳定的 <code>v1</code> 版本，避免在未来的版本中遇到兼容性问题。</li><li>一些与扩展和插件有关的 API 也被废弃，用户应使用新的扩展机制来替代。</li></ul></li><li><p><strong>Windows 节点的旧版本支持</strong>：</p><ul><li>旧版的 Windows 节点支持已被废弃，Kubernetes 1.32 仅支持 Windows Server 2019 或更新版本的节点。</li></ul></li></ul><h4 id="4-安全性增强"><a href="#4-安全性增强" class="headerlink" title="4. 安全性增强"></a><strong>4. 安全性增强</strong></h4><ul><li><p><strong>认证与授权</strong>：</p><ul><li>引入了更强的身份验证机制，增强了对 API Server 和 kubelet 等组件的访问控制。</li><li>更新了身份认证和授权策略，改进了对外部身份提供者的支持，增强了对 RBAC（基于角色的访问控制）策略的灵活性和扩展性。</li></ul></li><li><p><strong>安全修复</strong>：</p><ul><li>修复了已知的多个安全漏洞，特别是在身份验证、授权和存储层面，提升了整个集群的安全性。</li></ul></li><li><p><strong>Pod 安全策略（PSP）</strong>：</p><ul><li>对 Pod 安全策略进行了增强，提升了 Pod 运行时的安全性，并强化了对运行时权限的控制。</li></ul></li></ul><h4 id="5-性能与扩展性"><a href="#5-性能与扩展性" class="headerlink" title="5. 性能与扩展性"></a><strong>5. 性能与扩展性</strong></h4><ul><li><p><strong>集群性能</strong>：</p><ul><li>改进了大规模集群的性能，尤其是调度器、API Server 和 etcd 之间的交互。大规模集群在执行调度时的响应速度得到了显著提升。</li></ul></li><li><p><strong>API Server 扩展性</strong>：</p><ul><li>增强了 API Server 的扩展性，支持更多的插件和自定义资源类型的处理。</li><li>在处理高并发 API 请求时，API Server 的性能和吞吐量有了较大的提升。</li></ul></li></ul><h4 id="6-文档和工具更新"><a href="#6-文档和工具更新" class="headerlink" title="6. 文档和工具更新"></a><strong>6. 文档和工具更新</strong></h4><ul><li><p><strong>文档更新</strong>：</p><ul><li>更新了 Kubernetes 的官方文档，特别是在部署、扩展、集群管理和容器存储等方面，提供了更详细的指导。</li></ul></li><li><p><strong>开发工具</strong>：</p><ul><li>对开发者工具进行了优化，特别是 <strong>kubectl</strong>，增强了命令行工具的可用性和可扩展性，改进了用户的使用体验。</li></ul></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Kubernetes 1.32 版本着重于提升集群的稳定性、性能和可扩展性，特别是在调度、资源管理和 Windows 容器支持方面做了很多改进。同时，针对一些过时的功能进行了移除和废弃，用户需要注意迁移到新的配置和 API。安全性和性能优化是此次更新的重要方向，特别是在处理高负载时，集群的响应速度和稳定性有了显著提升。</p><p>该版本还强化了对多云环境和 Windows 容器的支持，继续推动 Kubernetes 向更广泛的应用场景拓展。在安全方面，修复了多个已知漏洞，进一步提高了集群的安全性。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx常见返回码整理</title>
    <link href="/2025/02/05/2025-02-05-Nginx%E5%B8%B8%E8%A7%81%E8%BF%94%E5%9B%9E%E7%A0%81%E6%95%B4%E7%90%86/"/>
    <url>/2025/02/05/2025-02-05-Nginx%E5%B8%B8%E8%A7%81%E8%BF%94%E5%9B%9E%E7%A0%81%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Nginx 的返回码（HTTP 状态码）是服务器对客户端请求的响应结果。理解这些状态码的含义对于排查问题、优化性能和提升用户体验非常重要。以下是常见的 Nginx 返回码及其解析：</p><hr><h3 id="1xx：信息性状态码"><a href="#1xx：信息性状态码" class="headerlink" title="1xx：信息性状态码"></a><strong>1xx：信息性状态码</strong></h3><p>表示请求已被接收，继续处理。</p><ul><li><strong>100 Continue</strong>：<ul><li>客户端应继续发送请求的剩余部分。</li><li>通常用于 POST 或 PUT 请求中，客户端先发送请求头，服务器确认后再发送请求体。</li></ul></li><li><strong>101 Switching Protocols</strong>：<ul><li>服务器同意客户端请求，切换协议（如从 HTTP 切换到 WebSocket）。</li></ul></li></ul><hr><h3 id="2xx：成功状态码"><a href="#2xx：成功状态码" class="headerlink" title="2xx：成功状态码"></a><strong>2xx：成功状态码</strong></h3><p>表示请求已成功被服务器接收、理解并处理。</p><ul><li><strong>200 OK</strong>：<ul><li>请求成功，服务器返回了请求的资源。</li><li>最常见的成功状态码。</li></ul></li><li><strong>201 Created</strong>：<ul><li>请求成功，并且服务器创建了新的资源（如 POST 请求创建了新资源）。</li></ul></li><li><strong>204 No Content</strong>：<ul><li>请求成功，但响应中没有内容（如 DELETE 请求成功）。</li></ul></li><li><strong>206 Partial Content</strong>：<ul><li>服务器成功处理了部分 GET 请求（如大文件的分段下载）。</li></ul></li></ul><hr><h3 id="3xx：重定向状态码"><a href="#3xx：重定向状态码" class="headerlink" title="3xx：重定向状态码"></a><strong>3xx：重定向状态码</strong></h3><p>表示需要客户端进一步操作以完成请求。</p><ul><li><strong>301 Moved Permanently</strong>：<ul><li>请求的资源已永久移动到新位置，客户端应使用新的 URL。</li></ul></li><li><strong>302 Found</strong>：<ul><li>请求的资源临时移动到新位置，客户端应使用新的 URL。</li></ul></li><li><strong>304 Not Modified</strong>：<ul><li>资源未修改，客户端可以使用缓存的版本。</li><li>通常用于条件请求（如 <code>If-Modified-Since</code>）。</li></ul></li></ul><hr><h3 id="4xx：客户端错误状态码"><a href="#4xx：客户端错误状态码" class="headerlink" title="4xx：客户端错误状态码"></a><strong>4xx：客户端错误状态码</strong></h3><p>表示客户端发送的请求有错误，服务器无法处理。</p><ul><li><strong>400 Bad Request</strong>：<ul><li>请求无效，服务器无法理解（如参数错误、格式错误）。</li></ul></li><li><strong>401 Unauthorized</strong>：<ul><li>请求需要身份验证，客户端未提供有效的凭据。</li></ul></li><li><strong>403 Forbidden</strong>：<ul><li>服务器拒绝请求，客户端没有访问权限。</li></ul></li><li><strong>404 Not Found</strong>：<ul><li>请求的资源不存在。</li></ul></li><li><strong>405 Method Not Allowed</strong>：<ul><li>请求方法不被允许（如使用 POST 访问只支持 GET 的接口）。</li></ul></li><li><strong>408 Request Timeout</strong>：<ul><li>请求超时，服务器未在指定时间内收到完整的请求。</li></ul></li><li><strong>413 Payload Too Large</strong>：<ul><li>请求体过大，服务器拒绝处理。</li></ul></li><li><strong>414 URI Too Long</strong>：<ul><li>请求的 URL 过长，服务器拒绝处理。</li></ul></li><li><strong>429 Too Many Requests</strong>：<ul><li>客户端发送的请求过多，触发限流。</li></ul></li><li><strong>499 Client Closed Request：</strong><ul><li>客户端在服务器处理请求的过程中断开了连接</li></ul></li></ul><hr><h3 id="5xx：服务器错误状态码"><a href="#5xx：服务器错误状态码" class="headerlink" title="5xx：服务器错误状态码"></a><strong>5xx：服务器错误状态码</strong></h3><p>表示服务器处理请求时发生错误。</p><ul><li><strong>500 Internal Server Error</strong>：<ul><li>服务器内部错误，无法完成请求。</li></ul></li><li><strong>502 Bad Gateway</strong>：<ul><li>服务器作为网关或代理时，从上游服务器收到无效响应。</li></ul></li><li><strong>503 Service Unavailable</strong>：<ul><li>服务器暂时不可用（如过载或维护）。</li></ul></li><li><strong>504 Gateway Timeout</strong>：<ul><li>服务器作为网关或代理时，未及时从上游服务器收到响应。</li></ul></li><li><strong>505 HTTP Version Not Supported</strong>：<ul><li>服务器不支持请求中使用的 HTTP 协议版本。</li></ul></li></ul><hr><h3 id="常见-Nginx-返回码场景分析"><a href="#常见-Nginx-返回码场景分析" class="headerlink" title="常见 Nginx 返回码场景分析"></a><strong>常见 Nginx 返回码场景分析</strong></h3><h3 id="1-502-Bad-Gateway"><a href="#1-502-Bad-Gateway" class="headerlink" title="1. 502 Bad Gateway"></a>1. <strong>502 Bad Gateway</strong></h3><ul><li><strong>原因</strong>：<ul><li>后端服务（如 Tomcat、Node.js）崩溃或无响应。</li><li>Nginx 与后端服务的连接超时。</li></ul></li><li><strong>解决方案</strong>：<ul><li><p>检查后端服务是否正常运行。</p></li><li><p>调整 Nginx 的超时配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_connect_timeout 60s;</span><br><span class="line">proxy_read_timeout 60s;</span><br><span class="line">proxy_send_timeout 60s;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-504-Gateway-Timeout"><a href="#2-504-Gateway-Timeout" class="headerlink" title="2. 504 Gateway Timeout"></a>2. <strong>504 Gateway Timeout</strong></h3><ul><li><strong>原因</strong>：<ul><li>后端服务处理请求时间过长，Nginx 等待超时。</li></ul></li><li><strong>解决方案</strong>：<ul><li><p>优化后端服务的性能。</p></li><li><p>调整 Nginx 的超时配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_read_timeout 300s;</span><br><span class="line">proxy_send_timeout 300s;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-404-Not-Found"><a href="#3-404-Not-Found" class="headerlink" title="3. 404 Not Found"></a>3. <strong>404 Not Found</strong></h3><ul><li><strong>原因</strong>：<ul><li>请求的资源不存在。</li><li>Nginx 配置错误，未正确映射请求路径。</li></ul></li><li><strong>解决方案</strong>：<ul><li><p>检查请求的 URL 是否正确。</p></li><li><p>检查 Nginx 的 <code>location</code> 配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /path &#123;</span><br><span class="line">    proxy_pass &lt;http://backend&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-403-Forbidden"><a href="#4-403-Forbidden" class="headerlink" title="4. 403 Forbidden"></a>4. <strong>403 Forbidden</strong></h3><ul><li><strong>原因</strong>：<ul><li>客户端没有访问权限。</li><li>Nginx 配置了访问控制（如 <code>allow</code> 和 <code>deny</code>）。</li></ul></li><li><strong>解决方案</strong>：<ul><li><p>检查 Nginx 的访问控制配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /path &#123;</span><br><span class="line">    allow 192.168.1.0/24;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-500-Internal-Server-Error"><a href="#5-500-Internal-Server-Error" class="headerlink" title="5. 500 Internal Server Error"></a>5. <strong>500 Internal Server Error</strong></h3><ul><li><strong>原因</strong>：<ul><li>后端服务抛出未捕获的异常。</li><li>Nginx 配置错误（如错误的 <code>proxy_pass</code>）。</li></ul></li><li><strong>解决方案</strong>：<ul><li><p>检查后端服务的日志，修复代码问题。</p></li><li><p>检查 Nginx 的 <code>proxy_pass</code> 配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /path &#123;</span><br><span class="line">    proxy_pass &lt;http://backend&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="Nginx-日志中的返回码"><a href="#Nginx-日志中的返回码" class="headerlink" title="Nginx 日志中的返回码"></a><strong>Nginx 日志中的返回码</strong></h3><p>Nginx 的访问日志（<code>access.log</code>）会记录每个请求的返回码。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [23/Oct/2023:12:34:56 +0800] &quot;GET /path HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>200</code>：返回码。</li><li><code>612</code>：响应体的大小（字节）。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Nginx 的返回码是排查问题和优化性能的重要依据。通过理解常见的状态码及其含义，可以快速定位问题并采取相应的解决方案。如果需要进一步分析，可以结合 Nginx 的日志和配置进行深入排查。</p>]]></content>
    
    
    <categories>
      
      <category>default</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次千辛万苦的部署</title>
    <link href="/2025/01/30/2025-01-30-%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%83%E8%BE%9B%E4%B8%87%E8%8B%A6%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
    <url>/2025/01/30/2025-01-30-%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%83%E8%BE%9B%E4%B8%87%E8%8B%A6%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="Started"><a href="#Started" class="headerlink" title="Started"></a>Started</h1><p>GitHub Pages 是 GitHub 提供的一个免费的静态网站托管服务，它允许 GitHub 用户创建和托管自己的静态网站，这些网站可以通过特定的 GitHub 仓库进行管理和托管。<br>因此笔者想通过githubpage搭建一套属于自己的个人博客，遂查询资料，主要参考：<a href="https://chirpy.cotes.page/posts/getting-started/%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C">https://chirpy.cotes.page/posts/getting-started/进行操作</a><br>步骤大致如下</p><ol><li>有一个自己的github账号</li><li>使用<a href="https://github.com/cotes2020/chirpy-starter">https://github.com/cotes2020/chirpy-starter</a> 这个启动器模版创建一个公共仓库，命名为*.github.io即可</li><li>最好有一个自己的域名</li><li>在pages中配置好域名以及使用github actions来源，在build and deployment标签下</li><li>将任何提交推送到 GitHub 以触发 “操作 “工作流。在版本库的 “操作 “选项卡中，你应该能看到 “构建和部署 “工作流正在运行。一旦构建完成并成功，网站将自动部署。<br>现在你就可以愉快的看到自己的个人博客了，由于jekyll没有后端，因此需要自己在根目录的_posts文件夹中编写markdown文件，文件命名要求如下：YYYY-MM-DD-TITLE.EXTENSION的新文件，并将其放在根目录的 _posts 中。EXTENSION 必须是 md 和 markdown 中的一个。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Deploy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
