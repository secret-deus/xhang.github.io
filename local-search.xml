<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/13/hello-world/"/>
    <url>/2025/02/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>etcdctl命令整理</title>
    <link href="/2025/02/13/2025-02-13-etcdctl%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <url>/2025/02/13/2025-02-13-etcdctl%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><code>etcdctl</code> 是 <code>etcd</code> 的命令行客户端工具，用于与 <code>etcd</code> 集群进行交互。下面是 <code>etcdctl</code> 的一些常用选项和命令，帮助你进行数据存取和集群管理等操作。</p><h1 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h1><p>在执行任何 <code>etcdctl</code> 命令时，你通常需要指定以下选项来配置连接参数：</p><ul><li><code>--endpoints=[]</code>：指定 <code>etcd</code> 集群的一个或多个端点地址，通常是 <code>http://ip:port</code> 格式。</li><li><code>--cacert=&quot;&quot;</code>：指定根证书文件路径，用于 TLS 连接。</li><li><code>--cert=&quot;&quot;</code>：指定客户端证书文件路径，用于 TLS 连接。</li><li><code>--key=&quot;&quot;</code>：指定客户端私钥文件路径，用于 TLS 连接。</li><li><code>--user=&quot;&quot;</code>：指定用户名和密码，格式为 <code>username:password</code>，用于身份验证。</li><li><code>--dial-timeout=&quot;&quot;</code>：指定建立连接的超时时长。</li><li><code>--command-timeout=&quot;&quot;</code>：指定命令执行的超时时长。</li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="数据操作命令"><a href="#数据操作命令" class="headerlink" title="数据操作命令"></a>数据操作命令</h2><ul><li><p><code>put &lt;key&gt; &lt;value&gt;</code>：设置指定键的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl put mykey myvalue</span><br></pre></td></tr></table></figure></li><li><p><code>get &lt;key&gt;</code>：获取指定键的值，可以使用 <code>--prefix</code> 来获取具有相同前缀的键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">etcdctl get mykey</span><br><span class="line">etcdctl get my --prefix</span><br></pre></td></tr></table></figure></li><li><p><code>del &lt;key&gt;</code>：删除指定键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl del mykey</span><br></pre></td></tr></table></figure></li></ul><h2 id="集群操作命令"><a href="#集群操作命令" class="headerlink" title="集群操作命令"></a>集群操作命令</h2><ul><li><p><code>member list</code>：列出集群中所有成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl member list</span><br></pre></td></tr></table></figure></li><li><p><code>endpoint status</code>：获取指定端点的状态信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl endpoint status</span><br></pre></td></tr></table></figure></li><li><p><code>endpoint health</code>：检查集群中一个或多个端点的健康状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl endpoint health</span><br></pre></td></tr></table></figure></li></ul><h2 id="维护相关命令"><a href="#维护相关命令" class="headerlink" title="维护相关命令"></a>维护相关命令</h2><ul><li><p><code>snapshot save &lt;filename&gt;</code>：创建集群的快照备份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl snapshot save backup.db</span><br></pre></td></tr></table></figure></li><li><p><code>snapshot status &lt;filename&gt;</code>：查看快照状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl snapshot status backup.db</span><br></pre></td></tr></table></figure></li><li><p><code>defrag</code>：整理 <code>etcd</code> 数据库以释放空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl defrag</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul><li><code>version</code>：显示 <code>etcdctl</code> 工具和 <code>etcd</code> 服务器版本。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl version</span><br></pre></td></tr></table></figure></li></ul><p>这些命令和选项覆盖了 <code>etcdctl</code> 的大部分基本功能，但 <code>etcdctl</code> 是一个非常强大和灵活的工具，拥有更多的高级选项和命令。要获取更多详细信息，您可以使用该工具的帮助命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h1 id="扩展命令"><a href="#扩展命令" class="headerlink" title="扩展命令"></a>扩展命令</h1><h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><p><code>etcdctl txn</code> 是用于执行事务操作的一种功能，允许你在一个原子操作中执行多个条件（条件、操作）。这在需要多个操作保证一致性时非常有用。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>事务操作通过一个三元组的形式指定：<strong>比较 → 如果成立 → 如果不成立</strong>。可以串联多个条件，每个条件包含对应的操作分支。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这里是一个简单的示例，展示如何使用 <code>etcdctl txn</code> 命令进行事务操作：</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>假设有一个键 <code>foo</code>，我们希望：</p><ul><li>如果 <code>foo</code> 的值是 <code>bar</code>，则更新 <code>foo</code> 的值为 <code>baz</code>。</li><li>否则，设置一个键 <code>newkey</code>，其值为 <code>newvalue</code>。</li></ul><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">etcdctl txn &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">compares:</span></span><br><span class="line"><span class="string">  value(&quot;foo&quot;) = &quot;bar&quot;</span></span><br><span class="line"><span class="string">success:</span></span><br><span class="line"><span class="string">  put &quot;foo&quot; &quot;baz&quot;</span></span><br><span class="line"><span class="string">failure:</span></span><br><span class="line"><span class="string">  put &quot;newkey&quot; &quot;newvalue&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h3 id="操作解析"><a href="#操作解析" class="headerlink" title="操作解析"></a>操作解析</h3><ol><li><p><strong>比较条件</strong>：</p><ul><li><code>value(&quot;foo&quot;) = &quot;bar&quot;</code>：检查键 <code>foo</code> 当前的值是否为 <code>bar</code>。</li></ul></li><li><p><strong>成功操作</strong>：</p><ul><li>如果上述条件成立，则执行 <code>put &quot;foo&quot; &quot;baz&quot;</code>：将键 <code>foo</code> 的值设置为 <code>baz</code>。</li></ul></li><li><p><strong>失败操作</strong>：</p><ul><li>如果条件不成立，则执行 <code>put &quot;newkey&quot; &quot;newvalue&quot;</code>：将键 <code>newkey</code> 的值设置为 <code>newvalue</code>。</li></ul></li></ol><h3 id="更多比较类型"><a href="#更多比较类型" class="headerlink" title="更多比较类型"></a>更多比较类型</h3><p><code>etcdctl txn</code> 支持多种比较类型：</p><ul><li><code>value(&quot;key&quot;) &lt;op&gt; &quot;value&quot;</code>：比较给定键的值。</li><li><code>version(&quot;key&quot;) &lt;op&gt; &quot;version&quot;</code>：比较键的版本号。</li><li><code>createRevision(&quot;key&quot;) &lt;op&gt; &quot;revision&quot;</code>：比较键的创建修订。</li><li><code>modRevision(&quot;key&quot;) &lt;op&gt; &quot;revision&quot;</code>：比较键的修改修订。</li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符 <code>&lt;op&gt;</code> 可以为以下之一：</p><ul><li><code>=</code>：等于</li><li><code>!=</code>：不等于</li><li><code>&lt;</code>：小于</li><li><code>&lt;=</code>：小于等于</li><li><code>&gt;</code>：大于</li><li><code>&gt;=</code>：大于等于</li></ul><h3 id="结果判断"><a href="#结果判断" class="headerlink" title="结果判断"></a>结果判断</h3><p>事务执行后，<code>etcd</code> 将返回一个事务结果，其中包含哪些操作被成功执行的信息。使用返回的信息可以进一步决定应用程序逻辑。</p><p>通过事务操作，你可以确保在复杂条件下的多步骤状态变更的一致性，这在分布式系统中至关重要。使用 <code>etcdctl txn</code> 和其他 API 选项可以来实现更复杂的操作和控制流程。</p><p><code>etcdctl watch</code> 命令用于监视 <code>etcd</code> 中的键值变化。它可以实时监控键值的变化，并提供回调机制来处理变化事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> watch stock1</span><br></pre></td></tr></table></figure><p><code>etcdctl watch</code> 命令的常用选项：</p><ul><li><code>--endpoints</code>：指定 <code>etcd</code> 集群的端点地址。</li><li><code>--prefix</code>：监视具有相同前缀的键。</li><li><code>--recursive</code>：递归监视键值变化。</li></ul><h2 id="租约机制"><a href="#租约机制" class="headerlink" title="租约机制"></a>租约机制</h2><p>在 <code>etcd</code> 中，租约（Lease）是一种机制，用于管理键值的生存时间。通过使用租约，你可以为键值对设置一个TTL（生存时间），当租约到期时，绑定到该租约的键值对将自动删除。这在需要临时数据或心跳保持时非常有用。</p><h3 id="创建租约"><a href="#创建租约" class="headerlink" title="创建租约"></a>创建租约</h3><p>可以通过 <code>etcdctl lease grant</code> 命令来创建一个租约。以下是创建租约的步骤：</p><h4 id="步骤-1-创建租约"><a href="#步骤-1-创建租约" class="headerlink" title="步骤 1: 创建租约"></a>步骤 1: 创建租约</h4><p>使用 <code>lease grant</code> 命令创建一个租约，并指定其 TTL（以秒为单位）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lease grant &lt;ttl&gt;</span><br></pre></td></tr></table></figure><p>例如，要创建一个 10 秒的租约：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lease grant 10</span><br></pre></td></tr></table></figure><p>成功创建后，命令将返回租约 ID 和 TTL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lease 1234567890 granted with TTL(10s)</span><br></pre></td></tr></table></figure><h4 id="步骤-2-使用租约"><a href="#步骤-2-使用租约" class="headerlink" title="步骤 2: 使用租约"></a>步骤 2: 使用租约</h4><p>使用获得的租约 ID，你可以将其与一个或多个键值对绑定。这样做的操作是使用 <code>--lease</code> 选项来设置键：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl put mykey myvalue --lease=1234567890</span><br></pre></td></tr></table></figure><p>这意味着 <code>mykey</code> 的生存期受租约 <code>1234567890</code> 的控制。当租约到期时，<code>mykey</code> 将自动过期并被删除。</p><h3 id="查看租约"><a href="#查看租约" class="headerlink" title="查看租约"></a>查看租约</h3><p>可以使用 <code>etcdctl lease timetolive</code> 命令查看租约的剩余 TTL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lease timetolive 1234567890</span><br></pre></td></tr></table></figure><p>这将返回租约的剩余时间以及是否具有保持活性选项。</p><h3 id="刷新租约"><a href="#刷新租约" class="headerlink" title="刷新租约"></a>刷新租约</h3><p>如果想延长租约的生存时间，可以使用 <code>etcdctl lease keep-alive</code> 命令来刷新租约：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lease keep-alive 1234567890</span><br></pre></td></tr></table></figure><p>此命令将租约的 TTL 重新设置为其初始值。</p><h3 id="释放租约"><a href="#释放租约" class="headerlink" title="释放租约"></a>释放租约</h3><p>如果不再需要租约，可以使用 <code>etcdctl lease revoke</code> 命令来显式释放租约：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lease revoke 1234567890</span><br></pre></td></tr></table></figure><p>释放后，所有绑定到此租约的键将被立即删除。</p><p>利用租约机制，能够有效管理临时数据的生命期，并在分布式系统中实现心跳和故障检测等高级功能。请确保在生产环境中合理配置租约的 TTL 和续约策略，以确保数据和系统的稳定性。</p><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p><code>etcdctl lock</code> 命令用于在 <code>etcd</code> 中实现分布式锁。它允许你在多个节点之间协调对共享资源的访问，确保在分布式环境中只有一个节点能够访问和修改资源。</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>以下是 <code>etcdctl lock</code> 命令的基本用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl lock &lt;key&gt;</span><br></pre></td></tr></table></figure><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p><code>etcdctl elect</code> 命令用于在 <code>etcd</code> 中实现分布式选举。它允许你在多个节点之间协调选举过程，确保在分布式环境中只有一个节点能够成为领导者。</p><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>以下是 <code>etcdctl elect</code> 命令的基本用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> elect &lt;election-name&gt; &lt;leader-name&gt;</span><br></pre></td></tr></table></figure><h1 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h1><h2 id="检查整体状态"><a href="#检查整体状态" class="headerlink" title="检查整体状态"></a>检查整体状态</h2><p>endpoint status 检查 –endpoints 标志中指定的每个端点的整体状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl endpoint status (--endpoints=<span class="variable">$ENDPOINTS</span>|--cluster)</span><br></pre></td></tr></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--cluster[=<span class="literal">false</span>]: use all endpoints from the cluster member list</span><br></pre></td></tr></table></figure><h2 id="检查健康"><a href="#检查健康" class="headerlink" title="检查健康"></a>检查健康</h2><p>endpoint health 检查 –endpoints 标记中指定的每个端点的健康状况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">etcdctl endpoint health (--endpoints=<span class="variable">$ENDPOINTS</span>|--cluster)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--cluster[=<span class="literal">false</span>]: use all endpoints from the cluster member list</span><br></pre></td></tr></table></figure><h2 id="检查KV-hash"><a href="#检查KV-hash" class="headerlink" title="检查KV hash"></a>检查KV hash</h2><p>endpoint hashkv 检查 –endpoints 标记中指定的每个端点的 KV 历史哈希值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl endpoint hashkv (--endpoints=<span class="variable">$ENDPOINTS</span>|--cluster) [rev=<span class="variable">$REV</span>]</span><br></pre></td></tr></table></figure><h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--cluster[=<span class="literal">false</span>]: use all endpoints from the cluster member list</span><br><span class="line">--rev=0: maximum revision to <span class="built_in">hash</span> (default: latest revision)</span><br></pre></td></tr></table></figure><h2 id="继承选项"><a href="#继承选项" class="headerlink" title="继承选项"></a>继承选项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--endpoints=<span class="string">&quot;127.0.0.1:2379&quot;</span>: gRPC endpoints</span><br><span class="line">-w, --write-out=<span class="string">&quot;simple&quot;</span>: <span class="built_in">set</span> the output format (fields, json, protobuf, simple, table)</span><br></pre></td></tr></table></figure><h2 id="快照机制"><a href="#快照机制" class="headerlink" title="快照机制"></a>快照机制</h2><p>snapshot save 创建集群的快照备份：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINT</span> snapshot save DB_NAME</span><br></pre></td></tr></table></figure><h3 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--endpoints=[127.0.0.1:2379], gRPC endpoints</span><br></pre></td></tr></table></figure><p>只能从一个 etcd 节点请求快照，因此 –endpoints 标志应只包含一个端点。</p><h2 id="API版本从v2切换到v3"><a href="#API版本从v2切换到v3" class="headerlink" title="API版本从v2切换到v3"></a>API版本从v2切换到v3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># write key in etcd version 2 store</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=2</span><br><span class="line">etcdctl --endpoints=http://<span class="variable">$ENDPOINT</span> <span class="built_in">set</span> foo bar</span><br><span class="line"></span><br><span class="line"><span class="comment"># read key in etcd v2</span></span><br><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> --output=<span class="string">&quot;json&quot;</span> get foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># stop etcd node to migrate, one by one</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># migrate v2 data</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINT</span> migrate --data-dir=<span class="string">&quot;default.etcd&quot;</span> --wal-dir=<span class="string">&quot;default.etcd/member/wal&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># restart etcd node after migrate, one by one</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># confirm that the key got migrated</span></span><br><span class="line">etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> get /foo</span><br></pre></td></tr></table></figure><h2 id="添加-删除etcd节点"><a href="#添加-删除etcd节点" class="headerlink" title="添加&#x2F;删除etcd节点"></a>添加&#x2F;删除etcd节点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For each machine</span></span><br><span class="line">TOKEN=my-etcd-token-1</span><br><span class="line">CLUSTER_STATE=new</span><br><span class="line">NAME_1=etcd-node-1</span><br><span class="line">NAME_2=etcd-node-2</span><br><span class="line">NAME_3=etcd-node-3</span><br><span class="line">HOST_1=10.240.0.13</span><br><span class="line">HOST_2=10.240.0.14</span><br><span class="line">HOST_3=10.240.0.15</span><br><span class="line">CLUSTER=<span class="variable">$&#123;NAME_1&#125;</span>=http://<span class="variable">$&#123;HOST_1&#125;</span>:2380,<span class="variable">$&#123;NAME_2&#125;</span>=http://<span class="variable">$&#123;HOST_2&#125;</span>:2380,<span class="variable">$&#123;NAME_3&#125;</span>=http://<span class="variable">$&#123;HOST_3&#125;</span>:2380</span><br><span class="line"></span><br><span class="line"><span class="comment"># For node 1</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_1&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_1&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> \</span><br><span class="line">--initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For node 2</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_2&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_2&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> \</span><br><span class="line">--initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For node 3</span></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_3&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_3&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> \</span><br><span class="line">--initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br></pre></td></tr></table></figure><p>然后用 member remove 和 member add 命令替换一个成员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get member ID</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">HOST_1=10.240.0.13</span><br><span class="line">HOST_2=10.240.0.14</span><br><span class="line">HOST_3=10.240.0.15</span><br><span class="line">etcdctl --endpoints=<span class="variable">$&#123;HOST_1&#125;</span>:2379,<span class="variable">$&#123;HOST_2&#125;</span>:2379,<span class="variable">$&#123;HOST_3&#125;</span>:2379 member list</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove the member</span></span><br><span class="line">MEMBER_ID=278c654c9a6dfd3b</span><br><span class="line">etcdctl --endpoints=<span class="variable">$&#123;HOST_1&#125;</span>:2379,<span class="variable">$&#123;HOST_2&#125;</span>:2379,<span class="variable">$&#123;HOST_3&#125;</span>:2379 \</span><br><span class="line">member remove <span class="variable">$&#123;MEMBER_ID&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add a new member (node 4)</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">NAME_1=etcd-node-1</span><br><span class="line">NAME_2=etcd-node-2</span><br><span class="line">NAME_4=etcd-node-4</span><br><span class="line">HOST_1=10.240.0.13</span><br><span class="line">HOST_2=10.240.0.14</span><br><span class="line">HOST_4=10.240.0.16 <span class="comment"># new member</span></span><br><span class="line">etcdctl --endpoints=<span class="variable">$&#123;HOST_1&#125;</span>:2379,<span class="variable">$&#123;HOST_2&#125;</span>:2379 \</span><br><span class="line">member add <span class="variable">$&#123;NAME_4&#125;</span> \</span><br><span class="line">--peer-urls=http://<span class="variable">$&#123;HOST_4&#125;</span>:2380</span><br></pre></td></tr></table></figure><p>接下来，使用 –initial-cluster-state existing 标志启动新成员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [WARNING] If the new member starts from the same disk space,</span></span><br><span class="line"><span class="comment"># make sure to remove the data directory of the old member</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># restart with &#x27;existing&#x27; flag</span></span><br><span class="line">TOKEN=my-etcd-token-1</span><br><span class="line">CLUSTER_STATE=existing</span><br><span class="line">NAME_1=etcd-node-1</span><br><span class="line">NAME_2=etcd-node-2</span><br><span class="line">NAME_4=etcd-node-4</span><br><span class="line">HOST_1=10.240.0.13</span><br><span class="line">HOST_2=10.240.0.14</span><br><span class="line">HOST_4=10.240.0.16 <span class="comment"># new member</span></span><br><span class="line">CLUSTER=<span class="variable">$&#123;NAME_1&#125;</span>=http://<span class="variable">$&#123;HOST_1&#125;</span>:2380,<span class="variable">$&#123;NAME_2&#125;</span>=http://<span class="variable">$&#123;HOST_2&#125;</span>:2380,<span class="variable">$&#123;NAME_4&#125;</span>=http://<span class="variable">$&#123;HOST_4&#125;</span>:2380</span><br><span class="line"></span><br><span class="line">THIS_NAME=<span class="variable">$&#123;NAME_4&#125;</span></span><br><span class="line">THIS_IP=<span class="variable">$&#123;HOST_4&#125;</span></span><br><span class="line">etcd --data-dir=data.etcd --name <span class="variable">$&#123;THIS_NAME&#125;</span> \</span><br><span class="line">--initial-advertise-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--listen-peer-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2380 \</span><br><span class="line">--advertise-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--listen-client-urls http://<span class="variable">$&#123;THIS_IP&#125;</span>:2379 \</span><br><span class="line">--initial-cluster <span class="variable">$&#123;CLUSTER&#125;</span> \</span><br><span class="line">--initial-cluster-state <span class="variable">$&#123;CLUSTER_STATE&#125;</span> \</span><br><span class="line">--initial-cluster-token <span class="variable">$&#123;TOKEN&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day04</title>
    <link href="/2025/02/13/2025-02-13-golanghttp%E5%BA%93%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/02/13/2025-02-13-golanghttp%E5%BA%93%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="1-整体框架"><a href="#1-整体框架" class="headerlink" title="1 整体框架"></a>1 整体框架</h1><h2 id="1-1-C-S架构"><a href="#1-1-C-S架构" class="headerlink" title="1.1 C-S架构"></a>1.1 C-S架构</h2><p>http 协议下，交互框架是由客户端（Client）和服务端（Server）两个模块组成的 C-S 架构，两个部分正好对应为本文研究的两条主线.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Client] --&gt;|HTTP Request| B[http.Client]</span><br><span class="line">    B --&gt;|Send Request| C[Transport]</span><br><span class="line">    C --&gt;|Dial| D[Network]</span><br><span class="line">    D --&gt;|Send to Server| E[Server]</span><br><span class="line">    E --&gt;|Handle Request| F[http.ServeMux]</span><br><span class="line">    F --&gt;|Call Handler| G[Handler Function]</span><br><span class="line">    G --&gt;|Generate Response| H[Response]</span><br><span class="line">    H --&gt;|Send Response| E</span><br><span class="line">    E --&gt;|Return Response| D</span><br><span class="line">    D --&gt;|Return to Client| C</span><br><span class="line">    C --&gt;|Return Response| B</span><br><span class="line">    B --&gt;|Receive Response| A</span><br><span class="line"></span><br><span class="line">    subgraph Server Flow</span><br><span class="line">        E --&gt;|Listen for Request| D</span><br><span class="line">        D --&gt;|Handle Incoming Connections| E</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph Client Flow</span><br><span class="line">        A --&gt;|Create Request| B</span><br><span class="line">        B --&gt;|Set Headers/Params| B</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h2 id="1-2-启动-http-服务"><a href="#1-2-启动-http-服务" class="headerlink" title="1.2 启动 http 服务"></a>1.2 启动 http 服务</h2><p>在 Golang 启动一个 http 服务只需寥寥数笔，非常方便，代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;pong&quot;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8091&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，完成了两件事：</p><ul><li> 调用 http.HandleFunc 方法，注册了对应于请求路径 &#x2F;ping 的 handler 函数</li><li> 调用 http.ListenAndServe，启动了一个端口为 8091 的 http 服务</li></ul><p>如此简洁轻便即实现了一个 http server 的启动，其背后究竟隐藏了哪些实施细节呢. 这个问题，就让我们在第 2 章的内容中，和大家一同展开探讨.</p><h2 id="1-3-发送-http-请求"><a href="#1-3-发送-http-请求" class="headerlink" title="1.3 发送 http 请求"></a>1.3 发送 http 请求</h2><p>在 Golang 中发送 http 请求的实现同样非常简单. 下面给出一例发送 JSON POST 请求的代码示例.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    reqBody, _ := json.Marshal(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;key1&quot;</span>: <span class="string">&quot;val1&quot;</span>, <span class="string">&quot;key2&quot;</span>: <span class="string">&quot;val2&quot;</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    resp, _ := http.Post(<span class="string">&quot;:8091&quot;</span>, <span class="string">&quot;application/json&quot;</span>, bytes.NewReader(reqBody))</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    </span><br><span class="line">    respBody, _ := io.ReadAll(resp.Body)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;resp: %s&quot;</span>, respBody)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分将作为本文的第二条线索，放在第 3 章中展开讨论.</p><h2 id="1-4-源码位置一览"><a href="#1-4-源码位置一览" class="headerlink" title="1.4 源码位置一览"></a>1.4 源码位置一览</h2><p>本文涉及内容的源码均位于 net&#x2F;http 库下，各模块的文件位置如下表所示：</p><table><thead><tr><th><strong>模块</strong></th><th><strong>文件</strong></th></tr></thead><tbody><tr><td>服务端</td><td>net&#x2F;http&#x2F;server.go</td></tr><tr><td>客户端——主流程</td><td>net&#x2F;http&#x2F;client.go</td></tr><tr><td>客户端——构造请求</td><td>net&#x2F;http&#x2F;request.go</td></tr><tr><td>客户端——网络交互</td><td>net&#x2F;http&#x2F;transport.go</td></tr></tbody></table><h1 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2 服务端"></a>2 服务端</h1><h2 id="2-1-核心数据结构"><a href="#2-1-核心数据结构" class="headerlink" title="2.1 核心数据结构"></a>2.1 核心数据结构</h2><p>首先对 http 服务端模块涉及的核心数据结构作简要介绍.</p><p>（1）Server</p><p>基于面向对象的思想，整个 http 服务端模块被封装在 Server 类当中.</p><p>Handler 是 Server 中最核心的成员字段，实现了从请求路径 path 到具体处理函数 handler 的注册和映射能力.</p><p>在用户构造 Server 对象时，倘若其中的 Handler 字段未显式声明，则会取 net&#x2F;http 包下的单例对象 DefaultServeMux（ServerMux 类型） 进行兜底.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// server 的地址</span></span><br><span class="line">    Addr <span class="type">string</span></span><br><span class="line">    <span class="comment">// 路由处理器.</span></span><br><span class="line">    Handler Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）Handler</p><p>Handler 是一个 interface，定义了方法： ServeHTTP.</p><p>该方法的作用是，根据 http 请求 Request 中的请求路径 path 映射到对应的 handler 处理函数，对请求进行处理和响应.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;    </span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）ServeMux</p><p>ServeMux 是对 Handler 的具体实现，内部通过一个 map 维护了从 path 到 handler 的映射关系.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]muxEntry</span><br><span class="line">    es []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">    hosts <span class="type">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）muxEntry</p><p>muxEntry 为一个 handler 单元，内部包含了请求路径 path + 处理函数 handler 两部分.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    h Handler</span><br><span class="line">    pattern <span class="type">string</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-注册-handler"><a href="#2-2-注册-handler" class="headerlink" title="2.2 注册 handler"></a>2.2 注册 handler</h2><p>首先给出服务端注册 handler 的主干链路，避免晕车.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Server] --&gt;|Create Mux| B[http.ServeMux]</span><br><span class="line">    B --&gt;|Register Route| C[HandleFunc]</span><br><span class="line">    C --&gt;|Set Handler| D[http.Handler]</span><br><span class="line">    D --&gt;|Invoke| E[Handler Function]</span><br><span class="line">    E --&gt;|Generate Response| F[Response]</span><br><span class="line">    F --&gt;|Return to Mux| B</span><br><span class="line">    B --&gt;|Send Response| G[Client]</span><br><span class="line">    </span><br><span class="line">    subgraph Handler Registration</span><br><span class="line">        A --&gt;|Listen on Port| H[http.ListenAndServe]</span><br><span class="line">        H --&gt;|Attach Mux| B</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>在 net&#x2F;http 包下声明了一个单例 ServeMux，当用户直接通过公开方法 http.HandleFunc 注册 handler 时，则会将其注册到 DefaultServeMux 当中.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123; </span><br><span class="line"></span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ServeMux.HandleFunc 内部会将处理函数 handler 转为实现了 ServeHTTP 方法的 HandlerFunc 类型，将其作为 Handler interface 的实现类注册到 ServeMux 的路由 map 当中.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).  实现Handler的interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> HandleFunc(pattern <span class="type">string</span>, handler <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现路由注册的核心逻辑位于 ServeMux.Handle 方法中，两个核心逻辑值得一提：</p><ul><li><p>将 path 和 handler 包装成一个 muxEntry，以 path 为 key 注册到路由 map ServeMux.m 中</p></li><li><p>响应模糊匹配机制. 对于以 ‘&#x2F;‘ 结尾的 path，根据 path 长度将 muxEntry 有序插入到数组 ServeMux.es 中.（模糊匹配机制的伏笔在 2.3 小节回收）</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> Handle(pattern <span class="type">string</span>, handler Handler) &#123;</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">    mux.m[pattern] = e</span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">        mux.es = appendSorted(mux.es, e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSorted</span><span class="params">(es []muxEntry, e muxEntry)</span></span> []muxEntry &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(es)</span><br><span class="line">    i := sort.Search(n, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(es[i].pattern) &lt; <span class="built_in">len</span>(e.pattern)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> i == n &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">append</span>(es, e)</span><br><span class="line">    &#125;</span><br><span class="line">    es = <span class="built_in">append</span>(es, muxEntry&#123;&#125;) <span class="comment">// try to grow the slice in place, any entry works.</span></span><br><span class="line">    <span class="built_in">copy</span>(es[i+<span class="number">1</span>:], es[i:])      <span class="comment">// Move shorter entries down</span></span><br><span class="line">    es[i] = e</span><br><span class="line">    <span class="keyword">return</span> es</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-启动-server"><a href="#2-3-启动-server" class="headerlink" title="2.3 启动 server"></a>2.3 启动 server</h2><p>调用 net&#x2F;http 包下的公开方法 ListenAndServe，可以实现对服务端的一键启动. 内部会声明一个新的 Server 对象，嵌套执行 Server.ListenAndServe 方法.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server.ListenAndServe 方法中，根据用户传入的端口，申请到一个监听器 listener，继而调用 Server.Serve 方法.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> ListenAndServe() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    addr := srv.Addr</span><br><span class="line">    <span class="keyword">if</span> addr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        addr = <span class="string">&quot;:http&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ln, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="keyword">return</span> srv.Serve(ln)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Server.Serve开始] --&gt;|创建Context| B[添加Server到Context]</span><br><span class="line">    B --&gt; C[进入For循环]</span><br><span class="line">    C --&gt;|阻塞等待| D[Listener.Accept]</span><br><span class="line">    D --&gt;|新连接到达| E[创建新的conn]</span><br><span class="line">    E --&gt;|异步处理| F[启动goroutine]</span><br><span class="line">    F --&gt; G[执行conn.serve]</span><br><span class="line">    G --&gt; H[处理请求]</span><br><span class="line">    H --&gt; I[返回响应]</span><br><span class="line">    I --&gt; J[关闭连接]</span><br><span class="line">    </span><br><span class="line">    C --&gt;|继续循环| D</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;每个连接的处理流程&quot;</span><br><span class="line">        F</span><br><span class="line">        G</span><br><span class="line">        H </span><br><span class="line">        I</span><br><span class="line">        J</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;主循环&quot;</span><br><span class="line">        C</span><br><span class="line">        D</span><br><span class="line">        E</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>Server.Serve 方法很核心，体现了 http 服务端的运行架构：for + listener.accept 模式.</p><ul><li>将 server 封装成一组 kv 对，添加到 context 当中</li><li>开启 for 循环，每轮循环调用 Listener.Accept 方法阻塞等待新连接到达</li><li>每有一个连接到达，创建一个 goroutine 异步执行 conn.serve 方法负责处理</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ServerContextKey = &amp;contextKey&#123;<span class="string">&quot;http-server&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> contextKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, err := l.Accept()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        connCtx := ctx</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(connCtx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>conn.serve 是响应客户端连接的核心方法：</p><ul><li>从 conn 中读取到封装到 response 结构体，以及请求参数 http.Request</li><li>调用 serveHandler.ServeHTTP 方法，根据请求的 path 为其分配 handler</li><li>通过特定 handler 处理并响应请求</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> serve(ctx context.Context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    c.r = &amp;connReader&#123;conn: c&#125;</span><br><span class="line">    c.bufr = newBufioReader(c.r)</span><br><span class="line">    c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        w, err := c.readRequest(ctx)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">        w.cancelCtx()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 serveHandler.ServeHTTP 方法中，会对 Handler 作判断，倘若其未声明，则取全局单例 DefaultServeMux 进行路由匹配，呼应了 http.HandleFunc 中的处理细节.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span></span> ServeHTTP(rw ResponseWriter, req *Request) &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![[..&#x2F;pictures&#x2F;servehttp.png]]</p><p>接下来，兜兜转转依次调用 ServeMux.ServeHTTP、ServeMux.Handler、ServeMux.handler 等方法，最终在 ServeMux.match 方法中，以 Request 中的 path 为 pattern，在路由字典 Server.m 中匹配 handler，最后调用 handler.ServeHTTP 方法进行请求的处理和响应.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> Handler(r *Request) (h Handler, pattern <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> handler(host, path <span class="type">string</span>) (h Handler, pattern <span class="type">string</span>) &#123;</span><br><span class="line">    mux.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    h, pattern = mux.match(path)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，当通过路由字典 Server.m 未命中 handler 时，此时会启动模糊匹配模式，两个核心规则如下：</p><ul><li>以 ‘&#x2F;‘ 结尾的 pattern 才能被添加到 Server.es 数组中，才有资格参与模糊匹配</li><li>模糊匹配时，会找到一个与请求路径 path 前缀完全匹配且长度最长的 pattern，其对应的handler 会作为本次请求的处理函数.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> match(path <span class="type">string</span>) (h Handler, pattern <span class="type">string</span>) &#123;</span><br><span class="line">    v, ok := mux.m[path]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServeMux.es 本身是按照 pattern 的长度由大到小排列的</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> mux.es &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.HasPrefix(path, e.pattern) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.h, e.pattern</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，2.2 小节中模糊匹配问题的伏笔回收.</p><h1 id="3-客户端"><a href="#3-客户端" class="headerlink" title="3 客户端"></a>3 客户端</h1><h2 id="3-1-核心数据结构"><a href="#3-1-核心数据结构" class="headerlink" title="3.1 核心数据结构"></a>3.1 核心数据结构</h2><p>（1）Client</p><p>与 Server 对仗，客户端模块也有一个 Client 类，实现对整个模块的封装：</p><ul><li>Transport：负责 http 通信的核心部分，也是接下来的讨论重点</li><li>Jar：cookie 管理</li><li>Timeout：超时设置</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Transport RoundTripper</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Jar CookieJar</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）RoundTripper</p><p>RoundTripper 是通信模块的 interface，需要实现方法 Roundtrip，即通过传入请求 Request，与服务端交互后获得响应 Response.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> &#123;    </span><br><span class="line">RoundTrip(*Request) (*Response, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）Transport</p><p>Tranport 是 RoundTripper 的实现类，核心字段包括：</p><ul><li>idleConn：空闲连接 map，实现复用</li><li>DialContext：新连接生成器</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> &#123;</span><br><span class="line">    idleConn     <span class="keyword">map</span>[connectMethodKey][]*persistConn <span class="comment">// most recently used at end</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    DialContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）Request</p><p>http 请求参数结构体.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    Method <span class="type">string</span></span><br><span class="line">    <span class="comment">// 请求路径</span></span><br><span class="line">    URL *url.URL</span><br><span class="line">    <span class="comment">// 请求头</span></span><br><span class="line">    Header Header</span><br><span class="line">    <span class="comment">// 请求参数内容</span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line">    <span class="comment">// 服务器主机</span></span><br><span class="line">    Host <span class="type">string</span></span><br><span class="line">    <span class="comment">// query 请求参数</span></span><br><span class="line">    Form url.Values</span><br><span class="line">    <span class="comment">// 响应参数 struct</span></span><br><span class="line">    Response *Response</span><br><span class="line">    <span class="comment">// 请求链路的上下文</span></span><br><span class="line">    ctx context.Context</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）Response</p><p>http 响应参数结构体.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 请求状态，200 为 请求成功</span></span><br><span class="line">    StatusCode <span class="type">int</span>    <span class="comment">// e.g. 200</span></span><br><span class="line">    <span class="comment">// http 协议，如：HTTP/1.0</span></span><br><span class="line">    Proto      <span class="type">string</span> <span class="comment">// e.g. &quot;HTTP/1.0&quot;</span></span><br><span class="line">    <span class="comment">// 请求头</span></span><br><span class="line">    Header Header</span><br><span class="line">    <span class="comment">// 响应参数内容  </span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line">    <span class="comment">// 指向请求参数</span></span><br><span class="line">    Request *Request</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-方法链路总览"><a href="#3-2-方法链路总览" class="headerlink" title="3.2 方法链路总览"></a>3.2 方法链路总览</h2><p>客户端发起一次 http 请求大致分为几个步骤：</p><ul><li>• 构造 http 请求参数</li><li>• 获取用于与服务端交互的 tcp 连接</li><li>• 通过 tcp 连接发送请求参数</li><li>• 通过 tcp 连接接收响应结果</li></ul><p>整体方法链路如下图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[客户端代码] --&gt;|NewRequest| B[http.NewRequest]</span><br><span class="line">    B --&gt;|Do| C[http.Client]</span><br><span class="line">    C --&gt;|Transport.RoundTrip| D[http.Transport]</span><br><span class="line">    D --&gt;|Dial| E[net.Dial]</span><br><span class="line">    E --&gt;|Establish TCP Connection| F[TCP 连接]</span><br><span class="line">    F --&gt;|Write| G[TCP Conn.Write]</span><br><span class="line">    G --&gt;|Send HTTP Request| H[HTTP 服务器]</span><br><span class="line">    H --&gt;|Process Request| I[HTTP 响应]</span><br><span class="line">    I --&gt;|Read| J[TCP Conn.Read]</span><br><span class="line">    J --&gt;|Return Response| D</span><br><span class="line">    D --&gt;|Return Response| C</span><br><span class="line">    C --&gt;|Handle Response| A</span><br><span class="line"></span><br><span class="line">    subgraph 客户端</span><br><span class="line">        A --&gt; B</span><br><span class="line">        B --&gt; C</span><br><span class="line">        C --&gt; D</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 网络层</span><br><span class="line">        D --&gt; E</span><br><span class="line">        E --&gt; F</span><br><span class="line">        F --&gt; G</span><br><span class="line">        G --&gt; J</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 服务器</span><br><span class="line">        H --&gt; I</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 客户端</span><br><span class="line">        D --&gt; C</span><br><span class="line">        C --&gt; A</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h2 id="3-3-Client-Post"><a href="#3-3-Client-Post" class="headerlink" title="3.3 Client.Post"></a>3.3 Client.Post</h2><p>调用 net&#x2F;http 包下的公开方法 Post 时，需要传入服务端地址 url，请求参数格式 contentType 以及请求参数的 io reader.</p><p>方法中会使用包下的单例客户端 DefaultClient 处理这次请求.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultClient = &amp;Client&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Post</span><span class="params">(url, contentType <span class="type">string</span>, body io.Reader)</span></span> (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultClient.Post(url, contentType, body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Client.Post 方法中，首先会结合用户的入参，构造出完整的请求参数 Request；继而通过 Client.Do 方法，处理这笔请求.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Post(url, contentType <span class="type">string</span>, body io.Reader) (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">    req, err := NewRequest(<span class="string">&quot;POST&quot;</span>, url, body)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, contentType)</span><br><span class="line">    <span class="keyword">return</span> c.Do(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-NewRequest"><a href="#3-4-NewRequest" class="headerlink" title="3.4 NewRequest"></a>3.4 NewRequest</h2><p>NewRequestWithContext 方法中，根据用户传入的 url、method等信息，构造了 Request 实例.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequestWithContext</span><span class="params">(ctx context.Context, method, url <span class="type">string</span>, body io.Reader)</span></span> (*Request, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    u, err := urlpkg.Parse(url)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    rc, ok := body.(io.ReadCloser)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    req := &amp;Request&#123;</span><br><span class="line">        ctx:        ctx,</span><br><span class="line">        Method:     method,</span><br><span class="line">        URL:        u,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Header:     <span class="built_in">make</span>(Header),</span><br><span class="line">        Body:       rc,</span><br><span class="line">        Host:       u.Host,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-Client-Do"><a href="#3-5-Client-Do" class="headerlink" title="3.5 Client.Do"></a>3.5 Client.Do</h2><p>发送请求方法时，经由 Client.Do、Client.do 辗转，继而步入到 Client.send 方法中.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Do(req *Request) (*Response, <span class="type">error</span>) &#123;     </span><br><span class="line"><span class="keyword">return</span> c.do(req) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> do(req *Request) (retres *Response, reterr <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        deadline      = c.deadline()</span><br><span class="line">        resp          *Response</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    )    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">var</span> err <span class="type">error</span>       </span><br><span class="line">        <span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Client.send 方法中，会在通过 send 方法发送请求之前和之后，分别对 cookie 进行更新.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> send(req *Request, deadline time.Time) (resp *Response, didTimeout <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置 cookie 到请求头中</span></span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">            req.AddCookie(cookie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 resp 的 cookie 到请求头中</span></span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 send 方法时，需要注入 RoundTripper 模块，默认会使用全局单例 DefaultTransport 进行注入，核心逻辑位于 Transport.RoundTrip 方法中，其中分为两个步骤：</p><ul><li>• 获取&#x2F;构造 tcp 连接</li><li>• 通过 tcp 连接完成与服务端的交互</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    DialContext: defaultTransportDialContext(&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">        KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> transport() RoundTripper &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Transport</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span> (resp *Response, didTimeout <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    resp, err = rt.RoundTrip(req)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> RoundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;    </span><br><span class="line"><span class="keyword">return</span> t.roundTrip(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> roundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> &#123;          </span><br><span class="line">        <span class="comment">// ...    </span></span><br><span class="line">        treq := &amp;transportRequest&#123;Request: req, trace: trace, cancelKey: cancelKey&#125;      </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pconn, err := t.getConn(treq, cm)        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        resp, err = pconn.roundTrip(treq)          </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-Transport-getConn"><a href="#3-6-Transport-getConn" class="headerlink" title="3.6 Transport.getConn"></a>3.6 Transport.getConn</h2><p>获取 tcp 连接的策略分为两步：</p><ul><li>• 通过 queueForIdleConn 方法，尝试复用采用相同协议、访问相同服务端的空闲连接</li><li>• 倘若无可用连接，则通过 queueForDial 方法，异步创建一个新的连接，并通过接收 ready channel 信号的方式，确认构造连接的工作已经完成.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取连接的请求参数体</span></span><br><span class="line">    w := &amp;wantConn&#123;</span><br><span class="line">        cm:         cm,</span><br><span class="line">        <span class="comment">// key 由 http 协议、服务端地址等信息组成</span></span><br><span class="line">        key:        cm.key(),</span><br><span class="line">        ctx:        ctx,</span><br><span class="line">        <span class="comment">// 标识连接构造成功的信号发射器</span></span><br><span class="line">        ready:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倘若连接获取失败，在 wantConn.cancel 方法中，会尝试将 tcp 连接放回队列中以供后续复用</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            w.cancel(t, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 尝试复用指向相同服务端地址的空闲连接</span></span><br><span class="line">    <span class="keyword">if</span> delivered := t.queueForIdleConn(w); delivered &#123;</span><br><span class="line">        pc := w.pc</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步构造新的连接</span></span><br><span class="line">    t.queueForDial(w)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 通过阻塞等待信号的方式，等待连接获取完成</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-w.ready:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> w.pc, w.err</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）复用连接</p><ul><li>• 尝试从 Transport.idleConn 中获取指向同一服务端的空闲连接 persisConn</li><li>• 获取到连接后会调用 wantConn.tryDeliver 方法将连接绑定到 wantConn 请求参数上</li><li>• 绑定成功后，会关闭 wantConn.ready channel，以唤醒阻塞读取该 channel 的 goroutine</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> queueForIdleConn(w *wantConn) (delivered <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> list, ok := t.idleConn[w.key]; ok &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(list) &gt; <span class="number">0</span> &amp;&amp; !stop &#123;</span><br><span class="line">            pconn := list[<span class="built_in">len</span>(list)<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            delivered = w.tryDeliver(pconn, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> delivered &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                list = list[:<span class="built_in">len</span>(list)<span class="number">-1</span>]               </span><br><span class="line">            &#125;</span><br><span class="line">            stop = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> stop &#123;</span><br><span class="line">            <span class="keyword">return</span> delivered</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wantConn)</span></span> tryDeliver(pc *persistConn, err <span class="type">error</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    w.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> w.mu.Unlock()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    w.pc = pc</span><br><span class="line">    w.err = err</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">close</span>(w.ready)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建连接</p><p>在 queueForDial 方法会异步调用 Transport.dialConnFor 方法，创建新的 tcp 连接. 由于是异步操作，所以在上游会通过读 channel 的方式，等待创建操作完成.</p><p>这里之所以采用异步操作进行连接创建，有两部分原因：</p><ul><li>• 一个 tcp 连接并不是一个静态的数据结构，它是有生命周期的，创建过程中会为其创建负责读写的两个守护协程，伴随而生</li><li>• 在上游 Transport.queueForIdleConn 方法中，当通过 select 多路复用的方式，接收到其他终止信号时，可以提前调用 wantConn.cancel 方法打断创建连接的 goroutine. 相比于串行化执行而言，这种异步交互的模式，具有更高的灵活度</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> queueForDial(w *wantConn) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">go</span> t.dialConnFor(w) </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transport.dialConnFor 方法中，首先调用 Transport.dialConn 创建 tcp 连接 persisConn，接着执行 wantConn.tryDeliver 方法，将连接绑定到 wantConn 上，然后通过关闭 ready channel 操作唤醒上游读 ready channel 的 goroutine.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dialConnFor(w *wantConn) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pc, err := t.dialConn(w.ctx, w.cm)</span><br><span class="line">    delivered := w.tryDeliver(pc, err)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transport.dialConn 方法包含了创建连接的核心逻辑：</p><ul><li>• 调用 Transport.dial 方法，最终通过 Tranport.DialContext 成员函数，创建好 tcp 连接，封装到 persistConn 当中</li><li>• 异步启动连接的伴生读写协程 readLoop 和 writeLoop 方法，组成提交请求、接收响应的循环</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">    pconn = &amp;persistConn&#123;</span><br><span class="line">        t:             t,</span><br><span class="line">        reqch:         <span class="built_in">make</span>(<span class="keyword">chan</span> requestAndChan, <span class="number">1</span>),</span><br><span class="line">        writech:       <span class="built_in">make</span>(<span class="keyword">chan</span> writeRequest, <span class="number">1</span>),</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conn, err := t.dial(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pconn.conn = conn      </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">    <span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">    <span class="keyword">return</span> pconn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dial(ctx context.Context, network, addr <span class="type">string</span>) (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> t.DialContext(ctx, network, addr)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在伴生读协程 persisConn.readLoop 方法中，会读取来自服务端的响应，并添加到 persistConn.reqCh 中，供上游 persistConn.roundTrip 方法接收.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> readLoop() &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    alive := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> alive &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        rc := &lt;-pc.reqch</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">var</span> resp *Response</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        resp, err = pc.readResponse(rc, trace)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">select</span>&#123;</span><br><span class="line">            rc.ch &lt;- responseAndError&#123;res: resp&#125;:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...        </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>    </p><p>（3）归还连接</p><p>有复用连接的能力，就必然存在归还连接的机制.</p><p>首先，在构造新连接中途，倘若被打断，则可能会将连接放回队列以供复用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 倘若连接获取失败，在 wantConn.cancel 方法中，会尝试将 tcp 连接放回队列中以供后续复用</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            w.cancel(t, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wantConn)</span></span> cancel(t *Transport, err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> pc != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.putOrCloseIdleConn(pc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> tryPutIdleConn(pconn *persistConn) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    key := pconn.cacheKey</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    t.idleConn[key] = <span class="built_in">append</span>(idles, pconn)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，倘若与服务端的一轮交互流程结束，也会将连接放回队列以供复用.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> readLoop() &#123;</span><br><span class="line">    tryPutIdleConn := <span class="function"><span class="keyword">func</span><span class="params">(trace *httptrace.ClientTrace)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := pc.t.tryPutIdleConn(pc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    alive := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> alive &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> bodyEOF := &lt;-waitForBodyRead:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            tryPutIdleConn(trace)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> putOrCloseIdleConn(pconn *persistConn) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := t.tryPutIdleConn(pconn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        pconn.<span class="built_in">close</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-persistConn-roundTrip"><a href="#3-7-persistConn-roundTrip" class="headerlink" title="3.7 persistConn.roundTrip"></a>3.7 persistConn.roundTrip</h2><p>3.6 小节中谈到，一个连接 persistConn 是一个具有生命特征的角色. 它本身伴有 readLoop 和 writeLoop 两个守护协程，与上游应用者之间通过 channel 进行读写交互.</p><p>而其中扮演应用者这一角色的，正式本小节谈到的主流程中的方法：persistConn.roundTrip：</p><ul><li>• 首先将 http 请求通过 persistConn.writech 发送给连接的守护协程 writeLoop，并进一步传送到服务端</li><li>• 其次通过读取 resc channel，接收由守护协程 readLoop 代理转发的客户端响应数据.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> roundTrip(req *transportRequest) (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pc.writech &lt;- writeRequest&#123;req, writeErrCh, continueCh&#125;</span><br><span class="line">    resc := <span class="built_in">make</span>(<span class="keyword">chan</span> responseAndError)</span><br><span class="line">    pc.reqch &lt;- requestAndChan&#123;</span><br><span class="line">        req:        req.Request,</span><br><span class="line">        cancelKey:  req.cancelKey,</span><br><span class="line">        ch:         resc,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> &#123;    </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> re := &lt;-resc:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> re.res, <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>graph TD<br>    A[Server.Serve开始] –&gt;|创建Context| B[添加Server到Context]<br>    B –&gt; C[进入For循环]<br>    C –&gt;|阻塞等待| D[Listener.Accept]<br>    D –&gt;|新连接到达| E[创建新的conn]<br>    E –&gt;|异步处理| F[启动goroutine]<br>    F –&gt; G[执行conn.serve]<br>    G –&gt; H[处理请求]<br>    H –&gt; I[返回响应]<br>    I –&gt; J[关闭连接]</p><pre><code>C --&gt;|继续循环| Dsubgraph &quot;每个连接的处理流程&quot;    F    G    H     I    Jendsubgraph &quot;主循环&quot;    C    D    Eend</code></pre>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day04</title>
    <link href="/2025/02/13/2025-02-13-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day04/"/>
    <url>/2025/02/13/2025-02-13-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day04/</url>
    
    <content type="html"><![CDATA[<h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个长度为3元素类型为int的数组a</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><h2 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> b [<span class="number">4</span>]<span class="type">int</span></span><br><span class="line">a = b <span class="comment">//不可以这样做，因为此时a和b是不同的类型</span></span><br></pre></td></tr></table></figure><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化也有很多方式。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span>                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"><span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                 <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"><span class="keyword">var</span> cityArray = [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">fmt.Println(testArray)                      <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                       <span class="comment">//[1 2 0]</span></span><br><span class="line">fmt.Println(cityArray)                      <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> numArray = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray = [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">fmt.Println(testArray)                          <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                           <span class="comment">//[1 2]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of numArray:%T\n&quot;</span>, numArray)   <span class="comment">//type of numArray:[2]int</span></span><br><span class="line">fmt.Println(cityArray)                          <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of cityArray:%T\n&quot;</span>, cityArray) <span class="comment">//type of cityArray:[3]string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [...]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(a)                  <span class="comment">// [0 1 0 5]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:[4]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>遍历数组a有以下两种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 方法1：for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：for range遍历</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v1 := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\t&quot;</span>, v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">北京上海</span><br><span class="line">广州深圳</span><br><span class="line">成都重庆</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h2><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(x [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray2</span><span class="params">(x [3][2]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">modifyArray(a) <span class="comment">//在modify中修改的是a的副本x</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[10 20 30]</span></span><br><span class="line">b := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">int</span>&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">modifyArray2(b) <span class="comment">//在modify中修改的是b的副本x</span></span><br><span class="line">fmt.Println(b)  <span class="comment">//[[1 1] [1 1] [1 1]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>数组支持 “&#x3D;&#x3D;”、”!&#x3D;” 操作符，因为内存总是被初始化过的。</li><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>求数组<code>[1, 3, 5, 7, 8]</code>所有元素的和</li><li>找出数组中和为指定值的两个元素的下标，比如从数组<code>[1, 3, 5, 7, 8]</code>中找出和为8的两个元素的下标分别为<code>(0,3)</code>和<code>(1,2)</code>。</li></ol><p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySum</span><span class="params">(x [3]<span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x&#123;</span><br><span class="line">        sum = sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p><h2 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h2><p>声明切片类型的基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明切片类型</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="type">string</span>              <span class="comment">//声明一个字符串切片</span></span><br><span class="line"><span class="keyword">var</span> b = []<span class="type">int</span>&#123;&#125;             <span class="comment">//声明一个整型切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> c = []<span class="type">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> d = []<span class="type">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line">fmt.Println(a)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(b)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(c)              <span class="comment">//[false true]</span></span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>)       <span class="comment">//true</span></span><br><span class="line">fmt.Println(b == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line">fmt.Println(c == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line"><span class="comment">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p><h3 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h3><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><h4 id="简单切片表达式"><a href="#简单切片表达式" class="headerlink" title="简单切片表达式"></a>简单切片表达式</h4><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;s:%v len(s):%v cap(s):%v\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:[2 3] len(s):2 <span class="built_in">cap</span>(s):4</span><br></pre></td></tr></table></figure><p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>:]  <span class="comment">// 等同于 a[2:len(a)]</span></span><br><span class="line">a[:<span class="number">3</span>]  <span class="comment">// 等同于 a[0:3]</span></span><br><span class="line">a[:]   <span class="comment">// 等同于 a[0:len(a)]</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p><p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;s:%v len(s):%v cap(s):%v\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">s2 := s[<span class="number">3</span>:<span class="number">4</span>]  <span class="comment">// 索引的上限是cap(s)而不是len(s)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;s2:%v len(s2):%v cap(s2):%v\n&quot;</span>, s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s:[2 3] len(s):2 <span class="built_in">cap</span>(s):4</span><br><span class="line">s2:[5] len(s2):1 <span class="built_in">cap</span>(s2):1</span><br></pre></td></tr></table></figure><h4 id="完整切片表达式"><a href="#完整切片表达式" class="headerlink" title="完整切片表达式"></a>完整切片表达式</h4><p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high : max]</span><br></pre></td></tr></table></figure><p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;t:%v len(t):%v cap(t):%v\n&quot;</span>, t, <span class="built_in">len</span>(t), <span class="built_in">cap</span>(t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t:[2 3] len(t):2 <span class="built_in">cap</span>(t):4</span><br></pre></td></tr></table></figure><p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p><h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make([]T, size, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(a)      <span class="comment">//[0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a)) <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a)) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p><h3 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h3><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p><p>举个例子，现在有一个数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<img src="https://www.liwenzhou.com/images/Go/slice/slice_01.png" alt="slice_01">切片<code>s2 := a[3:6]</code>，相应示意图如下：<img src="https://www.liwenzhou.com/images/Go/slice/slice_02.png" alt="slice_02"></p><h3 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h3><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]</span></span><br><span class="line">s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">fmt.Println(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">fmt.Println(i, s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意：**通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;&#125;  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="type">int</span>)  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//append()添加元素和切片扩容</span></span><br><span class="line"><span class="keyword">var</span> numSlice []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numSlice = <span class="built_in">append</span>(numSlice, i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;</span>, numSlice, <span class="built_in">len</span>(numSlice), <span class="built_in">cap</span>(numSlice), numSlice)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0]  len:1  <span class="built_in">cap</span>:1  ptr:0xc0000a8000</span><br><span class="line">[0 1]  len:2  <span class="built_in">cap</span>:2  ptr:0xc0000a8040</span><br><span class="line">[0 1 2]  len:3  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3]  len:4  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3 4]  len:5  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5]  len:6  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6]  len:7  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7]  len:8  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7 8]  len:9  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br><span class="line">[0 1 2 3 4 5 6 7 8 9]  len:10  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><p>append()函数还支持一次性追加多个元素。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> citySlice []<span class="type">string</span></span><br><span class="line"><span class="comment">// 追加一个元素</span></span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, <span class="string">&quot;北京&quot;</span>)</span><br><span class="line"><span class="comment">// 追加多个元素</span></span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>)</span><br><span class="line"><span class="comment">// 追加切片</span></span><br><span class="line">a := []<span class="type">string</span>&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;</span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, a...)</span><br><span class="line">fmt.Println(citySlice) <span class="comment">//[北京 上海 广州 深圳 成都 重庆]</span></span><br></pre></td></tr></table></figure><h2 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h2><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出以下内容：</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap&#x3D;doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1&#x2F;4，即（newcap&#x3D;old.cap,for {newcap +&#x3D; newcap&#x2F;4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;&#x3D; cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p><h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h2><p>首先我们来看一个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := a</span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// copy()复制切片</span></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">copy</span>(c, a)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片c</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p><h2 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h2><p>1.请写出下面代码的输出结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">a = <span class="built_in">append</span>(a, fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, i))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.请使用内置的<code>sort</code>包对数组<code>var a = [...]int&#123;3, 7, 8, 9, 1&#125;</code>进行排序（附加题，自行查资料解答）。</p>]]></content>
    
    
    <categories>
      
      <category>开发学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day03</title>
    <link href="/2025/02/12/2025-02-12-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day03/"/>
    <url>/2025/02/12/2025-02-12-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day03/</url>
    
    <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else(分支结构)"></a>if else(分支结构)</h2><h3 id="if条件判断基本写法"><a href="#if条件判断基本写法" class="headerlink" title="if条件判断基本写法"></a>if条件判断基本写法</h3><p>Go语言中<code>if</code>条件判断的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</p><p>Go语言规定与<code>if</code>匹配的左括号<code>&#123;</code>必须与<code>if和表达式</code>放在同一行，<code>&#123;</code>放在其他位置会触发编译错误。 同理，与<code>else</code>匹配的<code>&#123;</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">score := <span class="number">65</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a>if条件判断特殊写法</h3><p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> score := <span class="number">65</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考题：</strong> 上下两种写法的区别在哪里？</p><h2 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for(循环结构)"></a>for(循环结构)</h2><p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p><p>for循环的基本格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。</p><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range(键值循环)"></a>for range(键值循环)</h2><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p><ol><li>数组、切片、字符串返回索引和值。</li><li>map返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ol><p>Go1.22版本开始支持 for range 整数。👉 <a href="https://go.dev/doc/go1.22">Go 1.22 Release Notes</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">5</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> <span class="number">2</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;《Go语言之路》上市啦！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">《Go语言之路》上市啦！</span><br><span class="line">《Go语言之路》上市啦！</span><br></pre></td></tr></table></figure><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">finger := <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> finger &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;大拇指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;食指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;中指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;无名指&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;小拇指&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;无效的输入！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSwitch3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n := <span class="number">7</span>; n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;奇数&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;偶数&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">age := <span class="number">30</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> age &lt; <span class="number">25</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;好好学习吧&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">25</span> &amp;&amp; age &lt; <span class="number">35</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;好好工作吧&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">60</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;好好享受吧&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;活着真好&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;c&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h2 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto(跳转到指定标签)"></a>goto(跳转到指定标签)</h2><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> breakFlag <span class="type">bool</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line">breakFlag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外层for循环判断</span></span><br><span class="line"><span class="keyword">if</span> breakFlag &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>goto</code>语句能简化代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line"><span class="keyword">goto</span> breakTag</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">// 标签</span></span><br><span class="line">breakTag:</span><br><span class="line">fmt.Println(<span class="string">&quot;结束for循环&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break(跳出循环)"></a>break(跳出循环)</h2><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p><p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breakDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">BREAKDEMO1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">break</span> BREAKDEMO1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue(继续下次循环)"></a>continue(继续下次循环)</h2><p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p><p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">continueDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">forloop1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// forloop2:</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> forloop1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写代码打印9*9乘法表。</li></ol>]]></content>
    
    
    <categories>
      
      <category>开发学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day02</title>
    <link href="/2025/02/12/2025-02-12-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day02/"/>
    <url>/2025/02/12/2025-02-12-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day02/</url>
    
    <content type="html"><![CDATA[<h1 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p><p>Go语言中有25个关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure><p>此外，Go语言中还有37个保留字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    Types:    <span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span>  </span><br><span class="line">              <span class="type">uint</span>  <span class="type">uint8</span>  <span class="type">uint16</span>  <span class="type">uint32</span>  <span class="type">uint64</span>  <span class="type">uintptr</span></span><br><span class="line">              <span class="type">float32</span>  <span class="type">float64</span>  <span class="type">complex128</span>  <span class="type">complex64</span></span><br><span class="line">              <span class="type">bool</span>  <span class="type">byte</span>  <span class="type">rune</span>  <span class="type">string</span>  <span class="type">error</span></span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">             <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">             <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h2><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p><p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p><h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="type">bool</span></span><br></pre></td></tr></table></figure><h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="type">string</span></span><br><span class="line">    b <span class="type">int</span></span><br><span class="line">    c <span class="type">bool</span></span><br><span class="line">    d <span class="type">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为<code>空字符串</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p><p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>或者一次初始化多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, age = <span class="string">&quot;Q1mi&quot;</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">10</span></span><br><span class="line">m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x, _ := foo()</span><br><span class="line">_, y := foo()</span><br><span class="line">fmt.Println(<span class="string">&quot;x=&quot;</span>, x)</span><br><span class="line">fmt.Println(<span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p><p>注意事项：</p><ol><li>函数外的每个语句都必须以关键字开始（var、const、func等）</li><li><code>:=</code>不能使用在函数外。</li><li><code>_</code>多用于占位，表示忽略值。</li></ol><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure><p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p><p>多个常量也可以一起声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p><p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1</span></span><br><span class="line">n3        <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="几个常见的iota示例"><a href="#几个常见的iota示例" class="headerlink" title="几个常见的iota示例:"></a>几个常见的<code>iota</code>示例:</h3><p>使用<code>_</code>跳过某些值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1</span></span><br><span class="line">_</span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>iota</code>声明中间插队</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">_  = <span class="literal">iota</span></span><br><span class="line">KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>多个<code>iota</code>定义在一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2</span></span><br><span class="line">c, d                      <span class="comment">//2,3</span></span><br><span class="line">e, f                      <span class="comment">//3,4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint8</td><td>无符号 8位整型 (0 到 255)</td></tr><tr><td>uint16</td><td>无符号 16位整型 (0 到 65535)</td></tr><tr><td>uint32</td><td>无符号 32位整型 (0 到 4294967295)</td></tr><tr><td>uint64</td><td>无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td>int8</td><td>有符号 8位整型 (-128 到 127)</td></tr><tr><td>int16</td><td>有符号 16位整型 (-32768 到 32767)</td></tr><tr><td>int32</td><td>有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td>int64</td><td>有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint</td><td>32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td></tr><tr><td>int</td><td>32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td></tr><tr><td>uintptr</td><td>无符号整型，用于存放一个指针</td></tr></tbody></table><p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p><p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p><h3 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h3><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p><p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。 <code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。 <code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p><p>而且还允许我们用 <code>_</code> 来分隔数字，比如说： <code>v := 123_456</code> 表示 v 的值等于 123456。</p><p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d \n&quot;</span>, a)  <span class="comment">// 10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b \n&quot;</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 八进制  以0开头</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">077</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%o \n&quot;</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十六进制  以0x开头</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">int</span> = <span class="number">0xff</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x \n&quot;</span>, c)  <span class="comment">// ff</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X \n&quot;</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code> 标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex64和complex128</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="type">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="type">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure><p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p><p><strong>注意：</strong></p><ol><li>布尔类型变量的默认值为<code>false</code>。</li><li>Go 语言中不允许将整型强制转换为布尔型.</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;你好&quot;</span></span><br></pre></td></tr></table></figure><h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h3><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td><code>\r</code></td><td>回车符（返回行首）</td></tr><tr><td><code>\n</code></td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\\</code></td><td>反斜杠</td></tr><tr><td>举个例子，我们要打印一个Windows平台下的一个文件路径：</td><td></td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;str := \&quot;c:\\Code\\lesson1\\go.exe\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>+或fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix,strings.HasSuffix</td><td>前缀&#x2F;后缀判断</td></tr><tr><td>strings.Index(),strings.LastIndex()</td><td>子串出现的位置</td></tr><tr><td>strings.Join(a[]string, sep string)</td><td>join操作</td></tr></tbody></table><h2 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h2><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;中&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p>Go 语言的字符有以下两种：</p><ol><li><code>uint8</code>类型，或者叫 byte 型，代表一个<code>ASCII码</code>字符。</li><li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li></ol><p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p><p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;hello沙河&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, s[i], s[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, r, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) </span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) </span><br></pre></td></tr></table></figure><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p><p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p><h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line">byteS1 := []<span class="type">byte</span>(s1)</span><br><span class="line">byteS1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line">runeS2 := []<span class="type">rune</span>(s2)</span><br><span class="line">runeS2[<span class="number">0</span>] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p><p>强制类型转换的基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p><p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line"><span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">c = <span class="type">int</span>(math.Sqrt(<span class="type">float64</span>(a*a + b*b)))</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写代码分别定义一个整型、浮点型、布尔型、字符串型变量，使用<code>fmt.Printf()</code>搭配<code>%T</code>分别打印出上述变量的值和类型。</li><li>编写代码统计出字符串<code>&quot;hello沙河小王子&quot;</code>中汉字的数量。</li></ol><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>Go 语言内置的运算符有：</p><ol><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li></ol><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>&#x2F;</td><td>相除</td></tr><tr><td>%</td><td>求余</td></tr></tbody></table><p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td>!&#x3D;</td><td>检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td>&gt;</td><td>检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&gt;&#x3D;</td><td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;&#x3D;</td><td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td>|</td><td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td>!</td><td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>参与运算的两数各对应的二进位相与。  <br>（两位均为1才为1）</td></tr><tr><td>|</td><td>参与运算的两数各对应的二进位相或。  <br>（两位有一个为1就为1）</td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。  <br>（两位不一样则为1）</td></tr><tr><td>«</td><td>左移n位就是乘以2的n次方。  <br>“a«b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td>»</td><td>右移n位就是除以2的n次方。  <br>“a»b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+&#x3D;</td><td>相加后再赋值</td></tr><tr><td>-&#x3D;</td><td>相减后再赋值</td></tr><tr><td>*&#x3D;</td><td>相乘后再赋值</td></tr><tr><td>&#x2F;&#x3D;</td><td>相除后再赋值</td></tr><tr><td>%&#x3D;</td><td>求余后再赋值</td></tr><tr><td>«&#x3D;</td><td>左移后赋值</td></tr><tr><td>»&#x3D;</td><td>右移后赋值</td></tr><tr><td>&amp;&#x3D;</td><td>按位与后赋值</td></tr><tr><td>|&#x3D;</td><td>按位或后赋值</td></tr><tr><td>^&#x3D;</td><td>按位异或后赋值</td></tr></tbody></table><h1 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h1><p>有一堆数字，如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？</p>]]></content>
    
    
    <categories>
      
      <category>开发学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cloudfare重定向问题处理</title>
    <link href="/2025/02/11/2025-02-11-cloudfare%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
    <url>/2025/02/11/2025-02-11-cloudfare%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天给GitHub Page套了层Cloudflare，结果访问时浏览器报“重定向次数过多”错误。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>通过百度查询，发现是HTTPS的问题。GitHub Page中打开了“Enforce HTTPS ”，这会让所有HTTP的链接重定向到HTTPS中。而Cloudflare回源使用的是HTTP链接，于是就出现了一遍遍的重定向，最终次数过多浏览器报错。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将Cloudflare中的SSL&#x2F;TLS 加密模式由“关闭”或“灵活”改为“完全”即可。</p>]]></content>
    
    
    <categories>
      
      <category>Deploy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang整体复习Day01</title>
    <link href="/2025/02/11/2025-02-11-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day01/"/>
    <url>/2025/02/11/2025-02-11-Golang%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0Day01/</url>
    
    <content type="html"><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>由于笔者工作与开发关系不大，因此已有许久没有复习过golang的语法和用例，最近在对运维平台的梳理过程中，想要用golang来做一下后端的实现，奈何基础知识基本上忘光了，连ai写都写不下去，故此开始复习一下相关内容，顺便整理一下之前杂乱的笔记。  </p><h1 id="0-从零开始搭建Go环境"><a href="#0-从零开始搭建Go环境" class="headerlink" title="0.从零开始搭建Go环境"></a>0.从零开始搭建Go环境</h1><h2 id="0-1-安装Go"><a href="#0-1-安装Go" class="headerlink" title="0.1 安装Go"></a>0.1 安装Go</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p>Go官网下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></p><p>Go官方镜像站（推荐）：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p><h4 id="版本的选择"><a href="#版本的选择" class="headerlink" title="版本的选择"></a>版本的选择</h4><p>Windows平台和Mac平台推荐下载可执行文件版，Linux平台下载压缩文件版。</p><p>笔者使用的是macos平台，因此下载的是go1.23.6.darwin-amd64.pkg这个版本。</p><p><img src="/../pictures/golang.png" alt="go下载页面"></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>双击下载的pkg文件，按照提示安装即可。</p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>笔者使用的是macos平台，因此需要配置环境变量。</p><p>在终端输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$PATH:/usr/local/go/bin&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>配置完成后，可以在终端输入go version查看是否安装成功。</p><p><img src="/../pictures/goversion.png" alt="go版本"></p><h4 id="运行第一个go程序"><a href="#运行第一个go程序" class="headerlink" title="运行第一个go程序"></a>运行第一个go程序</h4><p>这里可以参考<a href="https://tour.golang.org/welcome/1">Go官方教程</a></p><p>笔者这里选择的是<a href="https://tour.golang.org/welcome/1">Hello, World!</a></p><p>在ide中新建一个go文件，文件名可以为hello.go，文件内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run hello.go</span><br></pre></td></tr></table></figure><p>这样就能看到类似如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>至此，Go环境就配置完成了。</p><h1 id="1-依赖管理"><a href="#1-依赖管理" class="headerlink" title="1.依赖管理"></a>1.依赖管理</h1><h2 id="为什么需要依赖管理"><a href="#为什么需要依赖管理" class="headerlink" title="为什么需要依赖管理"></a>为什么需要依赖管理</h2><p>最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？</p><h2 id="godep"><a href="#godep" class="headerlink" title="godep"></a>godep</h2><p>Go语言从v1.5开始开始引入<code>vendor</code>模式，如果项目目录下有vendor目录，那么go工具链会优先使用<code>vendor</code>内的包进行编译、测试等。</p><p><code>godep</code>是一个通过vender模式实现的Go语言的第三方依赖管理工具，类似的还有由社区维护准官方包管理工具<code>dep</code>。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>执行以下命令安装<code>godep</code>工具。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/tools/godep</span><br></pre></td></tr></table></figure><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>安装好godep之后，在终端输入<code>godep</code>查看支持的所有命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">godep save     将依赖项输出并复制到Godeps.json文件中</span><br><span class="line">godep go       使用保存的依赖项运行go工具</span><br><span class="line">godep get      下载并安装具有指定依赖项的包</span><br><span class="line">godep path     打印依赖的GOPATH路径</span><br><span class="line">godep restore  在GOPATH中拉取依赖的版本</span><br><span class="line">godep update   更新选定的包或go版本</span><br><span class="line">godep diff     显示当前和以前保存的依赖项集之间的差异</span><br><span class="line">godep version  查看版本信息</span><br></pre></td></tr></table></figure><p>使用<code>godep help [command]</code>可以看看具体命令的帮助信息。</p><h3 id="使用godep"><a href="#使用godep" class="headerlink" title="使用godep"></a>使用godep</h3><p>在项目目录下执行<code>godep save</code>命令，会在当前项目中创建<code>Godeps</code>和<code>vender</code>两个文件夹。</p><p>其中<code>Godeps</code>文件夹下有一个<code>Godeps.json</code>的文件，里面记录了项目所依赖的包信息。 <code>vender</code>文件夹下是项目依赖的包的源代码文件。</p><h3 id="vender机制"><a href="#vender机制" class="headerlink" title="vender机制"></a>vender机制</h3><p>Go1.5版本之后开始支持，能够控制Go语言程序编译时依赖包搜索路径的优先级。</p><p>例如查找项目的某个依赖包，首先会在项目根目录下的<code>vender</code>文件夹中查找，如果没有找到就会去<code>$GOAPTH/src</code>目录下查找。</p><h3 id="godep开发流程"><a href="#godep开发流程" class="headerlink" title="godep开发流程"></a>godep开发流程</h3><ol><li>保证程序能够正常编译</li><li>执行<code>godep save</code>保存当前项目的所有第三方依赖的版本信息和代码</li><li>提交Godeps目录和vender目录到代码库。</li><li>如果要更新依赖的版本，可以直接修改<code>Godeps.json</code>文件中的对应项</li></ol><h2 id="go-module"><a href="#go-module" class="headerlink" title="go module"></a>go module</h2><p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。</p><h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><p>要启用<code>go module</code>支持首先要设置环境变量<code>GO111MODULE</code>，通过它可以开启或关闭模块支持，它有三个可选值：<code>off</code>、<code>on</code>、<code>auto</code>，默认值是<code>auto</code>。</p><ol><li><code>GO111MODULE=off</code>禁用模块支持，编译时会从<code>GOPATH</code>和<code>vendor</code>文件夹中查找包。</li><li><code>GO111MODULE=on</code>启用模块支持，编译时会忽略<code>GOPATH</code>和<code>vendor</code>文件夹，只根据 <code>go.mod</code>下载依赖。</li><li><code>GO111MODULE=auto</code>，当项目在<code>$GOPATH/src</code>外且项目根目录有<code>go.mod</code>文件时，开启模块支持。</li></ol><p>简单来说，设置<code>GO111MODULE=on</code>之后就可以使用<code>go module</code>了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p><p>使用 go module 管理依赖后会在项目根目录下生成两个文件<code>go.mod</code>和<code>go.sum</code>。</p><h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>Go1.11之后设置GOPROXY命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><p>Go1.13之后<code>GOPROXY</code>默认值为<code>https://proxy.golang.org</code>，在国内是无法访问的，所以十分建议大家设置GOPROXY，这里我推荐使用<a href="https://studygolang.com/topics/10014">goproxy.cn</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><h3 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h3><p>常用的<code>go mod</code>命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go mod download    下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录）</span><br><span class="line">go mod edit        编辑go.mod文件</span><br><span class="line">go mod graph       打印模块依赖图</span><br><span class="line">go mod init        初始化当前文件夹, 创建go.mod文件</span><br><span class="line">go mod tidy        增加缺少的module，删除无用的module</span><br><span class="line">go mod vendor      将依赖复制到vendor下</span><br><span class="line">go mod verify      校验依赖</span><br><span class="line">go mod why         解释为什么需要依赖</span><br></pre></td></tr></table></figure><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p>go.mod文件记录了项目所有的依赖信息，其结构大致如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module github.com/Q1mi/studygo/blogger</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586</span><br><span class="line">github.com/gin-gonic/gin v1.4.0</span><br><span class="line">github.com/go-sql-driver/mysql v1.4.1</span><br><span class="line">github.com/jmoiron/sqlx v1.2.0</span><br><span class="line">github.com/satori/go.uuid v1.2.0</span><br><span class="line">google.golang.org/appengine v1.6.1 // indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>module</code>用来定义包名</li><li><code>require</code>用来定义依赖包及版本</li><li><code>indirect</code>表示间接引用</li></ul><h4 id="依赖的版本"><a href="#依赖的版本" class="headerlink" title="依赖的版本"></a>依赖的版本</h4><p>go mod支持语义化版本号，比如<code>go get foo@v1.2.3</code>，也可以跟git的分支或tag，比如<code>go get foo@master</code>，当然也可以跟git提交哈希，比如<code>go get foo@e3702bed2</code>。关于依赖的版本支持以下几种格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gopkg.in/tomb.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20141024135613</span>-dd632973f1e7</span><br><span class="line">gopkg.in/vmihailenco/msgpack.v2 v2<span class="number">.9</span><span class="number">.1</span></span><br><span class="line">gopkg.in/yaml.v2 &lt;=v2<span class="number">.2</span><span class="number">.1</span></span><br><span class="line">github.com/tatsushid/<span class="keyword">go</span>-fastping v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20160109021039</span>-d7bb493dee3e</span><br><span class="line">latest</span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>在国内访问golang.org&#x2F;x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replace (</span><br><span class="line">golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614</span>d502a4dac =&gt; github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614</span>d502a4dac</span><br><span class="line">golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180821023952</span><span class="number">-922</span>f4815f713 =&gt; github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180826012351</span><span class="number">-8</span>a410e7b638d</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.0</span> =&gt; github.com/golang/text v0<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><p>在项目中执行<code>go get</code>命令可以下载依赖包，并且还可以指定下载的版本。</p><ol><li>运行<code>go get -u</code>将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li><li>运行<code>go get -u=patch</code>将会升级到最新的修订版本</li><li>运行<code>go get package@version</code>将会升级到指定的版本号version</li></ol><p>如果下载所有依赖可以使用<code>go mod download</code> 命令。</p><h3 id="整理依赖"><a href="#整理依赖" class="headerlink" title="整理依赖"></a>整理依赖</h3><p>我们在代码中删除依赖代码后，相关的依赖库并不会在<code>go.mod</code>文件中自动移除。这种情况下我们可以使用<code>go mod tidy</code>命令更新<code>go.mod</code>中的依赖关系。</p><h3 id="go-mod-edit"><a href="#go-mod-edit" class="headerlink" title="go mod edit"></a>go mod edit</h3><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>因为我们可以手动修改go.mod文件，所以有些时候需要格式化该文件。Go提供了一下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -<span class="built_in">fmt</span></span><br></pre></td></tr></table></figure><h4 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -require=golang.org/x/text</span><br></pre></td></tr></table></figure><h4 id="移除依赖项"><a href="#移除依赖项" class="headerlink" title="移除依赖项"></a>移除依赖项</h4><p>如果只是想修改<code>go.mod</code>文件中的内容，那么可以运行<code>go mod edit -droprequire=package path</code>，比如要在<code>go.mod</code>中移除<code>golang.org/x/text</code>包，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -droprequire=golang.org/x/text</span><br></pre></td></tr></table></figure><p>关于<code>go mod edit</code>的更多用法可以通过<code>go help mod edit</code>查看。</p><h2 id="在项目中使用go-module"><a href="#在项目中使用go-module" class="headerlink" title="在项目中使用go module"></a>在项目中使用go module</h2><h3 id="既有项目"><a href="#既有项目" class="headerlink" title="既有项目"></a>既有项目</h3><p>如果需要对一个已经存在的项目启用<code>go module</code>，可以按照以下步骤操作：</p><ol><li>在项目目录下执行<code>go mod init</code>，生成一个<code>go.mod</code>文件。</li><li>执行<code>go get</code>，查找并记录当前项目的依赖，同时生成一个<code>go.sum</code>记录每个依赖库的版本和哈希值。</li></ol><h3 id="新项目"><a href="#新项目" class="headerlink" title="新项目"></a>新项目</h3><p>对于一个新创建的项目，我们可以在项目文件夹下按照以下步骤操作：</p><ol><li>执行<code>go mod init 项目名</code>命令，在当前项目文件夹下创建一个<code>go.mod</code>文件。</li><li>手动编辑<code>go.mod</code>中的require依赖项或执行<code>go get</code>自动发现、维护依赖。</li></ol><h3 id="使用go-mod导入本地项目"><a href="#使用go-mod导入本地项目" class="headerlink" title="使用go mod导入本地项目"></a>使用go mod导入本地项目</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>假设我们现在有<code>moduledemo</code>和<code>mypackage</code>两个包，其中<code>moduledemo</code>包中会导入<code>mypackage</code>包并使用它的<code>New</code>方法。</p><p><code>mypackage/mypackage.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypackage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;mypackage.New&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在分两种情况讨论：</p><h4 id="在同一个项目下"><a href="#在同一个项目下" class="headerlink" title="在同一个项目下"></a>在同一个项目下</h4><p><strong>注意</strong>：在一个项目（project）下我们是可以定义多个包（package）的。</p><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p>现在的情况是，我们在<code>moduledemo/main.go</code>中调用了<code>mypackage</code>这个包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">moduledemo</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── mypackage</span><br><span class="line">    └── mypackage.go</span><br></pre></td></tr></table></figure><h5 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h5><p>这个时候，我们需要在<code>moduledemo/go.mod</code>中按如下定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module moduledemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>然后在<code>moduledemo/main.go</code>中按如下方式导入<code>mypackage</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;moduledemo/mypackage&quot;</span>  <span class="comment">// 导入同一项目下的mypackage包</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mypackage.New()</span><br><span class="line">fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h5><p>举一反三，假设我们现在有文件目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── bubble</span><br><span class="line">    ├── dao</span><br><span class="line">    │   └── mysql.go</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── main.go</span><br></pre></td></tr></table></figure><p>其中<code>bubble/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module github.com/q1mi/bubble</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p><code>bubble/dao/mysql.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;mypackage.New&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bubble/main.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/q1mi/bubble/dao&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dao.New()</span><br><span class="line">fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不在同一个项目下"><a href="#不在同一个项目下" class="headerlink" title="不在同一个项目下"></a>不在同一个项目下</h4><h5 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── moduledemo</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   └── main.go</span><br><span class="line">└── mypackage</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── mypackage.go</span><br></pre></td></tr></table></figure><h5 id="导入包-1"><a href="#导入包-1" class="headerlink" title="导入包"></a>导入包</h5><p>这个时候，<code>mypackage</code>也需要进行module初始化，即拥有一个属于自己的<code>go.mod</code>文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module mypackage</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>然后我们在<code>moduledemo/main.go</code>中按如下方式导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;mypackage&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mypackage.New()</span><br><span class="line">fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这两个包不在同一个项目路径下，你想要导入本地包，并且这些包也没有发布到远程的github或其他代码仓库地址。这个时候我们就需要在<code>go.mod</code>文件中使用<code>replace</code>指令。</p><p>在调用方也就是<code>moduledemo/go.mod</code>中按如下方式指定使用相对路径来寻找<code>mypackage</code>这个包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module moduledemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">require <span class="string">&quot;mypackage&quot;</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">replace <span class="string">&quot;mypackage&quot;</span> =&gt; <span class="string">&quot;../mypackage&quot;</span></span><br></pre></td></tr></table></figure><h5 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h5><p>最后我们再举个例子巩固下上面的内容。</p><p>我们现在有文件目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── p1</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   └── main.go</span><br><span class="line">└── p2</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── p2.go</span><br></pre></td></tr></table></figure><p><code>p1/main.go</code>中想要导入<code>p2.go</code>中定义的函数。</p><p><code>p2/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module liwenzhou.com/q1mi/p2</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p><code>p1/main.go</code>中按如下方式导入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;liwenzhou.com/q1mi/p2&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p2.New()</span><br><span class="line">fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我并没有把<code>liwenzhou.com/q1mi/p2</code>这个包上传到<code>liwenzhou.com</code>这个网站，我们只是想导入本地的包，这个时候就需要用到<code>replace</code>这个指令了。</p><p><code>p1/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module github.com/q1mi/p1</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">require <span class="string">&quot;liwenzhou.com/q1mi/p2&quot;</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">replace <span class="string">&quot;liwenzhou.com/q1mi/p2&quot;</span> =&gt; <span class="string">&quot;../p2&quot;</span></span><br></pre></td></tr></table></figure><p>此时，我们就可以正常编译<code>p1</code>这个项目了。</p>]]></content>
    
    
    <categories>
      
      <category>开发学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运维平台功能梳理</title>
    <link href="/2025/02/10/2025-02-10-%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0%E5%8A%9F%E8%83%BD%E6%A2%B3%E7%90%86/"/>
    <url>/2025/02/10/2025-02-10-%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0%E5%8A%9F%E8%83%BD%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>要构建一个运维平台，接入阿里云平台并实现资产管理、用户管理、告警管理、日志管理、数据库监控等功能，需要从需求分析、架构设计和技术栈选择三个方面进行梳理。以下是详细的整理。</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="1-资产管理"><a href="#1-资产管理" class="headerlink" title="1.资产管理"></a>1.资产管理</h2><ul><li>功能需求：<ul><li>自动同步阿里云资源（如ECS、RDS、SLB等）到运维平台数据库；</li><li>资源分类和标签管理（主要是针对不同业务的不同需求进行命名以及标签管理）</li><li>资源生命周期管理（创建资源、修改资源配置、删除资源）</li><li>资源使用情况和报表（形成大盘）</li></ul></li><li>非功能需求<ul><li>数据实时性：资源状态需要实时更新；</li><li>可扩展性：支持未来接入其他云平台（如AWS、腾讯云等）</li></ul></li></ul><h2 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2.用户管理"></a>2.用户管理</h2><ul><li>功能需求：<ul><li>用户角色和权限管理（包括管理员、运维人员、普通用户）</li><li>基于角色的访问控制</li><li>用户操作日志审计</li></ul></li><li>非功能需求：<ul><li>安全性：支持多因素认证（MFA）和密码策略。</li><li>可扩展性：支持 LDAP 或 OAuth 集成。</li></ul></li></ul><h2 id="3-告警管理"><a href="#3-告警管理" class="headerlink" title="3. 告警管理"></a>3. 告警管理</h2><ul><li>功能需求：<ul><li>对接阿里云监控服务（如 CloudMonitor）。</li><li>自定义告警规则和阈值。</li><li>告警通知（邮件、短信、钉钉、Webhook）。</li><li>告警历史记录和统计分析。</li></ul></li><li>非功能需求：<ul><li>实时性：告警需要及时触发和通知。</li><li>灵活性：支持多种通知渠道和自定义模板。</li></ul></li></ul><h2 id="4-日志管理"><a href="#4-日志管理" class="headerlink" title="4. 日志管理"></a>4. 日志管理</h2><ul><li>功能需求：<ul><li>收集阿里云服务日志（如 SLB 访问日志、RDS 慢查询日志）。</li><li>日志存储和检索（支持全文搜索和过滤）。</li><li>日志分析和可视化（如异常检测、趋势分析）。</li></ul></li><li>非功能需求：<ul><li>高性能：支持大规模日志数据的实时处理。</li><li>可扩展性：支持未来接入其他日志源。</li></ul></li></ul><h2 id="5-数据库监控"><a href="#5-数据库监控" class="headerlink" title="5. 数据库监控"></a>5. 数据库监控</h2><ul><li>功能需求：<ul><li>监控阿里云 RDS 实例的性能指标（如 CPU、内存、连接数）。</li><li>慢查询分析和优化建议。</li><li>数据库健康状态告警。</li></ul></li><li>非功能需求：<ul><li>实时性：监控数据需要实时更新。</li><li>可视化：提供直观的图表和报表。</li></ul></li></ul><hr><h1 id="二、架构设计"><a href="#二、架构设计" class="headerlink" title="二、架构设计"></a>二、架构设计</h1><h2 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h2><ul><li>前端：用户交互界面，提供资产管理、告警管理、日志查询等功能。</li><li>后端：核心业务逻辑，处理数据同步、告警规则、日志分析等。</li><li>数据库：存储用户数据、资源信息、告警记录、日志数据等。</li><li>消息队列：用于异步处理告警通知、日志收集等任务。</li><li>缓存：提高数据访问性能，如 Redis。</li><li>监控与告警：对接阿里云监控服务，实现实时告警。</li><li>日志收集与分析：使用 ELK（Elasticsearch、Logstash、Kibana）或 Loki 实现日志管理。</li></ul><h2 id="2-模块划分"><a href="#2-模块划分" class="headerlink" title="2. 模块划分"></a>2. 模块划分</h2><ul><li>资产管理模块：<ul><li>同步阿里云资源信息。</li><li>提供资源查询和操作接口。</li></ul></li><li>用户管理模块：<ul><li>用户认证和授权。</li><li>操作日志记录。</li></ul></li><li>告警管理模块：<ul><li>对接阿里云监控。</li><li>告警规则管理和通知。</li></ul></li><li>日志管理模块：<ul><li>日志收集、存储和检索。</li><li>日志分析和可视化。</li></ul></li><li>数据库监控模块：<ul><li>监控 RDS 实例性能。</li><li>提供慢查询分析和优化建议。</li></ul></li></ul><h2 id="3-数据流设计"><a href="#3-数据流设计" class="headerlink" title="3. 数据流设计"></a>3. 数据流设计</h2><ul><li>资源同步：定期调用阿里云 API 获取资源信息，存储到数据库。</li><li>告警处理：阿里云监控触发告警后，通过消息队列异步处理通知。</li><li>日志收集：通过 Logstash 或 Fluentd 收集日志，存储到 Elasticsearch。</li><li>监控数据：通过阿里云 SDK 获取 RDS 监控数据，存储到数据库并提供可视化。</li></ul><hr><h1 id="三、技术栈选择"><a href="#三、技术栈选择" class="headerlink" title="三、技术栈选择"></a>三、技术栈选择</h1><h2 id="1-前端"><a href="#1-前端" class="headerlink" title="1. 前端"></a>1. 前端</h2><ul><li>框架：React 或 Vue.js。</li><li>UI 库：Ant Design 或 Element UI。</li><li>图表库：ECharts 或 Chart.js。</li></ul><h2 id="2-后端"><a href="#2-后端" class="headerlink" title="2. 后端"></a>2. 后端</h2><ul><li>语言：Python（Django&#x2F;Flask）或 Go（Gin）。</li><li>API 框架：RESTful API 或 GraphQL。</li><li>阿里云 SDK：使用阿里云官方 SDK 进行资源管理和监控。</li></ul><h2 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h2><ul><li>关系型数据库：MySQL 或 PostgreSQL（存储用户、资源、告警等数据）。</li><li>日志存储：Elasticsearch。</li><li>缓存：Redis。</li></ul><h2 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4. 消息队列"></a>4. 消息队列</h2><ul><li>工具：RabbitMQ 或 Kafka（用于异步处理告警通知和日志收集）。</li></ul><h3 id="5-日志管理"><a href="#5-日志管理" class="headerlink" title="5. 日志管理"></a>5. 日志管理</h3><ul><li>收集：Logstash 或 Fluentd。</li><li>存储与检索：Elasticsearch。</li><li>可视化：Kibana 或 Grafana。</li></ul><h2 id="6-监控与告警"><a href="#6-监控与告警" class="headerlink" title="6. 监控与告警"></a>6. 监控与告警</h2><ul><li>阿里云监控：通过 CloudMonitor 获取监控数据。</li><li>告警通知：集成钉钉、邮件、短信等通知渠道。</li></ul><h2 id="7-部署与运维"><a href="#7-部署与运维" class="headerlink" title="7. 部署与运维"></a>7. 部署与运维</h2><ul><li>容器化：Docker + Kubernetes。</li><li>CI&#x2F;CD：Jenkins 或 GitLab CI。</li><li>监控：Prometheus + Grafana。</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KubernetesChangelogs</title>
    <link href="/2025/02/05/2025-02-05-KubernetesChangeLog%E6%B1%87%E6%80%BB/"/>
    <url>/2025/02/05/2025-02-05-KubernetesChangeLog%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="Kubernetes-1-24"><a href="#Kubernetes-1-24" class="headerlink" title="Kubernetes 1.24"></a><strong>Kubernetes 1.24</strong></h3><p><strong>发布日期：</strong> 2022年5月3日<br><strong>主要更新：</strong></p><ul><li><strong>移除 Dockershim：</strong>  v1.20 中被弃用的 Dockershim 组件已从 kubelet 中移除。用户需迁移至其他受支持的容器运行时，如 containerd 或 CRI-O。</li><li><strong>默认关闭 Beta API：</strong> 的 Beta API 默认不再启用，现有的 Beta API 及其更新版本仍保持启用。</li><li><strong>签署发布工件：</strong> 入了使用 cosign 对发布工件进行签名的机制，增强了软件供应链的安全性。</li><li><strong>OpenAPI v3 支持：</strong> 供了以 OpenAPI v3 格式发布 API 的 Beta 支持。</li><li><strong>存储容量跟踪和卷扩展：</strong> 储容量跟踪和卷扩展功能已达到稳定版，改进了存储管理能力。</li><li><strong>非抢占优先级：</strong>  PriorityClasses 添加了非抢占选项，提供了更灵活的调度策略。</li><li><strong>存储插件迁移：</strong> zure Disk 和 OpenStack Cinder 插件已迁移至 CSI 驱动程序。</li><li><strong>gRPC 探针：</strong> RPC 探测功能升级至 Beta，允许为 gRPC 应用程序配置启动、存活和就绪性探测。</li><li><strong>Kubelet 凭证提供者：</strong> ubelet 对镜像凭证提供者的支持已升级到 Beta，允许动态检索容器镜像仓库的凭据。</li><li><strong>上下文日志记录：</strong> 入了上下文日志记录功能，使函数调用者能够控制日志记录的各个方面。</li><li><strong>避免服务 IP 分配冲突：</strong> 入了新的功能，允许为服务的静态 IP 地址分配软保留范围，降低冲突风险。</li><li><strong>移除动态 Kubelet 配置：</strong> 态 Kubelet 配置已从 kubelet 中移除，并计划在 Kubernetes 1.26 中从 API 服务器中移除。<br>多详细信息，请参阅官方发布公告。citeturn0search10</li></ul><hr><h3 id="Kubernetes-1-25"><a href="#Kubernetes-1-25" class="headerlink" title="Kubernetes 1.25"></a><strong>Kubernetes 1.25</strong></h3><p><strong>发布日期：</strong> 2022年8月23日<br><strong>主要更新：</strong></p><ul><li><strong>Pod 安全性准入：</strong> odSecurity 准入控制器已达到稳定版，提供了基于命名空间标签的安全策略。</li><li><strong>容器运行时接口（CRI）增强：</strong>  CRI 进行了改进，增强了对多种容器运行时的兼容性。</li><li><strong>存储功能增强：</strong> SI 插件支持更多的存储后端，并增强了与动态卷供给的兼容性。</li><li><strong>资源请求和限制优化：</strong> 进了资源请求与限制的计算和调度，提升了调度器的资源分配能力。</li><li><strong>弃用 PodSecurityPolicy（PSP）：</strong> SP 功能被正式弃用，用户应迁移到新的 PodSecurity 策略。</li><li><strong>移除 <code>--cloud-provider</code> 标志：</strong> –cloud-provider&#96; 标志被移除，用户需迁移到新的云提供商接口。</li><li><strong>服务账户权限策略调整：</strong> 服务账户的权限策略进行了改进，部分权限不再默认开放。</li><li><strong>API 版本更新：</strong> 些旧的 API 版本被废弃，用户需迁移到更稳定的版本。<br>多详细信息，请参阅官方发布公告。</li></ul><hr><h3 id="Kubernetes-1-26"><a href="#Kubernetes-1-26" class="headerlink" title="Kubernetes 1.26"></a><strong>Kubernetes 1.26</strong></h3><p><strong>发布日期：</strong> 2022年12月8日<br><strong>主要更新：</strong></p><ul><li><strong>原生边车容器支持：</strong> 入了原生的边车容器支持，简化了边车容器的管理。</li><li><strong>Job 控制器增强：</strong>  Job 控制器进行了增强，支持更多的调度和重试策略。</li><li><strong>存储功能增强：</strong> 入了对新的存储卷模式和快照功能的支持。</li><li><strong>弃用旧版 API：</strong> 一步弃用了旧的 API 版本，用户需尽快迁移到新的 API。</li><li><strong>安全性增强：</strong> 强了对证书和密钥管理的控制，提升了集群的安全性。<br>多详细信息，请参阅官方发布公告。</li></ul><hr><h3 id="Kubernetes-1-27"><a href="#Kubernetes-1-27" class="headerlink" title="Kubernetes 1.27"></a><strong>Kubernetes 1.27</strong></h3><p><strong>发布日期：</strong> 2023年4月11日<br><strong>主要更新：</strong></p><ul><li><strong>控制器管理器的领导者迁移：</strong> ube-controller-manager 和 cloud-controller-manager 可以在高可用控制平面中重新分配新的控制器，无需停机。</li><li><strong>Pod 亲和性 NamespaceSelector：</strong>  Pod 亲和性&#x2F;反亲和性规则添加了 <code>namespaceSelector</code> 字段。</li><li><strong>弃用旧版 API：</strong> 续弃用旧的 API 版本，用户需迁移到新的 API。</li><li><strong>安全性增强：</strong> 进了对服务账户和 RBAC 的支持，增强了权限管理。<br>多详细信息，请参阅官方发布公告。</li></ul><hr><h3 id="Kubernetes-1-28"><a href="#Kubernetes-1-28" class="headerlink" title="Kubernetes 1.28"></a><strong>Kubernetes 1.28</strong></h3><p><strong>发布日期：</strong> 2023年8月16日<br><strong>主要更新：</strong></p><ol><li><strong>节点非体面关闭功能进入 GA（正式发布）阶段：</strong><ul><li>特性允许在节点意外关闭或不可恢复时，有状态工作负载能够在其他节点上重新启动，确保应用的高可用性。citeturn0search0</li></ul></li><li><strong>对 Linux 上交换内存的 Beta 支持：</strong><ul><li>入了对 Linux 节点上交换内存的支持，提升了节点的内存管理能力，增强了系统的稳定性。citeturn0search2</li></ul></li><li><strong>Job 失效处理的改进：</strong><ul><li>入了 Pod 更换策略和基于索引的回退限制，改进了对批处理作业中 Pod 失效的处理，提高了批处理任务的可靠性。citeturn0search6</li></ul></li><li><strong>节点 podresources API 正式发布：</strong><ul><li>API 允许用户查询节点上分配给容器的资源信息，增强了对资源分配的可观测性。citeturn0search14</li></ul></li><li><strong>用于改进集群安全升级的新机制（Alpha）：</strong><ul><li>入了混合版本代理特性，允许在集群升级期间，不同版本的 API 服务器之间正确处理资源请求，确保升级过程的平滑和安全。citeturn0search13</li></ul></li></ol><hr><h3 id="Kubernetes-1-29"><a href="#Kubernetes-1-29" class="headerlink" title="Kubernetes 1.29"></a><strong>Kubernetes 1.29</strong></h3><p><strong>发布日期：</strong> 2023年12月13日<br><strong>主要更新：</strong></p><ol><li><strong>引入 nftables 作为 kube-proxy 的新后端（Alpha）：</strong><ul><li>kube-proxy 添加了基于 nftables 的后端，以替代传统的 iptables，提供更好的性能和可扩展性。citeturn0search4</li></ul></li><li><strong>Sidecar 容器功能进入 Beta 阶段并默认启用：</strong><ul><li>idecar 容器运行模式进入了 Beta 阶段，允许用户明确定义 Sidecar 容器的启动顺序和生命周期管理，增强了对应用程序的支持。citeturn0search11</li></ul></li><li><strong>KMS v2 静态加密功能正式发布：</strong><ul><li>MS v2 提供了性能提升、密钥轮换和可观测性方面的改进，为集群中的数据加密提供了更可靠的解决方案。citeturn0search7</li></ul></li><li><strong>ReadWriteOncePod 持久卷访问模式达到稳定版：</strong><ul><li>入了新的持久卷访问模式，确保在整个集群中，只有一个 Pod 可以读写特定的 PVC，增强了数据的安全性和一致性。citeturn0search10</li></ul></li><li><strong>上下文日志记录功能的增强：</strong><ul><li>进了日志记录机制，引入了上下文日志记录功能，提供了更好的故障排除能力和增强的日志记录。citeturn0search3</li></ul></li><li><strong>Service 负载均衡器 IP 模式（Alpha）：</strong><ul><li>入了新的 Alpha 特性，允许用户配置 Service 的负载均衡器 IP 模式，提供了更灵活的流量管理方式。citeturn0search4</li></ul></li></ol><hr><p>抱歉之前的总结遗漏了 Kubernetes 1.30 和 1.31 版本的更新日志。以下是对这两个版本的中文总结：</p><hr><h3 id="Kubernetes-1-30"><a href="#Kubernetes-1-30" class="headerlink" title="Kubernetes 1.30"></a><strong>Kubernetes 1.30</strong></h3><p><strong>发布日期：</strong> 2024年3月12日<br><strong>主要更新：</strong></p><ol><li><strong>动态资源分配（DRA）结构化参数：</strong><ul><li>DRA 进行了扩展，引入了结构化参数支持，增强了资源请求的透明性和可管理性。</li></ul></li><li><strong>节点交换内存（Swap）支持：</strong><ul><li>进了 Linux 节点的交换内存支持，默认启用了 <code>NodeSwap</code> 特性门控，并将默认行为设置为 <code>NoSwap</code> 模式，提升了系统稳定性。</li></ul></li><li><strong>用户命名空间支持：</strong><ul><li>用户命名空间的支持升级至 Beta，允许在容器内以非特权用户运行进程，增强了安全性。</li></ul></li><li><strong>结构化身份认证配置：</strong><ul><li>入了基于文件的身份认证配置，支持配置多个 JWT 认证组件，提供了更灵活的认证机制。</li></ul></li><li><strong>基于容器资源指标的 Pod 自动扩缩容：</strong><ul><li>许根据各个容器的资源使用情况配置自动扩缩容策略，提升了资源利用效率。</li></ul></li><li><strong>在准入控制中使用 CEL：</strong><ul><li>成了通用表达式语言（CEL）用于准入控制，提供了更动态和细粒度的策略控制能力。<br>多详细信息，请参阅官方发布公告。</li></ul></li></ol><hr><h3 id="Kubernetes-1-31"><a href="#Kubernetes-1-31" class="headerlink" title="Kubernetes 1.31"></a><strong>Kubernetes 1.31</strong></h3><p><strong>发布日期：</strong> 2024年8月13日<br><strong>主要更新：</strong></p><ol><li><strong>AppArmor 支持：</strong><ul><li>ubernetes 对 AppArmor 的支持已达到稳定版，用户可以通过在容器的 <code>securityContext</code> 中设置 <code>appArmorProfile.type</code> 字段来启用 AppArmor。</li></ul></li><li><strong>改进的入站连接可靠性：</strong><ul><li>ube-proxy 增强了对 <code>type: LoadBalancer</code> 和 <code>externalTrafficPolicy: Cluster</code> 服务的入站连接可靠性，减少了节点终止时的流量丢失。</li></ul></li><li><strong>持久卷阶段转换时间：</strong><ul><li>入了 <code>PersistentVolumeStatus</code> 的 <code>lastTransitionTime</code> 字段，记录持久卷状态转换的时间戳，便于监控和调试。</li></ul></li><li><strong>对 OCI 镜像卷的支持：</strong><ul><li>入了 Alpha 特性，允许在 Pod 中直接使用 OCI 镜像作为只读卷，简化了 AI&#x2F;ML 工作流中的数据访问。</li></ul></li><li><strong>nftables 后端：</strong><ul><li>ube-proxy 的 nftables 后端晋级为 Beta，提供了比 iptables 更好的性能和可扩展性。</li></ul></li><li><strong>弃用和移除：</strong><ul><li>cgroup v1 的支持转为维护模式，建议用户迁移到 cgroup v2。   - 除了 CephFS 和 Ceph RBD 树内卷插件，用户应迁移到相应的 CSI 驱动程序。   - 用了节点的 <code>status.nodeInfo.kubeProxyVersion</code> 字段，并将在未来版本中移除。<br>多详细信息，请参阅官方发布公告。</li></ul></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KubernetesChangelog-1.32</title>
    <link href="/2025/02/05/2025-02-05-KubernetesChangelog-1.32/"/>
    <url>/2025/02/05/2025-02-05-KubernetesChangelog-1.32/</url>
    
    <content type="html"><![CDATA[<p>好的，我将根据 Kubernetes 1.32 版本更新日志提供更具体的总结，涵盖功能增强、重要修复、废弃和移除的功能等内容。</p><h3 id="Kubernetes-1-32-版本更新日志总结"><a href="#Kubernetes-1-32-版本更新日志总结" class="headerlink" title="Kubernetes 1.32 版本更新日志总结"></a><strong>Kubernetes 1.32 版本更新日志总结</strong></h3><h4 id="1-新特性与增强"><a href="#1-新特性与增强" class="headerlink" title="1. 新特性与增强"></a><strong>1. 新特性与增强</strong></h4><ul><li><p><strong>API Aggregation（API 聚合层）</strong>：</p><ul><li>对 API 聚合层进行了改进，以支持更多的扩展功能和插件，提升了集群的可扩展性。</li></ul></li><li><p><strong>资源请求与限制</strong>：</p><ul><li><strong><code>kube-scheduler</code></strong> 进行了性能优化，改善了资源请求和限制的计算，提升了调度器在大规模集群中的效率。</li><li>新增了对 <code>resourceRequests</code> 和 <code>resourceLimits</code> 的细粒度控制，尤其在多租户环境中提高了调度的灵活性和公平性。</li></ul></li><li><p><strong>调度器（Scheduler）</strong>：</p><ul><li>对调度算法进行了优化，尤其是在多租户环境中提高了调度公平性。调度器现在可以更智能地处理具有不同资源需求的 Pod，避免资源分配不均的情况。</li><li>增强了调度器的调度策略，能够更好地适应集群的负载和资源限制。</li></ul></li><li><p><strong>Windows 容器支持</strong>：</p><ul><li>增强了 Kubernetes 对 <strong>Windows 容器</strong> 的支持，改进了在 Windows 环境下运行容器的稳定性和兼容性。尤其是对于不同 Windows 版本的支持更加完善。</li></ul></li><li><p><strong>持久存储</strong>：</p><ul><li>持久存储方面，支持对 <code>StatefulSet</code> 中卷的自动扩展，简化了存储管理。</li><li>对 <strong>CSI（容器存储接口）</strong> 的支持进行了增强，使其更加可靠，特别是在跨多个集群和多云环境中的表现。</li></ul></li></ul><h4 id="2-重要修复"><a href="#2-重要修复" class="headerlink" title="2. 重要修复"></a><strong>2. 重要修复</strong></h4><ul><li><p><strong>API Server</strong>：</p><ul><li>修复了与 API Server 性能相关的问题，尤其是在集群规模较大时，API 请求的响应速度和稳定性有所提升。</li><li>解决了部分情况下 API Server 由于负载过高而导致的崩溃问题。</li></ul></li><li><p><strong>调度与资源管理</strong>：</p><ul><li>解决了调度器在资源分配时可能出现的不公平情况，优化了资源优先级的分配算法，确保不同优先级的 Pod 能够得到合理调度。</li></ul></li><li><p><strong>网络与服务发现</strong>：</p><ul><li>修复了在使用 <strong>DNS 解析服务</strong>时出现的问题，尤其是在多网络环境下，服务发现功能更加稳定。</li><li>修复了 <code>kubectl</code> 在查询服务状态时可能出现的不一致性问题。</li></ul></li><li><p><strong>Etcd 存储</strong>：</p><ul><li>优化了与 <strong>etcd</strong> 之间的连接，改进了数据同步和存储性能，确保高并发读写操作时不会引发延迟问题。</li></ul></li></ul><h4 id="3-已废弃与移除的功能"><a href="#3-已废弃与移除的功能" class="headerlink" title="3. 已废弃与移除的功能"></a><strong>3. 已废弃与移除的功能</strong></h4><ul><li><p><strong>移除 <code>--cloud-provider</code> 标志</strong>：</p><ul><li>Kubernetes 1.32 开始废弃并移除了 <code>--cloud-provider</code> 相关的标志，推荐用户使用更加现代化和可扩展的配置方式来替代。</li><li>用户需要迁移到新的云平台接口，不再使用该标志来指定云服务提供商。</li></ul></li><li><p><strong>废弃的 API 版本</strong>：</p><ul><li><code>v1beta1</code> 版本的部分 Kubernetes API 已经被废弃，用户应迁移到稳定的 <code>v1</code> 版本，避免在未来的版本中遇到兼容性问题。</li><li>一些与扩展和插件有关的 API 也被废弃，用户应使用新的扩展机制来替代。</li></ul></li><li><p><strong>Windows 节点的旧版本支持</strong>：</p><ul><li>旧版的 Windows 节点支持已被废弃，Kubernetes 1.32 仅支持 Windows Server 2019 或更新版本的节点。</li></ul></li></ul><h4 id="4-安全性增强"><a href="#4-安全性增强" class="headerlink" title="4. 安全性增强"></a><strong>4. 安全性增强</strong></h4><ul><li><p><strong>认证与授权</strong>：</p><ul><li>引入了更强的身份验证机制，增强了对 API Server 和 kubelet 等组件的访问控制。</li><li>更新了身份认证和授权策略，改进了对外部身份提供者的支持，增强了对 RBAC（基于角色的访问控制）策略的灵活性和扩展性。</li></ul></li><li><p><strong>安全修复</strong>：</p><ul><li>修复了已知的多个安全漏洞，特别是在身份验证、授权和存储层面，提升了整个集群的安全性。</li></ul></li><li><p><strong>Pod 安全策略（PSP）</strong>：</p><ul><li>对 Pod 安全策略进行了增强，提升了 Pod 运行时的安全性，并强化了对运行时权限的控制。</li></ul></li></ul><h4 id="5-性能与扩展性"><a href="#5-性能与扩展性" class="headerlink" title="5. 性能与扩展性"></a><strong>5. 性能与扩展性</strong></h4><ul><li><p><strong>集群性能</strong>：</p><ul><li>改进了大规模集群的性能，尤其是调度器、API Server 和 etcd 之间的交互。大规模集群在执行调度时的响应速度得到了显著提升。</li></ul></li><li><p><strong>API Server 扩展性</strong>：</p><ul><li>增强了 API Server 的扩展性，支持更多的插件和自定义资源类型的处理。</li><li>在处理高并发 API 请求时，API Server 的性能和吞吐量有了较大的提升。</li></ul></li></ul><h4 id="6-文档和工具更新"><a href="#6-文档和工具更新" class="headerlink" title="6. 文档和工具更新"></a><strong>6. 文档和工具更新</strong></h4><ul><li><p><strong>文档更新</strong>：</p><ul><li>更新了 Kubernetes 的官方文档，特别是在部署、扩展、集群管理和容器存储等方面，提供了更详细的指导。</li></ul></li><li><p><strong>开发工具</strong>：</p><ul><li>对开发者工具进行了优化，特别是 <strong>kubectl</strong>，增强了命令行工具的可用性和可扩展性，改进了用户的使用体验。</li></ul></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Kubernetes 1.32 版本着重于提升集群的稳定性、性能和可扩展性，特别是在调度、资源管理和 Windows 容器支持方面做了很多改进。同时，针对一些过时的功能进行了移除和废弃，用户需要注意迁移到新的配置和 API。安全性和性能优化是此次更新的重要方向，特别是在处理高负载时，集群的响应速度和稳定性有了显著提升。</p><p>该版本还强化了对多云环境和 Windows 容器的支持，继续推动 Kubernetes 向更广泛的应用场景拓展。在安全方面，修复了多个已知漏洞，进一步提高了集群的安全性。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx常见返回码整理</title>
    <link href="/2025/02/05/2025-02-05-Nginx%E5%B8%B8%E8%A7%81%E8%BF%94%E5%9B%9E%E7%A0%81%E6%95%B4%E7%90%86/"/>
    <url>/2025/02/05/2025-02-05-Nginx%E5%B8%B8%E8%A7%81%E8%BF%94%E5%9B%9E%E7%A0%81%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Nginx 的返回码（HTTP 状态码）是服务器对客户端请求的响应结果。理解这些状态码的含义对于排查问题、优化性能和提升用户体验非常重要。以下是常见的 Nginx 返回码及其解析：</p><hr><h3 id="1xx：信息性状态码"><a href="#1xx：信息性状态码" class="headerlink" title="1xx：信息性状态码"></a><strong>1xx：信息性状态码</strong></h3><p>表示请求已被接收，继续处理。</p><ul><li><strong>100 Continue</strong>：<ul><li>客户端应继续发送请求的剩余部分。</li><li>通常用于 POST 或 PUT 请求中，客户端先发送请求头，服务器确认后再发送请求体。</li></ul></li><li><strong>101 Switching Protocols</strong>：<ul><li>服务器同意客户端请求，切换协议（如从 HTTP 切换到 WebSocket）。</li></ul></li></ul><hr><h3 id="2xx：成功状态码"><a href="#2xx：成功状态码" class="headerlink" title="2xx：成功状态码"></a><strong>2xx：成功状态码</strong></h3><p>表示请求已成功被服务器接收、理解并处理。</p><ul><li><strong>200 OK</strong>：<ul><li>请求成功，服务器返回了请求的资源。</li><li>最常见的成功状态码。</li></ul></li><li><strong>201 Created</strong>：<ul><li>请求成功，并且服务器创建了新的资源（如 POST 请求创建了新资源）。</li></ul></li><li><strong>204 No Content</strong>：<ul><li>请求成功，但响应中没有内容（如 DELETE 请求成功）。</li></ul></li><li><strong>206 Partial Content</strong>：<ul><li>服务器成功处理了部分 GET 请求（如大文件的分段下载）。</li></ul></li></ul><hr><h3 id="3xx：重定向状态码"><a href="#3xx：重定向状态码" class="headerlink" title="3xx：重定向状态码"></a><strong>3xx：重定向状态码</strong></h3><p>表示需要客户端进一步操作以完成请求。</p><ul><li><strong>301 Moved Permanently</strong>：<ul><li>请求的资源已永久移动到新位置，客户端应使用新的 URL。</li></ul></li><li><strong>302 Found</strong>：<ul><li>请求的资源临时移动到新位置，客户端应使用新的 URL。</li></ul></li><li><strong>304 Not Modified</strong>：<ul><li>资源未修改，客户端可以使用缓存的版本。</li><li>通常用于条件请求（如 <code>If-Modified-Since</code>）。</li></ul></li></ul><hr><h3 id="4xx：客户端错误状态码"><a href="#4xx：客户端错误状态码" class="headerlink" title="4xx：客户端错误状态码"></a><strong>4xx：客户端错误状态码</strong></h3><p>表示客户端发送的请求有错误，服务器无法处理。</p><ul><li><strong>400 Bad Request</strong>：<ul><li>请求无效，服务器无法理解（如参数错误、格式错误）。</li></ul></li><li><strong>401 Unauthorized</strong>：<ul><li>请求需要身份验证，客户端未提供有效的凭据。</li></ul></li><li><strong>403 Forbidden</strong>：<ul><li>服务器拒绝请求，客户端没有访问权限。</li></ul></li><li><strong>404 Not Found</strong>：<ul><li>请求的资源不存在。</li></ul></li><li><strong>405 Method Not Allowed</strong>：<ul><li>请求方法不被允许（如使用 POST 访问只支持 GET 的接口）。</li></ul></li><li><strong>408 Request Timeout</strong>：<ul><li>请求超时，服务器未在指定时间内收到完整的请求。</li></ul></li><li><strong>413 Payload Too Large</strong>：<ul><li>请求体过大，服务器拒绝处理。</li></ul></li><li><strong>414 URI Too Long</strong>：<ul><li>请求的 URL 过长，服务器拒绝处理。</li></ul></li><li><strong>429 Too Many Requests</strong>：<ul><li>客户端发送的请求过多，触发限流。</li></ul></li><li><strong>499 Client Closed Request：</strong><ul><li>客户端在服务器处理请求的过程中断开了连接</li></ul></li></ul><hr><h3 id="5xx：服务器错误状态码"><a href="#5xx：服务器错误状态码" class="headerlink" title="5xx：服务器错误状态码"></a><strong>5xx：服务器错误状态码</strong></h3><p>表示服务器处理请求时发生错误。</p><ul><li><strong>500 Internal Server Error</strong>：<ul><li>服务器内部错误，无法完成请求。</li></ul></li><li><strong>502 Bad Gateway</strong>：<ul><li>服务器作为网关或代理时，从上游服务器收到无效响应。</li></ul></li><li><strong>503 Service Unavailable</strong>：<ul><li>服务器暂时不可用（如过载或维护）。</li></ul></li><li><strong>504 Gateway Timeout</strong>：<ul><li>服务器作为网关或代理时，未及时从上游服务器收到响应。</li></ul></li><li><strong>505 HTTP Version Not Supported</strong>：<ul><li>服务器不支持请求中使用的 HTTP 协议版本。</li></ul></li></ul><hr><h3 id="常见-Nginx-返回码场景分析"><a href="#常见-Nginx-返回码场景分析" class="headerlink" title="常见 Nginx 返回码场景分析"></a><strong>常见 Nginx 返回码场景分析</strong></h3><h3 id="1-502-Bad-Gateway"><a href="#1-502-Bad-Gateway" class="headerlink" title="1. 502 Bad Gateway"></a>1. <strong>502 Bad Gateway</strong></h3><ul><li><strong>原因</strong>：<ul><li>后端服务（如 Tomcat、Node.js）崩溃或无响应。</li><li>Nginx 与后端服务的连接超时。</li></ul></li><li><strong>解决方案</strong>：<ul><li><p>检查后端服务是否正常运行。</p></li><li><p>调整 Nginx 的超时配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_connect_timeout 60s;</span><br><span class="line">proxy_read_timeout 60s;</span><br><span class="line">proxy_send_timeout 60s;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-504-Gateway-Timeout"><a href="#2-504-Gateway-Timeout" class="headerlink" title="2. 504 Gateway Timeout"></a>2. <strong>504 Gateway Timeout</strong></h3><ul><li><strong>原因</strong>：<ul><li>后端服务处理请求时间过长，Nginx 等待超时。</li></ul></li><li><strong>解决方案</strong>：<ul><li><p>优化后端服务的性能。</p></li><li><p>调整 Nginx 的超时配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_read_timeout 300s;</span><br><span class="line">proxy_send_timeout 300s;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-404-Not-Found"><a href="#3-404-Not-Found" class="headerlink" title="3. 404 Not Found"></a>3. <strong>404 Not Found</strong></h3><ul><li><strong>原因</strong>：<ul><li>请求的资源不存在。</li><li>Nginx 配置错误，未正确映射请求路径。</li></ul></li><li><strong>解决方案</strong>：<ul><li><p>检查请求的 URL 是否正确。</p></li><li><p>检查 Nginx 的 <code>location</code> 配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /path &#123;</span><br><span class="line">    proxy_pass &lt;http://backend&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-403-Forbidden"><a href="#4-403-Forbidden" class="headerlink" title="4. 403 Forbidden"></a>4. <strong>403 Forbidden</strong></h3><ul><li><strong>原因</strong>：<ul><li>客户端没有访问权限。</li><li>Nginx 配置了访问控制（如 <code>allow</code> 和 <code>deny</code>）。</li></ul></li><li><strong>解决方案</strong>：<ul><li><p>检查 Nginx 的访问控制配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /path &#123;</span><br><span class="line">    allow 192.168.1.0/24;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-500-Internal-Server-Error"><a href="#5-500-Internal-Server-Error" class="headerlink" title="5. 500 Internal Server Error"></a>5. <strong>500 Internal Server Error</strong></h3><ul><li><strong>原因</strong>：<ul><li>后端服务抛出未捕获的异常。</li><li>Nginx 配置错误（如错误的 <code>proxy_pass</code>）。</li></ul></li><li><strong>解决方案</strong>：<ul><li><p>检查后端服务的日志，修复代码问题。</p></li><li><p>检查 Nginx 的 <code>proxy_pass</code> 配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /path &#123;</span><br><span class="line">    proxy_pass &lt;http://backend&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="Nginx-日志中的返回码"><a href="#Nginx-日志中的返回码" class="headerlink" title="Nginx 日志中的返回码"></a><strong>Nginx 日志中的返回码</strong></h3><p>Nginx 的访问日志（<code>access.log</code>）会记录每个请求的返回码。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [23/Oct/2023:12:34:56 +0800] &quot;GET /path HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>200</code>：返回码。</li><li><code>612</code>：响应体的大小（字节）。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Nginx 的返回码是排查问题和优化性能的重要依据。通过理解常见的状态码及其含义，可以快速定位问题并采取相应的解决方案。如果需要进一步分析，可以结合 Nginx 的日志和配置进行深入排查。</p>]]></content>
    
    
    <categories>
      
      <category>default</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识梳理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次千辛万苦的部署</title>
    <link href="/2025/01/30/2025-01-30-%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%83%E8%BE%9B%E4%B8%87%E8%8B%A6%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
    <url>/2025/01/30/2025-01-30-%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%83%E8%BE%9B%E4%B8%87%E8%8B%A6%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="Started"><a href="#Started" class="headerlink" title="Started"></a>Started</h1><p>GitHub Pages 是 GitHub 提供的一个免费的静态网站托管服务，它允许 GitHub 用户创建和托管自己的静态网站，这些网站可以通过特定的 GitHub 仓库进行管理和托管。<br>因此笔者想通过githubpage搭建一套属于自己的个人博客，遂查询资料，主要参考：<a href="https://chirpy.cotes.page/posts/getting-started/%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C">https://chirpy.cotes.page/posts/getting-started/进行操作</a><br>步骤大致如下</p><ol><li>有一个自己的github账号</li><li>使用<a href="https://github.com/cotes2020/chirpy-starter">https://github.com/cotes2020/chirpy-starter</a> 这个启动器模版创建一个公共仓库，命名为*.github.io即可</li><li>最好有一个自己的域名</li><li>在pages中配置好域名以及使用github actions来源，在build and deployment标签下</li><li>将任何提交推送到 GitHub 以触发 “操作 “工作流。在版本库的 “操作 “选项卡中，你应该能看到 “构建和部署 “工作流正在运行。一旦构建完成并成功，网站将自动部署。<br>现在你就可以愉快的看到自己的个人博客了，由于jekyll没有后端，因此需要自己在根目录的_posts文件夹中编写markdown文件，文件命名要求如下：YYYY-MM-DD-TITLE.EXTENSION的新文件，并将其放在根目录的 _posts 中。EXTENSION 必须是 md 和 markdown 中的一个。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Deploy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
